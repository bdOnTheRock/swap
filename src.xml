<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;
using pdb.gen.albums;
using pdb.gen.Tuning;
using pdb.gen;
using System.Windows.Threading;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(TrackListViewModel t)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext");
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(f);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }

                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.Track);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = pl.FindTrack(item.PieceId);
                            if (!tl.Exists)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (item.VirtualClassement == 0m)
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    reset(provider, choose, state == playerstate.play);
                    var coll = PresentationTracks;
                    coll.MoveCurrentTo(choose);
                    focus(choose);

                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                   // focus(item);
                    if (playing && autoPlay)
                    {
                        player.play(item.Location, true);
                    }
                   // focus(item);
                }

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

              //  focus(item);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
                focus(item);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }

        public void focusHelp()
        {
            var t = TrackListViewModel.CurrentPlaying;
            if (t == null)
                t = TrackListViewModel.HumanSelected;
            if (t == null) return;
            focus(t); 
        }
        private void focus(TrackListViewModel t)
        {
            if (provider == null)
                return;
            provider.Focus(t);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    confAlbumSort.auto(p);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            var currentPlaying = TrackListViewModel.CurrentPlaying; 
                            tracks.MoveCurrentTo(currentPlaying);
                            provider.Focus(currentPlaying);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext;

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }
            private bool toClear;

            private void calc()
            {
                step = "calc";
                try
                {
                    if (string.IsNullOrEmpty(filter) && !filterNext)
                    {
                        toClear = true;
                        apply();
                        return;
                    }
                    toClear = false;

                    filter = filter.Trim().ToLower().removeAccent();
                    //if (string.IsNullOrWhiteSpace(filter) && !filterNext && conf.includeVirtual && conf.includeVirtualArtist)
                    //{
                    //    clear(); 
                    //    return;
                    //}

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (conf.onlyMaster && vitem.Piece.Parent != null)
                            continue; 
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualByArtist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;
                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualByArtist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }




            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }


                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {
                        if (toClear)
                        {
                            log.log("clear filter");
                            coll.Filter = null;
                            log.log("fin clear filter");
                            return;
                        }

                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                        PlayerViewModel.Instance.makeResume();
                        PlayerViewModel.Instance.focusHelp(); 
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply),App.DISPATCHER_PRIORITY);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);

        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
            {
                string newResume = resume;
                try
                {

                    IEnumerable items = null;
                    var provider = DisplayProvider;
                    if (provider == null)
                        return;
                    var tracks = provider.PresentationTracks;
                    int nbOrg = -1;
                    items = tracks;
                    if (items == null)
                        return;

                    var selected = provider.SelectedTracks;
                    if (selected.Count > 1)
                    {
                        items = selected;
                        nbOrg = 0;
                        foreach (TrackListViewModel t in tracks)
                            nbOrg++;
                    }
                    int nb = 0, nbSelected = 0, nbPresent = 0;
                    TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                    HashSet<int> h = new HashSet<int>();

                    foreach (TrackListViewModel track in items)
                    {
                        if (!h.Add(track.PieceGen.MasterId))
                            continue;
                        nb++;
                        duration += track.Duration;
                        if (track.Enabled)
                        {
                            nbSelected++;
                            durationSelected += track.Duration;
                        }
                        if (track.Exists)
                        {
                            nbPresent++;
                            durationPresent += track.Duration;
                        }
                    }

                    ITextWriter sb = new pdb.util.StringBuilder();
                    sb.Append(nb);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    if (nbOrg >= 0)
                    {
                        sb.Append(" sur ");
                        sb.Append(nbOrg);
                        sb.Append(",");
                    }
                    sb.Append(" ");
                    humanDuration(sb, duration);
                    sb.Append(" ( ");
                    sb.Append(nbSelected);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nbSelected > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationSelected);

                    sb.Append(" )");

                    if (nbPresent > 0)
                    {
                        sb.Append(" presents: ");
                        sb.Append(nbPresent);
                        sb.Append(" ");
                        sb.Append("elt");
                        if (nb > 1)
                            sb.Append("s");
                        sb.Append(" ");
                        humanDuration(sb, durationPresent);
                    }
                    sb.Append("\t");

                    var currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        humanSize(sb, currentTrack.Size);
                        sb.Append(" ");
                        sb.Append(currentTrack.getLocation());
                    }

                    newResume = sb.ToString();

                }
                catch (Exception e0)
                {
                    App.log.log(e0.ToString());
                }
                finally
                {
                    if (newResume != resume)
                    {
                        resume = newResume;
                        if (resumeChange != null)
                        {
                            try
                            {
                                resumeChange(this, EventArgs.Empty);
                            }
                            catch (Exception ex)
                            {
                                App.log.log(ex.ToString());
                            }
                        }
                    }
                }
            }
            else
            {
                App.Current.Dispatcher.BeginInvoke(new Action(makeResume),App.DISPATCHER_PRIORITY);
            }

        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfFilterW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfFilterW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Paramètres de filtre" Height="288" Width="329">
    <Grid Height="188" Width="268">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>


        <CheckBox VerticalAlignment="Center" Grid.Row="0" Grid.Column="0" Name="includeVirtual" ToolTip="Inclure les éléments virtuels" />
        <CheckBox VerticalAlignment="Center" Grid.Row="1" Grid.Column="0" Name="includeVirtualAlbum" ToolTip="Inclure les albums virtuels par artiste" />
        <CheckBox VerticalAlignment="Center" Grid.Row="2" Grid.Column="0" Name="includeId" ToolTip="Inclure la recherche par ID" />
        <CheckBox VerticalAlignment="Center" Grid.Row="3" Grid.Column="0" Name="onlyId" ToolTip="Recherche exclusivement par ID" />
        <CheckBox VerticalAlignment="Center" Grid.Row="4" Grid.Column="0" Name="family" ToolTip="Recherche étendue aux éléments apparentés" />
        <CheckBox VerticalAlignment="Center" Grid.Row="5" Grid.Column="0" Name="master" ToolTip="Restreindre aux masters" />



        <Label Grid.Row="0" Grid.Column="1" Content="Inclure les éléments virtuels" />
        <Label Grid.Row="1" Grid.Column="1" Content="Inclure les albums virtuels par artiste" />
        <Label Grid.Row="2" Grid.Column="1" Content="Inclure la recherche par ID" />
        <Label Grid.Row="3" Grid.Column="1" Content="Recherche exclusivement par ID" />
        <Label Grid.Row="4" Grid.Column="1" Content="Recherche étendue aux éléments apparentés" />
        <Label Grid.Row="5" Grid.Column="1" Content="Restreindre aux masters" />

        <StackPanel Grid.Row="6" Grid.Column="1" Orientation ="Horizontal" HorizontalAlignment="Right"  Height="30" Width="150">
            <Button Name="Cancel" Content="Cancel" Click="Cancel_Click"></Button>
            <Button Name="Ok" Content="Ok" Click="Ok_Click"></Button>
        </StackPanel>
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfFilterW.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.gen.Tuning;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfFilterW.xaml
    /// </summary>
    public partial class ConfFilterW : Window
    {
        private ConfFilter conf; 
        public ConfFilterW()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(ConfFilterW_Loaded);
            
        }

        public ConfFilterW(ConfFilter conf)
            : this()
        {
            this.conf = conf; 
        }

        private void display()
        {
            includeVirtual.IsChecked = conf.includeVirtual;
            includeVirtualAlbum.IsChecked = conf.includeVirtualArtist;
            includeId.IsChecked = conf.includeId;
            family.IsChecked = conf.family;
            onlyId.IsChecked = conf.onlyId;
            master.IsChecked = conf.onlyMaster; 
        }

        private void record()
        {
            conf.includeId = includeId.IsChecked.Value;
            conf.includeVirtual = includeVirtual.IsChecked.Value;
            conf.includeVirtualArtist = includeVirtualAlbum.IsChecked.Value;
            conf.onlyId = onlyId.IsChecked.Value;
            conf.family = family.IsChecked.Value;
            conf.onlyMaster = master.IsChecked.Value; 

        }

        void ConfFilterW_Loaded(object sender, RoutedEventArgs e)
        {
            Ok.IsDefault = true;
            display(); 
        }



        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            Close(); 
        }

        private void Ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close(); 
        }

       
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;
using pdb.obj;
using System.Text.RegularExpressions;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(_med0.d); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                var status = "";
                if (_virtual)
                    status = "v";
                if (_virtualByArtist)
                    status = "va";
                logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {

            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceClassementComparer(false));
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }


        //  private bool sortDone;
        DecimalIndex _med0;
        DecimalIndex med;
        public void makeSort(ConfAlbumSort conf, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;

            try
            {
                //if (!sortDone)
                //    misc.log("make sort {0}", name);
                //misc.log("make sort SortValue {0}", name); 
                selectedCoeff = util.selectedCoeff.noCoeff;

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                for (int i = 0; i < count; i++)
                {
                    list[i].eraseInfoMedianne();
                }

                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = Album.conf.AlbumMoyOffset;
                //if (!sortDone)
                //{



                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                classed = false;
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }
                //misc.log("make sort Duration {0}", name); 
                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;
                #region calcul brut
                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                this.med = AlbumMedianne.getMedianne(new List<Piece>(list), medianne);


                _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode0, false);
                //equivLight0 = Piece.getClassementEquiv(_med0.d);


                //list.Sort(new PieceClassementComparer(false));
                //listSortedValues = new List<decimal>();
                //for (int i = 0; i < count; i++)
                //    listSortedValues.Add(list[i].VirtualClassement);

                classementValue = this.med.d;
                if (classementValue > 0m)
                    list[this.med.index].Medianne = true;

                #endregion




                //misc.log("make sort calcul brut medianne {0}", name); 









                #endregion
                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion
                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, conf, false, ref i0);

                var med = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode, true);
                classementValueLight = med.d;

                #endregion

                //equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                //moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true));
                    Piece nextZero1 = null;
                    Piece nextZero2 = null;

                    Piece min1 = null;
                    Piece min2 = null;
                    Piece min = null;
                    decimal _min1 = int.MaxValue;
                    decimal _min2 = int.MaxValue;
                    decimal _minzero1 = int.MaxValue;
                    decimal _minzero2 = int.MaxValue;
                    bool realZero = false;
                    foreach (Piece p in list)
                    {
                        var v1 = p.VirtualClassement;
                        var v2 = p.VirtualClassement2;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v1 < _minzero1)
                                {
                                    _minzero1 = v1;
                                    nextZero1 = p;
                                    if (v1 == 0)
                                        realZero = true;
                                }
                            }

                            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v2 < _minzero2)
                                {
                                    _minzero2 = v2;
                                    nextZero2 = p;
                                    if (v2 == 0)
                                        realZero = true;
                                }

                            }



                            if (v1 > 0 && v1 < _min1)
                            {
                                _min1 = v1;
                                min1 = p;
                            }

                            if (v2 > 0 && v2 < _min2)
                            {
                                _min2 = v2;
                                min2 = p;
                            }
                        }
                    }
                    decimal _min = 0;
                    if (_min1 <= _min2)
                    {
                        min = min1;
                        _min = _min1;
                    }
                    else
                    {
                        min = min2;
                        _min = _min2;
                    }

                    Piece nextZero = null;
                    decimal _minzero = int.MaxValue;
                    if (_minzero1 <= _minzero2)
                    {
                        nextZero = nextZero1; _minzero = _minzero1;
                    }
                    else
                    {
                        nextZero = nextZero2; _minzero = _minzero2;
                    }

                    if (nextZero != null)
                    {

                        if (realZero)
                        {
                            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                            // j'applique le seuil que s'il est inférieur à la médiane
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;
                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                            }
                            else
                            {
                                //  var p = list[med.index];
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                Next = nextZero;
                                //if (Next.CoeffVirtuel > 1)
                                //    selectedCoeff = selectedCoeff.main; 
                                //if (_min < _min1)
                                //    selectedCoeff = selectedCoeff.min; 
                            }
                        }
                        else
                        {
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;

                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }

                            }
                            else if (_minzero < classementValueLight)
                            {
                                Next = nextZero;
                                classementValueLight = _minzero;

                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main;
                                if (_minzero < _minzero1)
                                    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }

                            else
                            {
                                Next = min;
                                classementValueLight = _min;
                                //  var p = list[med.index];
                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main;
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            }
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        Next = min;
                        if (min != null)
                        {
                            classementValueLight = _min;
                            // if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                            //if (Next.CoeffVirtuel > 1)
                            //    selectedCoeff = selectedCoeff.main; 
                            //if (_min < _min1)
                            //    selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                        }

                    }

                }

                //if (modeMin > modeMin.non)
                //{
                //    int nb = 0;
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;
                //        if (v > 0 && !p.Enabled)
                //            nb++;
                //        if (modeMin == util.modeMin.orphelin || v > 0)
                //        {
                //            if (p.Enabled && FileRegister.Exist(p.Location))
                //            {

                //                if (v < _min)
                //                {
                //                    _min = v;
                //                    min = p;
                //                }
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        _min = min.VirtualClassement;
                //        if (nb > 0)
                //            _min *= (decimal)nb / (decimal)count;
                //        if (modeMin == modeMin.toujours || _min > classementValueLight)
                //            classementValueLight = _min;
                //    }


                //}
                // equivLight = Piece.getClassementEquiv(classementValueLight);

                //  sortDone = true;


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }

        public void mustRefresh()
        {
            build = false;
            //   sortDone = false;
            selectionDone = false;
            atLeastOneEnabled = false;
            _tracksSortByClassement = null;

        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;
            //if (selectionDone)
            //    return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\obj\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    class StatAlbum
    {
        private string key;
        private int count;

        public void clear()
        {
            count = 0;
        }

        public StatAlbum(string key)
        {
            this.key = key;
        }

        public override bool Equals(object obj)
        {
            if (obj is StatAlbum)
            {
                return key.Equals(((StatAlbum)obj).key);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return key.GetHashCode();
        }

        public int Count { get { return count; } }
        public void record()
        {
            count++;
        }
    }

    class StatAlbums
    {
        private BgDictString0<StatAlbum> dict = new BgDictString0<StatAlbum>();

        public void clear()
        {
            foreach (var stat in dict)
            {
                stat.Value.clear();
            }
        }

        public StatAlbum getStat(Album album)
        {
            var key = album.Key;
            var s = dict[key];
            if (s == null)
            {
                s = new StatAlbum(key);
                dict.Add(key, s);
            }
            return s;
        }
    }


    public enum compressState
    {
        none,
        enCours,
        reload,
        cancel
    }




    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> all;
        protected static Dict<int, PiecePrior> dict;
        protected static Dict<int, PiecePrior> masterDict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();
        protected static Dict<string, string> empreintes = new Dict<string, string>();
        protected static StatAlbums statAlbums = new StatAlbums();

        //  protected static Dictionary<int, object> ids;
        protected static HashSet<int> idCopie;
        protected static HashSet<string> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";
        protected static volatile object _lock = new object();
        protected static Thread thCalcul;
        protected static Thread thCopy;

        protected static bool endCopy;
        protected static bool endCopyFinal;
        protected static compressState copy;
        protected static bool endCalcul;

        protected static compressState query;

        //protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static ILogger logger = Logger.getLogger("export");

        protected static void sendCancel()
        {
            lock (_lock)
            {
                if (query < compressState.cancel)
                    query = compressState.cancel;
            }
        }
        protected static compressState Query
        {
            get
            {
                lock (_lock)
                    return query;
            }
            set
            {
                lock (_lock)
                    query = value;
            }
        }





        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (Query)
            {
                case compressState.none:
                    break;
                case compressState.enCours:
                    //if (checkSthChange())
                    //{
                    //PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.reload;
                    //lock (_lock)
                    //    state = compressState.reload;
                    //}
                    break;
                case compressState.cancel:
                    PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.none;
                    break;
                default:
                    break;
            }
        }

        private static bool checkSthChange()
        {
            bool ret = false;
            foreach (PlayListViewModel pl in playlists)
            {
                var emp = empreintes[pl.Name];
                logger.log("{0} ancienne empreinte {1}", pl.Name, emp);
                var _newEmpre = pl.getEmpreinte();
                logger.log("{0} nouvelle empreinte {1}", pl.Name, _newEmpre);
                if (emp != _newEmpre)
                {
                    logger.log("on recalcule");
                    ret = true;
                }
                empreintes[pl.Name] = _newEmpre;

            }
            return ret;

        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }

            public override bool Equals(object obj)
            {
                var o = obj as PiecePrior;
                if (o == null)
                    return false;
                return PieceGen.PieceId == o.PieceGen.PieceId;
            }

            public override int GetHashCode()
            {
                return PieceGen.PieceId.GetHashCode();
            }

            public CListFile Files { get { return (PieceGen.Track as CPiece).Files; } }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            // public int MasterId { get { return Piece.MasterId; } }
            public int PieceId { get { return PieceGen.PieceId; } }
            public int MasterId { get { return PieceGen.MasterId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;            
            }

            public void setPrior0(int prior)
            {
                if (prior < this.prior0)
                    this.prior0 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                var _indexExport = PieceGen.IndexExport; 
                int indexExport = 0;
                if (_indexExport < 10000 && _indexExport >=0)
                    indexExport = PieceGen.IndexExport + 1;
                return string.Format("{0} {1} {2}\t {3} {4} {5} {6} {7}", rank, nb, PieceGen.TrackNumber, prior0, prior1, indexExport, PieceGen.PieceAlbum.Key, PieceGen.Name);
                //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (Query <= compressState.none)
                record();
            else
            {
                sendCancel();
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }
        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return x.Index.CompareTo(y.Index);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual void buildList(PlayListViewModel pl)
        {

            var list = new List<PiecePrior>();
            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                // var ids = new Dictionary<int, object>();
                int i = 0;
                var tracks = new List<TrackListViewModel>(pl.ExportTracks);
                logger.log("export::buildList {0} {1} elements", pl, tracks.Count);
                if (conf.albumReverse)
                {
                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));

                int lastI = 0;
                Album lastAlbum = null;
                StatAlbum lastStatAlbum = null;
                //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                int limitMax = int.MaxValue;
                if (conf.modeAlbum)
                {
                    nbByAlbum = conf.nbMax;
                    limitMax = conf.limitMax;
                    if (limitMax < nbByAlbum)
                        limitMax = nbByAlbum;
                }
                int nbLot = 0;
                int ii = -1;
                var ids = new HashSet<int>();
                while (true)
                {

                    if (query != compressState.enCours)
                        return ;
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        if (query != compressState.enCours)
                            return ;
                        int id = track.PieceId;
                        if (ids.Contains(id))
                            continue; 
                        ii++;
                       

                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            // CPiece piece = track.Piece;
                            if (track.Exists)
                            {
                                var pp = dict[id]; // list.Add(piece);
                                if (pp == null)
                                {
                                    pp = new PiecePrior(track.PieceGen, ii);
                                    dict[id] = pp;
                                }

                                //var masterId = track.MasterId;
                                //if (ids.Add(masterId))
                                //{
                                //    presents.Add(pp);
                                //}



                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        lastStatAlbum = statAlbums.getStat(lastAlbum);
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;

                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }

                                    // pp.setPrior(i);
                                    list.Add(pp);
                                    lastStatAlbum.record();
                                    ids.Add(id); 

                                    i++;

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;

                                        limitMax = conf.limitMax;
                                        if (limitMax < nbByAlbum)
                                            limitMax = nbByAlbum;

                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;

                                                limitMax = conf.limitMax;
                                                if (limitMax < nbByAlbum)
                                                    limitMax = nbByAlbum;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            var piece = p.Track as CPiece;
                                            if (piece != null && piece.Exists)
                                            {
                                                if (!onlyEnabled || piece.Enabled)
                                                {
                                                    id = p.PieceId;

                                                    //if (ids.Contains(id))
                                                    //    continue;
                                                    var ppp = dict[id];
                                                    // ppp.setPrior(i);
                                                    list.Add(ppp);
                                                    //   ids.Add(id);
                                                    i++;
                                                    if (piece.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;

                                                            limitMax = conf.limitMax;
                                                            if (limitMax < nbByAlbum)
                                                                limitMax = nbByAlbum;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                            break;
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;

                        limitMax = conf.limitMax;
                        if (limitMax < nbByAlbum)
                            limitMax = nbByAlbum;
                    }
                }
                listes.Add(list);
                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
           
        }

        public override string Header
        {
            get
            {
                if (query == compressState.enCours || query == compressState.reload)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (Query == compressState.none)
            {

                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    Query = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear(); empreintes.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                empreintes[pl.Name] = pl.getEmpreinte();
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                //listes = new List<List<PiecePrior>>();
                playlists.Clear(); empreintes.Clear();
                Query = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            waitCalculForEnd();

            Query = compressState.enCours;

            lock (_lock)
            {
                if (thCalcul == null)
                {
                    thCalcul = new Thread(calculLoop);
                    thCalcul.SetApartmentState(ApartmentState.STA);
                    thCalcul.Start();
                }

                if (thCopy == null)
                {
                    thCopy = new Thread(copyLoop);
                    thCopy.SetApartmentState(ApartmentState.STA);
                    thCopy.Start();
                }
            }


            OnPropertyChanged("Header");
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            logger.log("export:buildListIni");
            lock (_lock)
            {
                statAlbums.clear();
                listes = new List<List<PiecePrior>>();
                all = new List<PiecePrior>();
                dict = new Dict<int, PiecePrior>();
                masterDict = new Dict<int, PiecePrior>();
            }
            //  locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                    l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {

                    if (query != compressState.enCours)
                        return;
                    //var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(p.PieceId))
                    {
                        var pp = new PiecePrior(p, i);
                        i++;
                        all.Add(pp);
                        dict[p.PieceId] = pp;

                        //var piece = p.Track as CPiece;
                        //foreach (CFile file in piece.Files)
                        //{
                        //    var lp = locations[file.File];
                        //    if (lp == null)
                        //    {
                        //        lp = new List<PiecePrior>();
                        //        lp.Add(pp);
                        //        locations.Add(file.File, lp);
                        //    }
                        //    else
                        //    {
                        //        lp.Add(pp);
                        //        PiecePrior.mergePrior0(lp);
                        //    }
                        //}

                        var masterId = p.MasterId;
                        if (!masterDict.ContainsKey(masterId))
                            masterDict[masterId] = pp;


                    }
                }

                foreach (Piece p in l)
                {
                    if (query != compressState.enCours)
                        return;
                    dict[p.PieceId].setPrior0(masterDict[p.MasterId].Prior0);
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        private void waitCalculForEnd()
        {
            lock (_lock)
            {

                if (query == compressState.none)
                    return;
                if (query == compressState.enCours)
                    query = compressState.cancel;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                    if (endCalcul)
                        return;
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Calcul");
                }
            }

        }


        private void waitCopyForEnd()
        {
            lock (_lock)
            {
                if (copy == compressState.none)
                    return;
                if (copy == compressState.enCours)
                    copy = compressState.cancel;
                if (endCopy)
                    return;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                {
                    if (endCopy)
                        return;
                    if (query != compressState.enCours)
                    {
                        logger.log("abandon attente car query={0}", query);
                        return;
                    }
                }
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Copy");
                }
            }

        }


        [STAThread]
        private void copyLoop()
        {
            while (true)
            {
                try
                {
                    compressState _cp;
                    lock (_lock)
                        _cp = copy;
                    if (_cp != compressState.enCours)
                    {
                        Thread.Sleep(1000);
                        continue;
                    }

                    _copy();
                }

                catch (Exception ex)
                {
                    logger.log(ex.ToString());
                }
            }
        }


        [STAThread]
        private void calculLoop()
        {


            while (true)
            {
                try
                {
                    switch (Query)
                    {
                        case compressState.none: Thread.Sleep(1000); continue;

                        case compressState.enCours:
                            if (endCopyFinal)
                            {
                                Thread.Sleep(1000); continue;
                            }
                            break;
                        case compressState.reload:
                            waitCalculForEnd();
                            break;

                        case compressState.cancel:
                            {
                                waitCalculForEnd();
                                waitCopyForEnd();
                                Query = compressState.none;
                                nbLoop = 0;
                                Thread.Sleep(1000); continue;
                            }

                        default:
                            break;
                    }
                    lock (_lock)
                    {
                        endCalcul = false;
                        query = compressState.enCours;
                        nbLoop++;
                    }



                    buildListIni();

                    if (query != compressState.enCours)
                        return;

                    foreach (PlayListViewModel pl in playlists)
                    {
                        buildList(pl);
                        if (query != compressState.enCours)
                            return;
                    }

                    //foreach (List<PiecePrior> lp in locations.Values)
                    //{
                    //    PiecePrior.mergePrior1(lp);
                    //}

                    // concaténation
                    int max = 0;
                    list = new List<PiecePrior>();
                    foreach (var _l in listes)
                    {
                        if (query != compressState.enCours)
                            return;
                        var count_ = _l.Count;
                        if (count_ > max)
                            max = count_;
                    }
                    int count = listes.Count;

                    int nb = 0;
                    for (int i = 0; i < max; i++)
                    {
                        if (query != compressState.enCours)
                            return;
                        for (int j = 0; j < count; j++)
                        {
                            var l = listes[j];
                            if (i < l.Count)
                            {
                                var p = l[i];
                                p.setPrior(nb);
                                list.Add(p);
                                var master = masterDict[p.MasterId];
                                if (master != p)
                                    master.setPrior(nb);
                                nb++;
                            }
                        }
                    }

                    for (int i = 0; i < list.Count; i++)
                    {
                        if (query != compressState.enCours)
                            return;
                        var p = list[i];
                        var master = masterDict[p.MasterId];
                        if (master != p)
                            p.setPrior(master.Prior1);
                    }

                    list.Sort(new PriorComparer());
                    all.Sort(new PriorComparer());

                    waitCopyForEnd();
                    lock (_lock)
                    {
                        if (query != compressState.enCours)
                            continue;
                        App.log.log("Export lancé " + listes.Count + " liste" + (listes.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                        endCopy = false; copy = compressState.enCours; endCopyFinal = false;
                    }

                    while (true)
                    {
                        Thread.Sleep(100);

                        if (endCopy || query != compressState.enCours)
                            break;

                    }


                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                    Thread.Sleep(1000);
                }

                finally
                {
                    lock (_lock)
                        endCalcul = true;


                }

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state;
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state;
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
            //  }
        }
        [STAThread]
        private void _copy()
        {
            PlayListViewModel.resetExport(exportState.none);
            try
            {
                List<PiecePrior> _list = null;
                lock (_lock)
                {
                    _list = new List<PiecePrior>(list);
                }
                foreach (PiecePrior piece in _list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Files;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            setExport(exportState.present, piece);
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new HashSet<int>();
                idCopieLoc = new HashSet<string>();
                //  presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;

                        int id = piece.PieceGen.MasterId;
                        if (idCopie.Contains(id))
                            continue;
                        var files = piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.Contains(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie.Add(id); // idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc.Add(file.File); // [file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                var f = FileRegister.Check(pertinent.Path); //  FileInfo f = new  FileInfo FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece.PieceGen + " )");
                                f.copyTree(conf.dir + pertinent.File, true);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                compressState _copy;
                lock (_lock)
                    _copy = copy;

                if (Query != compressState.none && _copy != compressState.none)
                {
                    var _status = string.Format("statusCalc={0} statusCopy={1} calc={2} copy={3}", endCalcul, endCopy, query, copy);
                    var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6} {7}",
                        listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""), _status);
                    App.log.log(log, CAPTION);
                    if (conf.oneShot)
                        ihm.InfoIHm(log, CAPTION);
                    //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                    //list = new List<PiecePrior>();
                    //listes = new List<List<PiecePrior>>(); 

                    if (_copy == compressState.enCours)
                    {
                        endCopyFinal = true;
                        // PlayListViewModel.resetExport(exportState.none);
                    }

                    OnPropertyChanged("Header");
                }

                lock (_lock)
                {
                    endCopy = true;
                    copy = compressState.none;
                }
                //var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                //    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                //App.log.log(log, CAPTION);
                //if (conf.oneShot)
                //    ihm.InfoIHm(log, CAPTION);
                ////  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                //list = null;
                //listes = null;

                //if (state == compressState.enCours)
                //{
                //}
                //else
                //    PlayListViewModel.resetExport(exportState.none);

                //lock (_lock)
                //    state = compressState.end;
                //OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfAlbumSort.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Xml;
using pdb.util;
using System;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    [Serializable]
    /// <summary>
    /// Configuration sort Albums
    /// </summary>
    public class ConfAlbumSort : TuningBase
    {

        private List<ConfMedianne> composants = new List<ConfMedianne>();
        private List<ConfMedianne> composantsUtiles = new List<ConfMedianne>();
        public List<ConfMedianne> Composants { get { return composants; } }
        public List<ConfMedianne> ComposantsUtiles { get { return composantsUtiles; } }
        // public decimal coeffEnabled = 1m;
        public int stackSize = 0;
        public int stackPeremption = 10;
        public decimal stackPower = 2.0m;
        public int stackBefore = 0;
        public bool checkStack = false;
        public bool stackEnabled = true;
        public DateTime lastModif;
        public DateTime newA;
        public bool createCourant = true;
        public bool createInter = true;
        public bool createAll;
        // public bool oldAsZero; 
        public void Calcul()
        {
            composantsUtiles = new List<ConfMedianne>();
            foreach (var cmp in composants)
            {
                if (cmp.enabled)
                    composantsUtiles.Add(cmp);
            }
            if (composantsUtiles.Count == 0)
                composantsUtiles.Add(composants[0]);
        }
        public ConfAlbumSort()
        {
        }

        public ConfAlbumSort(XmlElement node)
            : base(node)
        {

            composants.Clear();
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    var cmp = new ConfMedianne(node, sub as XmlElement);
                    composants.Add(cmp);
                }
            }


            buildi("stackSize", v => stackSize = v);
            buildi("stackPeremption", v => stackPeremption = v);
            buildi("stackBefore", v => stackBefore = v);
            builddec("stackPower", v => stackPower = v); 

            buildb("stackEnabled", v => stackEnabled = v);
            buildb("checkStack", v => checkStack = v);
            buildDate("lastModif", v => lastModif = v);
            buildDate("newA", v => newA = v);
            buildb("createCourant", v => createCourant = v);
            buildb("createInter", v => createInter = v);
            buildb("createAll", v => createAll = v);



            Calcul();

        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("albumSort");

            write("stackSize", stackSize);
            write("stackPeremption", stackPeremption);
            write("stackBefore", stackBefore);
            write("stackPower", stackPower);

            write("stackEnabled", stackEnabled);
            write("checkStack", checkStack);
            write("lastModif", lastModif);
            write("newA", newA);
            write("createCourant", createCourant);
            write("createInter", createInter);
            write("createAll", createAll);

            foreach (var cmp in composants)
                cmp.save(w);
            writeEnd();
        }
        public bool Enabled
        {
            get
            {
                foreach (var cmp in composants)
                {
                    if (cmp.enabled)
                        return true;
                }
                return false;
            }
        }

        public void auto(Piece p)
        {
            try
            {
                if (checkStack && p.PieceAlbum != null && p.PieceAlbum.Empeached)
                    return;
                if (p.Added > newA)
                    return;
                var motif = p.SelectedMotif;
                if (p.SelectedMotif == selectedCoeff.none)
                    return;
                foreach (var cmp in composants)
                {
                    cmp.auto(motif);
                }
            }
            finally
            {
                foreach (Piece pp in p.Master)
                {
                    pp.Empeached = false;
                    pp.Empeached1 = false;
                }
            }
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfFilter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;

namespace pdb.gen.Tuning
{
    public class ConfFilter : TuningBase
    {
        public bool includeVirtual;
        public bool includeVirtualArtist;
        public bool includeId;
        public bool onlyId;
        public bool family;
        public bool onlyMaster; 

        public ConfFilter()
            : base()
        {
        }

        public ConfFilter(XmlElement node)
            : base(node)
        {
            buildb("includeVirtual", v => includeVirtual = v);
            buildb("includeVirtualArtist", v => includeVirtualArtist = v);
            buildb("includeId", v => includeId = v);
            buildb("onlyId", v => onlyId = v);
            buildb("family", v => family = v);
            buildb("onlyMaster", v => onlyMaster = v); 
        }
    }
}
]]></content>
  </file>
</db>
