<db path="C:\bernard\db2\">
   <file path="db4\pdb.player\ViewModel\DetailClassementViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Data;
using System.Windows.Input;
using pdb.gen.stat;
using pdb.player.ViewModel.Commande;
using pdb.obj;
using pdb.util;
using System.Threading;

namespace pdb.player.ViewModel
{
    enum ihmInDispo
    {
        none,
        rot,
        stat
    }

    public interface IRecordClassmentObserver
    {
        void signalClassementChange();
        void autoNextTrack(TrackListViewModel currentPlaying);
    }
    public interface IClassementObserver
    {
        void signalClassementChange(IClient client);
    }
    class DetailClassementViewModel : ViewModelBase
    {
        private static DetailClassementViewModel _instance;
        public static DetailClassementViewModel Instance { get { return _instance; } }
        private static IRecordClassmentObserver recordClassementObserver;
        public static IRecordClassmentObserver RecordObserver { set { recordClassementObserver = value; } }
        // private CPlayList _root;
        private PlayListViewModel currentClassList;
        private TrackListViewModel currentTrack;


        //   private CPlayList _currentClassList;
        private ICommand cmdRecord;
        private IClassementObserver ihm;
        public DetailClassementViewModel(IClassementObserver ihm)
        {
            this.ihm = ihm;
            cmdRecord = new RecordClassement(this);
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler<ClientEventArgs>(TrackListViewModel_CurrentSelectedChanged);
            //this._root = root.getOrCreate("classement");
            //_currentClassList = _root;
            // findCurrentPlaylist();
            _instance = this;
        }

        void TrackListViewModel_CurrentSelectedChanged(object sender, ClientEventArgs e)
        {
            App.Dispatch(() =>
            {
                //if (currentTrack == null)
                //{
                if (currentTrack != TrackListViewModel.HumanSelected)
                {
                    currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        setClassment(currentTrack.Classement, e.client);
                        Name = currentTrack.Name;
                    }
                    //  OnPropertyChanged(""); 

                }
            }, e.client);
            //}
        }

        private bool onlyDisabled = false;
        public bool OnlyDisabled
        {
            get { return onlyDisabled; }
            set
            {
                if (value != onlyDisabled)
                {
                    onlyDisabled = value;
                    OnPropertyChanged("OnlyDisabled");
                }
            }
        }


        private bool uncheckAfter = false;
        public bool UncheckAfter
        {
            get { return uncheckAfter; }
            set
            {
                if (value != uncheckAfter)
                {
                    uncheckAfter = value;
                    OnPropertyChanged("UncheckAfter");
                }
            }
        }

        private bool auto = true;
        public bool Auto
        {
            get { return auto; }
            set
            {
                if (value != auto)
                {
                    auto = value;
                    OnPropertyChanged("Auto");
                }
            }
        }

        private ihmInDispo inDispo;
        public ihmInDispo IhmInDispo
        {
            get { return inDispo; }
            set
            {
                if (value != inDispo)
                {
                    inDispo = value;
                    OnPropertyChanged("IhmInDispo");
                }
            }
        }


        public string Name
        {
            get { if (currentTrack != null) return currentTrack.Name; return ""; }
            set { OnPropertyChanged("Name"); }
        }
        private string classement = "-";
        public string Classement
        {
            get { return classement; }
            set
            {
                setClassment(value, null);
            }

        }

        public void setClassment(string value, IClient client)
        {
            if (value != classement)
            {
                if (isClassment(value))
                {
                    classement = value;
                    if (this.client != null)
                        this.client.cancel();
                    //var client = new SimpleClient("buildStat\t", Logger.getLogger("Classement"));
                    if (client == null)
                        client = new SimpleClient("buildStat\t", Logger.getLogger("Classement"));
                    if (client.Cancel)
                        return;
                    client.log(value);
                    this.client = client;


                    if (!client.Cancel)
                    {
                        // waitBeforeSignalClassChange(client, value); 
                        new Thread(() => waitBeforeSignalClassChange(client, value)).Start();
                    }
                }

            }
        }


        private void waitBeforeSignalClassChange(IClient client, string value)
        {
            Thread.Sleep(30);
            if (client.Cancel)
                return;
            findCurrentPlaylist(client);
            if (client.Cancel)
                return;
            client.log("fin stats " + value);
            Thread.Sleep(30);
            if (client.Cancel)
                return;
            ihm.signalClassementChange(client);
        }

        public static bool isClassment(string str)
        {
            return pdb.obj.Classement.canBeClassement(str);
        }
        private IClient client;
        private void findCurrentPlaylist(IClient client)
        {
            if (App.bib == null)
                return;
            try
            {
                if (string.IsNullOrEmpty(classement))
                {
                    //  _currentClassList = _root;
                    currentClassList = App.bib.getClass("", true); // new PlayListViewModel(_root);
                }
                else
                {
                    if (!pdb.obj.Classement.canBeClassement(classement))
                        return;

                    currentClassList = App.bib.getClass(classement, true);

                    //var tab = classement.ToCharArray();
                    //var pl = _root;

                    //foreach (char c in tab)
                    //{
                    //    if (c == '.')
                    //        break;
                    //    pl = pl.get(c.ToString());
                    //}
                    //_currentClassList = pl;
                    //  currentClassList = new PlayListViewModel(pl);
                }

                buildStats(client);
            }
            finally
            {
                //  OnPropertyChanged("");
            }
        }

        #region stats
        int d, d0, d1, d2, d3, d4, d5, d01, d23, d45, d02, d35;
        const int NB_ROW = 4;
        const int NB_COL = 6;
        private int[,] tab = new int[NB_ROW, NB_ROW];
        private DynamicStatPair stats; 
       

        private void buildStats(IClient client)
        {
            if (currentClassList == null)
                return;
            if (App.gen == null)
                return;


            stats = App.gen.generStat(client, classement, onlyDisabled);
           
            if (client.Cancel)
                return;
            d0 = get(0); // currentClassList.get("0", false).AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;
            d1 = get(1); // currentClassList.get("1").AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;
            d2 = get(2);  //currentClassList.get("2").AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;
            d3 = get(3); //currentClassList.get("3").AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;
            d4 = get(4); //currentClassList.get("4").AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;
            d5 = get(5); //currentClassList.get("5").AllTracks.FindAll(t => !onlyDisabled || !(t as TrackListViewModel).Enabled).Count;

            d01 = d0 + d1;
            d23 = d2 + d3;
            d45 = d4 + d5;

            d02 = d0 + d1 + d2;
            d35 = d3 + d4 + d5;

            d = d02 + d35;


            //   OnPropertyChanged("");
        }

        //public DataTable Stats
        //{
        //    get
        //    {
        //        if (stats == null)
        //            return null;
        //        var dt = new DataTable();
        //        for (int i = -DynamicStatLigne.SEMI_COLS; i <= DynamicStatLigne.SEMI_COLS; i++)
        //        {
        //            dt.Columns.Add(i.ToString(), typeof(int));
        //        }

        //        foreach (DynamicStatLigne ligne in stats.rows)
        //        {
        //            DataRow row = dt.Rows.Add();
        //            for (int i = -DynamicStatLigne.SEMI_COLS; i <= DynamicStatLigne.SEMI_COLS; i++)
        //            {
        //                row[i.ToString()] = ligne[i];
        //            }

        //        }

        //        return dt;

        //    }
        //}

        public DynamicStat getStats(IClient client)
        {
            if (stats == null)
                buildStats(client);
            return stats.offset;
        }

        private int get(int level)
        {
            if (currentClassList == null)
                return 0;
            if (stats == null)
                return 0;

            int row = 2;
            if (classement.Contains("."))
                row = 4;

            return stats.real[row][level];

            //var sub = currentClassList.get(level.ToString());
            //var pl = currentClassList;
            //int nb = 0;


            //if (onlyDisabled)
            //    nb += currentClassList.AlltracksVmd.Tracks.FindAll(t => t.PieceParentId < 0 && t.Rating == 20 * level).Count;
            //else
            //    nb += currentClassList.AlltracksVm.Tracks.FindAll(t => t.PieceParentId < 0 && t.Rating == 20 * level && (!t.Enabled || t.PieceGen.ClassementProvisoireRecent)).Count;

            //if (sub != null)
            //{
            //    if (onlyDisabled)
            //        nb += sub.AlltracksVmd.AllTracks.FindAll(t => t.PieceParentId < 0).Count;
            //    else
            //        nb += sub.AlltracksVm.AllTracks.FindAll(t => t.PieceParentId < 0 && (!t.Enabled || t.PieceGen.ClassementProvisoireRecent)).Count;
            //}

            //return nb;

            //if (!onlyDisabled)
            //    return tracks.Count;

            //tracks = tracks.FindAll(t => !t.Enabled);

            //return tracks.Count;

        }

        //private int get(string className, int level)
        //{
        //    var currentClassList = App.bib.getClass(className, false);
        //    var sub = currentClassList.get(level.ToString());
        //    List<TrackListViewModel> tracks;
        //    if (sub == null)
        //    {
        //        tracks = currentClassList.Tracks.FindAll(t => t.Rating == 20 * level);
        //    }
        //    else
        //    {
        //        tracks = sub.AllTracks;
        //    }

        //    if (!onlyDisabled)
        //        return tracks.Count;

        //    tracks = tracks.FindAll(t => !t.Enabled);

        //    return tracks.Count;

        //}

        private string getOffset(string classBase, int offset)
        {
            if (string.IsNullOrEmpty(classBase))
                return "";
            return "";
        }

        public int D { get { return d; } }
        public int D0 { get { return d0; } }
        public int D1 { get { return d1; } }
        public int D2 { get { return d2; } }
        public int D3 { get { return d3; } }
        public int D4 { get { return d4; } }
        public int D5 { get { return d5; } }

        public int D01 { get { return d01; } }
        public int D23 { get { return d23; } }
        public int D45 { get { return d45; } }

        public int D02 { get { return d02; } }
        public int D35 { get { return d35; } }
        #endregion

        private List<TrackListViewModel> _list;
        public List<TrackListViewModel> getTracks(IClient client)
        {

            if (_list == null)
            {
                if (App.gen == null)
                    return new List<TrackListViewModel>();
                if (client == null)
                    client = new SimpleClient("ClassementTracks", Logger.getLogger("ClassementTracks"));
                var list = App.gen.getTracks(client, classement, onlyDisabled);
                _list = new List<TrackListViewModel>();
                foreach (var p in list)
                {
                    TrackListViewModel t = TrackListViewModel.getOrCreate(p); // App.bib.Musique.FindTrack(p.PieceId);
                    if (t != null)
                        _list.Add(t);
                }
            }
            return _list;

        }
        public void reset()
        {
            _list = null;
        }
        //public AllTracksViewModel Tracks0
        //{
        //    get
        //    {
        //        AllTracksViewModel tracks = null;
        //        if (currentClassList == null)
        //            return null;
        //        if (onlyDisabled)
        //            tracks = currentClassList.AllTrackFatherDisabled;
        //        else
        //            tracks = currentClassList.AllTrackFather;
        //        if (tracks == null)
        //            return null;
        //        if (!onlyDisabled)
        //            tracks = currentClassList.AllTrackFather; 
        //        tracks.refresh();

        //        return tracks;

        //        //var list = currentClassList.AlltracksVm;
        //        //if (onlyDisabled)
        //        //    list = list.FindAll(t => !t.Enabled);

        //        ////if (currentTrack != null)
        //        ////{
        //        ////    foreach (TrackListViewModel t in list)
        //        ////    {
        //        ////        if (t.Location == currentTrack.Location)
        //        ////            t.IsSelected = true;
        //        ////        else
        //        ////            t.IsSelected = false;
        //        ////    }
        //        ////}
        //        //return currentClassList.AlltracksVm; 
        //        //return list;
        //    }
        //}

        public List<TrackListViewModel> Album
        {
            get
            {
                if (currentClassList == null)
                    return null;
                if (currentTrack == null)
                    return null;
                var tracks = App.getAlbum(currentTrack);
                //foreach (TrackListViewModel t in tracks)
                //{
                //    if (t.Location == currentTrack.Location)
                //        t.IsSelected = true;
                //    else
                //        t.IsSelected = false; 
                //}

                return tracks;
            }
        }



        public TrackListViewModel SelectedTrackInClassView
        {
            get
            {
                if (currentTrack == null | currentClassList == null)
                    return null;
                return currentTrack;
            }
            set
            {
            }
        }

        public TrackListViewModel SelectedTrackInAlbumView
        {
            get
            {
                if (currentTrack == null || currentClassList == null)
                    return null;
                var tracks = Album;
                if (tracks == null || tracks.Count == 0)
                    return null;
                return tracks.Find(t => t.PieceId == currentTrack.PieceId);
            }
            set
            {
            }
        }

        public void record()
        {
            App.Indispo = false;
            if (currentTrack == null)
                return;
            var currentPlaying = TrackListViewModel.CurrentPlaying;
            if (currentPlaying != null && currentPlaying.MasterId != currentTrack.MasterId)
            {
                IIhm ihm = App.Instance;
                if (!ihm.Confirm("Modifier le classement de " + currentTrack + " ?", "Classement"))
                    return;
            }



            currentTrack.Classement = classement;


            if (uncheckAfter)
                currentTrack.Enabled = false;

            if (recordClassementObserver != null)
            {
                recordClassementObserver.signalClassementChange();
                if (auto)
                    recordClassementObserver.autoNextTrack(currentTrack);
            }

        }

        //void IClient.log(string phase)
        //{
        //   if (client ==null)
        //        return; 
        //   client.log(phase); 
        //}

        public bool CanRecord
        {
            get
            {
                return currentTrack != null && currentTrack.Enabled && isClassment(classement);
            }
        }

        public ICommand Record { get { return cmdRecord; } }

        //bool IClient.Cancel
        //{
        //    get
        //    {
        //        if (client ==null)
        //            return false; 
        //        return client.Cancel; 
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\ClassementCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.ClassementCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid Background="{Binding IhmInDispo, Converter={StaticResource dispo},  UpdateSourceTrigger=PropertyChanged}" >
        <!--<Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="3" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>-->
        <!--<DataGrid  Grid.Column="0" DockPanel.Dock="Bottom" 
                       Name="dgAlbum" 
                       AutoGenerateColumns="False" 
                       ScrollViewer.CanContentScroll="True" 
                       SelectedItem="{Binding SelectedTrackInAlbumView}">

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding isSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>

            <DataGrid.Columns>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />
                <DataGridTextColumn Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement}"/>
            </DataGrid.Columns>

        </DataGrid>
        <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" />-->

        <Grid Grid.Column="0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="*" />
                <RowDefinition Height="3" />
                <RowDefinition Height="*" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>

            <Grid Grid.Row="0" Margin="5"  >
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="90" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <CheckBox Grid.Column="0" Style="{StaticResource cb}"  Name="cbEnabled" ToolTip="Afficher seulement les désactivés" IsChecked="{Binding OnlyDisabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <CheckBox Grid.Column="1" Style="{StaticResource cb}"  Name="cbUncheck" ToolTip="Décocher après classement" IsChecked="{Binding UncheckAfter, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <CheckBox Grid.Column="2"  Style="{StaticResource cb}" Name="cbAuto" ToolTip="Passage au morceau suivant automatiquement" IsChecked="{Binding Auto, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <TextBox Grid.Column="3"  Name="TbClass"   Text="{Binding Classement, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource cl} }" PreviewKeyDown="TbClass_PreviewKeyDown" MouseEnter="TbClass_MouseEnter" PreviewMouseDown="TbClass_PreviewMouseDown" MouseLeave="TbClass_MouseLeave"  />
                <TextBox Grid.Column="4"  Name="TbName" Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                <Button Grid.Column="5" Name="btRecord" DockPanel.Dock="Right" Content="Enregistrer"  Command="{Binding Record,UpdateSourceTrigger=PropertyChanged}" 
                        />

            </Grid>


            <!--<ListView  DockPanel.Dock="Top" Grid.Row="0" Name="dg"  ScrollViewer.CanContentScroll="True" >
                <ListView.ItemContainerStyle>
                    <Style TargetType="{x:Type ListViewItem}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <Trigger Property="IsSelected" Value="True">
                                <Setter Property="FontWeight" Value="Bold" />
                            </Trigger>
                        </Style.Triggers>
                    </Style>
                </ListView.ItemContainerStyle>
                <ListView.View>
                    <GridView>
                        <GridViewColumn DisplayMemberBinding="{Binding Enabled}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Name}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Classement}"/>
                    </GridView>
                </ListView.View>
            </ListView>-->

            <l:EnhancedDataGrid Grid.Row="1" AutoGenerateColumns="False"  DockPanel.Dock="Top" x:Name="dg" x:Uid="classement"  ScrollViewer.CanContentScroll="True" ConfCouleur="classement" >
                <!--SelectedItem="{Binding SelectedTrackInClassView}" >-->
                <DataGrid.ContextMenu>
                    <ContextMenu>
                        <MenuItem Header="infos" Command="{Binding}"/>
                    </ContextMenu>
                </DataGrid.ContextMenu>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <!--<Trigger Property="IsSelected" Value="True">
                                <Setter Property="Foreground" Value="Brown" />
                            </Trigger>
                            <DataTrigger Binding="{Binding Exists}" Value="False">
                                <Setter Property="Foreground" Value="LightGray" />
                            </DataTrigger>-->

                        </Style.Triggers>
                    </Style>
                </DataGrid.ItemContainerStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <EventSetter Event="MouseDoubleClick" Handler="dgMouseDoubleClick" />
                        <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=classement,  UpdateSourceTrigger=PropertyChanged}" />
                       
                        <!--<Style.Triggers>
                            <Trigger Property="DataGridRow.IsSelected" Value="True">
                                <Setter Property="DataGridRow.Background" Value="Brown" />
                            </Trigger>
                          

                        </Style.Triggers>-->
                    </Style>
                </DataGrid.RowStyle>
                <DataGrid.Columns>
                    <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />-->
                    <DataGridTemplateColumn Header="" >
                        <DataGridTemplateColumn.CellTemplate>
                            <DataTemplate>
                                <CheckBox Style="{StaticResource cb}"  IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                            </DataTemplate>
                        </DataGridTemplateColumn.CellTemplate>
                    </DataGridTemplateColumn>
                    <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                    <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl} }"/>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                    <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                    <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay}"/>
                    <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                    <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                    <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                    <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>


                </DataGrid.Columns>

            </l:EnhancedDataGrid>


            <GridSplitter Grid.Row="2" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True" />

            <!--<Grid Grid.Row="3" HorizontalAlignment="Stretch">
                <DataGrid ItemsSource="{Binding}" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" 
                       Name="dgStat"  IsReadOnly="True"
          Width="{Binding RelativeSource={RelativeSource AncestorType={x:Type DockPanel}}, Path=ActualWidth}"
                       AutoGenerateColumns="False" >
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="-5" Binding="{Binding -5}"/>
                        <DataGridTextColumn Header="-4" Binding="{Binding -4}"/>
                        <DataGridTextColumn Header="-3" Binding="{Binding -3}"/>
                        <DataGridTextColumn Header="-2" Binding="{Binding -2}"/>
                        <DataGridTextColumn Header="-1" Binding="{Binding -1}"/>
                        <DataGridTextColumn Header="0" Binding="{Binding  0}" >
                            
                        </DataGridTextColumn>
                        <DataGridTextColumn Header="1" Binding="{Binding  1}"/>
                        <DataGridTextColumn Header="2" Binding="{Binding  2}"/>
                        <DataGridTextColumn Header="3" Binding="{Binding  3}"/>
                        <DataGridTextColumn Header="4" Binding="{Binding  4}"/>
                        <DataGridTextColumn Header="5" Binding="{Binding  5}"/>
                    </DataGrid.Columns>
                    <DataGrid.ItemTemplate>
                        <DataTemplate>
                            <TextBlock Text ="{Binding}" Width="Auto"  HorizontalAlignment="Stretch"/>
                        </DataTemplate>
                    </DataGrid.ItemTemplate>
                </DataGrid>
            </Grid>-->
            <Grid Name="tab" Grid.Row="3"  MouseLeftButtonDown="tab_MouseLeftButtonDown"  MouseRightButtonDown="tab_MouseRightButtonDown">

            </Grid>
            <Grid Grid.Row="4">
                <Grid.RowDefinitions>
                    <RowDefinition  Height="Auto"/>
                    <RowDefinition />
                    <RowDefinition />

                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <!--<TextBlock Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3" Name="d02" Text="{Binding D02}" />
            <TextBlock Grid.Row="0" Grid.Column="3" Grid.ColumnSpan="3" Name="d35" Text="{Binding D35}" />
            <TextBlock Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="2" Name="d01" Text="{Binding D01}" />
            <TextBlock Grid.Row="1" Grid.Column="2" Grid.ColumnSpan="2" Name="d23" Text="{Binding D23}" />
            <TextBlock Grid.Row="1" Grid.Column="4" Grid.ColumnSpan="2" Name="d45" Text="{Binding D45}" />-->


                <TextBlock Grid.Row="1"  Grid.Column="0" Name="d" Text="{Binding D}" />
                <TextBlock Grid.Row="1" Grid.Column="1" Name="d02" Text="{Binding D02}" />
                <TextBlock Grid.Row="1" Grid.Column="2" Name="d35" Text="{Binding D35}" />
                <TextBlock Grid.Row="1" Grid.Column="3" Name="d01" Text="{Binding D01}" />
                <TextBlock Grid.Row="1" Grid.Column="4" Name="d23" Text="{Binding D23}" />
                <TextBlock Grid.Row="1" Grid.Column="5" Name="d45" Text="{Binding D45}" />
                <TextBlock Grid.Row="2" Grid.Column="0" Name="d0" Text="{Binding D0}" />
                <TextBlock Grid.Row="2" Grid.Column="1" Name="d1" Text="{Binding D1}" />
                <TextBlock Grid.Row="2" Grid.Column="2" Name="d2" Text="{Binding D2}" />
                <TextBlock Grid.Row="2" Grid.Column="3" Name="d3" Text="{Binding D3}" />
                <TextBlock Grid.Row="2" Grid.Column="4" Name="d4" Text="{Binding D4}" />
                <TextBlock Grid.Row="2" Grid.Column="5" Name="d5" Text="{Binding D5}" />
            </Grid>

        </Grid>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants - sans les virtuels 
        /// </summary>
        private List<Piece> listPieceInAlbumReal = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool classementChange;
        private bool _firstConsolid = true;
        private bool _albumBuild = false;
        public bool AlbumsBuild { get { return _albumBuild; } }


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private PlayList root = new PlayList("root", null);
        public PlayList Root { get { return root; } }
        private PlayList musique;
        private PlayList classement;
        private PlayList listes;
        private PlayList genres;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new PlayList("musique", root);
            classement = new PlayList("classement", root);
            listes = new PlayList("listes", root);
            genres = new PlayList("genres", listes);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }
        public void ClassementChange() { classementChange = true; }
        public bool ClassementChanged { get { return classementChange; } }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating(false);
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        //public void buildClassTree()
        //{
        //    buildClassTree(classement);
        //}


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private bool filterOnlyNext = false;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                }
            }
        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums()
        {

            albums.invalidateAll(true);
            // pour l'instant ne fonctionne pas 
            return;
            _albumBuild = false;
        }

        public bool AlbumBuild { get { return _albumBuild; } }

        private void buildVirtualFromList(PlayList pl, List<Piece> list)
        {
            string path = pl.getPath(listes, genres);
            foreach (IItem item in pl.Items)
            {
                var piece = htIds[item.ID];
                var v = piece.createVirtualAlbum(path, virtualMode.list, null);
                if (v != null)
                {
                    list.Add(v);
                }
            }

            foreach (PlayList sub in pl.PlayLists)
            {
                buildVirtualFromList(sub, list);
            }
        }

        public void ConsolidInit(IEnumerable<ITrackInfoItunes> dbList)
        {
            if (_albumBuild)
                return;
            allClassed.Clear();
            allClassedInAlbumEnabled.Clear();
            m_listTrackClassed.Clear();

            listPiece.Clear();
            listPieceInAlbum.Clear();
            listPieceInAlbumReal.Clear();
            all.Clear();

            // albums = new Albums(this);
            // VirtualPiece.init();

            //htIds.Clear();

            //  htIds = new BgDict<int, Piece>();
            foreach (ITrackInfoItunes track in dbList)
            {

                if (!track.isPodcast)
                {
                    Piece piece = null;
                    int pieceId = track.PieceId;
                    if (htIds.ContainsKey(pieceId))
                    {
                        piece = htIds[pieceId];
                        piece.initRank();
                    }
                    else
                    {
                        piece = new Piece(track);
                        htIds.Add(pieceId, piece);
                    }

                    all.Add(piece);

                }
            }
            // link
            foreach (Piece piece in all)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }
            }

            // liste FORT + albums


            albums.checkBuild();
            logger.log("build albums");
            foreach (Piece piece in all)
            {

                if (piece.Parent == null)
                {
                    // piece.removeVirtualChilds(); 
                    listPiece.Add(piece);
                    foreach (Piece p in piece)
                    {
                        if (p.Virtual)
                            continue;
                        if (albums.check(p))
                        {
                            listPieceInAlbum.Add(p);
                            listPieceInAlbumReal.Add(p);
                        }
                    }
                }
            }

            var confGen = CConf.ConfGen;
            var min = confGen.AlbumMin;

            bool loadVirt = _albumVirtual;
            if (loadVirt)
            {
                var fileAlbum = Albums.getSortedAlbumFile();
                if (!File.Exists(fileAlbum))
                {
                    loadVirt = false;
                }
                else
                {
                    int nbload = 0;
                    logger.log("load albums virtuels");
                    try
                    {
                        nbload = albums.load(htIds);
                    }
                    catch (Exception ex)
                    {
                        logger.Error("Impossible de charger le fichier {0} {1}", fileAlbum, ex);
                        loadVirt = false;
                        nbload = -1;
                    }

                    if (nbload == 0)
                    {
                        logger.Error("le fichier {0} est vide", fileAlbum);
                        loadVirt = false;
                    }
                }
            }

            if (_albumVirtual && !loadVirt)
            {
                logger.log("build albums virtuels");


                var listCandidat = new List<Piece>();
                var dictTmp = new BgDictString<Album>();
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        piece.buildVirtualAlbums(listCandidat);
                    }
                }

                if (CConf.ConfGen.ListVirtual)
                {
                    buildVirtualFromList(listes, listCandidat);
                }

                foreach (Piece p in listCandidat)
                    albums.checkVirtual(p, dictTmp);




                min = confGen.PathVirtualMin;
                if (min > 1)
                {
                    // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                    foreach (var key in new List<string>(dictTmp.Keys))
                    {
                        var a = dictTmp[key];
                        if (a.VirtualMode == virtualMode.path || a.VirtualMode == virtualMode.extended || a.VirtualMode == virtualMode.extendedWord)
                        {
                            if (a.Count < min)
                            {
                                a.ClearAndMenage();
                                dictTmp.Remove(key);
                            }
                        }
                    }
                }

                if (confGen.ArtistVirtual)
                {
                    min = confGen.ArtistVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualByArtist)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }


                if (confGen.WordVirtual)
                {
                    min = confGen.WordVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualMode == virtualMode.word)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }




                var listAlbums = new List<Album>(dictTmp.Values);

                listAlbums.Sort(new VirtualAlbumComparer());
                albums.checkVirtuals(listAlbums, listPieceInAlbum);

                foreach (Piece piece in all)
                {
                    piece.menageChilds();
                }

            }

            albums.buildDone();

            // Suppression des albums avec trop peu de morceaux
            min = confGen.AlbumMin;
            if (min > 1)
            {
                // Suppression des albums standards avec trop peu de morceaux
                var dict = albums.Dict;
                foreach (var key in new List<string>(dict.Keys))
                {
                    var a = dict[key];
                    if (!a.Virtual)
                    {
                        if (a.Count < min)
                        {
                            a.ClearAndMenage();
                            dict.Remove(key);
                        }
                    }
                }
            }
            if (!loadVirt)
                albums.sortVirtual();
            _albumBuild = true;

        }


        public void MakeConsolid(IEnumerable<ITrackInfoItunes> dbList, bool makeSort, bool classementChange, IClient client)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;
                calcRank = !urgence; // && (allClassed.Count == 0 || classementChange); 
                if (calcRank)
                {
                    allClassed.Clear();
                    allClassedInAlbumEnabled.Clear();
                    m_listTrackClassed.Clear();

                    ConsolidInit(dbList);
                    //if (CConf.ConfGen.LimitAlbums > 0)
                    //    _albumBuild = false;
                    now = DateTime.Now;

                    StackAlbum.Instance.init(all);

                    misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    foreach (Piece piece in listPieceInAlbum)
                    {
                        if (piece.Classement.isClassed())
                        {
                            allClassed.Add(piece);
                            //if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            //    allClassedInAlbumEnabled.Add(piece);
                        }
                    }

                    foreach (Piece piece in listPieceInAlbumReal)
                    {
                        if (piece.Classement.isClassed())
                        {
                            if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                                allClassedInAlbumEnabled.Add(piece);
                        }
                    }

                    misc.log("m_listTrackClassed: {0} elt", m_listTrackClassed.Count);
                    misc.log("listPieceInAlbum: {0} elt", listPieceInAlbum.Count);
                    misc.log("allClassed: {0} elt", allClassed.Count);
                    misc.log("allClassedInAlbumEnabled: {0} elt", allClassedInAlbumEnabled.Count);
                    // (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                    misc.log("listPieceInAlbumReal; {0} elt {1} ms", listPieceInAlbumReal.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;



                    misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                    client.log("ranking");
                }
                Ranking(makeSort, classementChange, client);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                    urgence = false;
                    this.classementChange = false;
                }
            }

        }

        public void buildMusique()
        {
            misc.log("buildMusique");
            //if (CConf.ConfGen.LimitList > 0)
            //    return;
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece); // addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbumReal)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif
            misc.log("fin buildMusique");
        }

        //private void buildMusique(PlayList musique)
        //{
        //    var d = new HashSet<int>();
        //    foreach (Piece piece in all)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece); // addObj(piece);
        //    }


        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece);
        //    }
        //}

        public void buildMusiqueAgain()
        {
            musique.DeleteBase();
            buildMusique();
        }


        public void buildLists(PlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                // mine.add(sub);
                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }


            //foreach (PlComponent c in ext)
            //{
            //    if (c is CPlayList)
            //    {
            //        var subExt = c as CPlayList;
            //        var sub = new CPlayList(subExt.Name, mine);
            //        sub.ID = subExt.ID;
            //        // mine.add(sub);
            //        buildList(sub, subExt);
            //    }
            //    else
            //    {
            //        var t = c as IFile;
            //        var piece = htIds[t.PieceId];
            //        mine.add(new TrackList(piece));
            //    }
            //}
        }


        private bool urgence;
        private bool calcRank;
        public void setUrgence()
        {
            urgence = true;
        }
        public bool Urgence { get { return urgence; } set { urgence = value; } }
        internal Album getAlbum(Piece track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort, bool classementChange, IClient client)
        {
            classementChange = classementChange && !urgence;
            albums.buildStack(makeSort);
            if (calcRank)
            {
                QRanking();
                //  LRanking();
                QLRanking();
                client.log("QLRanking");
            }
            DateTime now = DateTime.Now;
            if (Piece.Compact)
            {
                if (goCompact || (classementChange && CConf.ConfGen.AlbumSort.compactAny))
                {
                    lock (Albums.LockSort)
                    {
                        client.log("Albums.LockSort");
                        goCompact = false;
                        // classementChange = false;
                        //var l = new List<Piece>(this.listPiece);
                        //l.Sort(new CPieceComparerByQualityAndLength2());
                        new Condenseur(listPieceInAlbum).gener2();
                        client.log("new Condenseur(listPieceInAlbum).gener2();");
                    }
                }
                misc.log("Piece.Compact; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }


            // var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            //   logger.log("PieceRestComparer->RankRest ");
            //list.Sort(new PieceRestComparer());

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            //logger.log("list.Sort(new PieceDeltaComparer());");
            //list.Sort(new PieceDeltaComparer());
            //list.Reverse();

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankDelta = i + 1;
            //}

            //logger.log("PieceSortComparer->Sort ");
            //list.Sort(new PieceSortComparer());
            //list.Reverse();

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.Sort = i + 1;
            //}

            albums.makeSort(_firstConsolid, client, logger);
            //if (calcRank)
            //{
            //    logger.log("AlbumsSort ");
            //    var all = new List<Piece>(listPieceInAlbum);
            //    // if (makeSort)


            //    logger.log("AllPieceComparer->RankAllAlbum ");
            //    all.Sort(new AllPieceComparer());
            //    for (int i = 0; i < all.Count; i++)
            //    {
            //        all[i].RankAllAlbum = i + 1;
            //    }

            //    client.log("AllPieceComparer"); 
            //}

            // CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackInfoItunes> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackInfoItunes track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.Classement.ToString());
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating(false));
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now;



            var l_pieceComparer = new PieceDeepClassementComparer();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


            //on ordonne les morceaux top-down => sont privilégiés les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

            //compactage de la liste en tenant compte des mieux notés
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.Classement.isClassed())
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            // Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                break;
            }
            return Convert.ToInt32(qRank);
        }
        ///// <summary>
        ///// Tri des morceaux en fonction de leur longueur
        ///// </summary>
        ///// <remarks></remarks>
        //private void LRanking()
        //{
        //    logger.log("LRanking");
        //    DateTime now = DateTime.Now;
        //    DateTime debut = now;

        //    List<Piece> l_aux = new List<Piece>(listPiece);
        //    l_aux.Sort(new CPieceComparerByLenght());
        //    for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
        //    {
        //        Piece l_piece = l_aux[l_iIndex];
        //        l_piece.LRank = l_iIndex + 1;
        //    }

        //    logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        //}

        //public void compact()
        //{
        //    if (Piece.Compact)
        //    {
        //        if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
        //        {
        //            goCompact = false;
        //            var l = new List<Piece>(this.listPiece);
        //            l.Sort(new CPieceComparerByQualityAndLength2());
        //            new Condenseur(m_listQL).gener2();
        //        }
        //    }
        //}
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            m_listQL = new List<Piece>(m_listTrackClassed);
            foreach (Piece p in m_listQL)
                p.invalidateCache(false);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            //List<Piece> l_aux = new List<Piece>(listPiece);
            //l_aux.Sort(new CPieceComparerByQualityAndLength());
            //int count = l_aux.Count;
            //for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            //{
            //    Piece l_piece = l_aux[l_iIndex];
            //    l_piece.QLRank = l_iIndex + 1;
            //}

            //l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            //for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            //{
            //    Piece l_piece = l_aux[l_iIndex];
            //    l_piece.Rank.TwiceInv = l_iIndex + 1;
            //}


            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;
                var list = new List<Piece>(m_listQL);
                list.Sort(new ClassementValueDecimal0Comparer());

                if (_albumSortMode.createCourant)
                {
                    var unselected = list.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = list.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(list).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(list) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(list) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            //  _buildStat(rappel); 
            new Thread(() => _buildStat(rappel)).Start();

        }

        public DynamicStatPair  generStat(IClient client, string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            var builder = new DynamicStatBuilder(client, list); 
            DynamicStat real = builder.gener(className, true); 
            DynamicStat offset = real; 

            if (DynamicStatBuilder.isZero(className))
            {
                offset = builder.gener(className, false); 
            }
            return new DynamicStatPair(real, offset); 
        }

       

        public List<Piece> getTracks(IClient client, string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(client, list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }

        private CLegacyListWriter ListWriter(List<Piece> l_list, params IListWriter[] writers)
        {

            if (m_listWriter == null)
            {
                m_listWriter = new CLegacyListWriter(this, l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
            }
            return m_listWriter;

        }

        private CLegacyListWriter ListWriterAlbums(List<Piece> l_listAlb, params IListWriter[] writers)
        {
            if (m_listWriterAlb == null)
            {
                m_listWriterAlb = new CLegacyListWriter(this, l_listAlb);
                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);
            }
            return m_listWriterAlb;
        }

        public void createRot(string a_baseName, IClient client, params IListWriter[] writers)
        {
            lock (_lock)
            {
                client.log("_lock");
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                m_listWriter = null;
                m_listWriterAlb = null;
                listWriterAll = null;
                // var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(this, null);






                //      m_listWriter.reset();
                //m_listWriter = new CLegacyListWriter(this, l_list);
                //foreach (IListWriter writer in writers)
                //    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    ListWriter(l_list, writers);
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in l_listAlb)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in l_listAlb)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    ListWriter(l_list, writers).writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    ListWriter(l_list, writers).writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                //m_listWriterAlb = new CLegacyListWriter(this, l_listAlb);

                //foreach (IListWriter writer in writers)
                //    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    ListWriterAlbums(l_listAlb, writers);
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in l_listAlb)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in l_listAlb)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                client.log("createRot");
                return;

                //writeRot(1);

                //m_listWriter.writeCheckClassement(1);

                //m_listWriter.reset();
                //writeRotMin(-1);
                //writeRotMin(10);
                //writeRotMin(1);
            }
        }
        //private void writeRotMin(int a_nbHour)
        //{
        //    logger.log("----------------------");
        //    m_listWriter.writeRotMin(a_nbHour);
        //}
        //private void writeRot(int a_base)
        //{
        //    m_listWriter.writeRot(a_base);

        //}
        #endregion
    }
}



]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\stat\DynamicStatBuilder.cs">
    <content><![CDATA[
using pdb.util;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace pdb.gen.stat
{
    public class DynamicStatPair
    {
        public readonly DynamicStat real;
        public readonly DynamicStat offset; 
        public DynamicStatPair(DynamicStat real, DynamicStat offset)
        {
            this.real = real; 
            this.offset = offset; 
        }
    }
    public class DynamicStat : IEnumerable<DynamicStatLigne>
    {

        public const int ROWS = 5;
        public readonly List<DynamicStatLigne> rows = new List<DynamicStatLigne>(ROWS);
        public string className;
        public DynamicStat()
        {
            for (int r = 0; r < ROWS; r++)
                rows.Add(new DynamicStatLigne(r));
        }

        public DynamicStatLigne this[int row]
        {
            get
            {
                return rows[row];
            }
        }


        public IEnumerator<DynamicStatLigne> GetEnumerator()
        {
            return rows.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return rows.GetEnumerator();
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.Append(className);
            sb.Append(": ");
            foreach (var stat in rows)
            {
                sb.Append("\t");
                sb.Append(stat.ToString());
                sb.AppendLine();
            }
            return sb.ToString();


        }
    }

    public class DynamicStatLigne : IEnumerable<int>
    {
        public DynamicStatLigne(int row)
        {
            this.row = row;
            for (int i = 0; i < COLS; i++)
            {
                data.Add(0);
            }
        }
        public readonly int row;
        public const int COLS = 13;
        public const int SEMI_COLS = 6;
        private List<int> data = new List<int>(COLS);

        public int min;
        public int max;

        public int this[int col]
        {
            get
            {
                return data[Col(col)];
            }
            set
            {
                data[Col(col)] = value;
            }

        }

        private int Col(int col) { return col + SEMI_COLS; }

        public IEnumerator<int> GetEnumerator()
        {
            return data.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return data.GetEnumerator();
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.Append(min);
            sb.Append("-");
            sb.Append(max);
            sb.Append(" ");
            for (int i = -SEMI_COLS; i <= SEMI_COLS; i++)
            {
                sb.Append(" ");
                sb.Append(i);
                sb.Append("=");
                sb.Append(this[i]);
            }
            return sb.ToString();
        }
    }

    public class DynamicStatBuilder
    {
        const decimal EPSILON = 0.0000000000001m;
        private Regex reg = new Regex("[6789]");
        static NumberFormatInfo nfi;
        private List<Piece> list;
        private int level;
        //private int sub;
        //private int delta;
        //private int coeff;
        private int count;
        private IClient client;

        static DynamicStatBuilder()
        {
            nfi = new NumberFormatInfo() { NumberDecimalSeparator = "." };
        }

        public DynamicStatBuilder(IClient client, IEnumerable<Piece> list)
        {
            this.client = client;
            this.list = new List<Piece>(list);
            if (client.Cancel)
                return;
            this.list.Reverse();
            this.count = this.list.Count;
        }
        static Regex regNoEmpty = new Regex("[1-9]+");
        private static string getClassRecenter(string className)
        {
            if (string.IsNullOrEmpty(className))
                return className;
            if (regNoEmpty.IsMatch(className))
                return className;
            var tab = className.ToCharArray();
            int count = tab.GetLength(0);
            tab[count - 1] = '1';
            var ret = new string(tab);
            return ret;
        }

        public static bool isZero(string className)
        {
            return !regNoEmpty.IsMatch(className);
        }

        public DynamicStat gener(string className, bool real)
        {
            if (!real)
                className = getClassRecenter(className);
            //if (string.IsNullOrEmpty(className))
            //    className = "3";
            DynamicStat stats = new DynamicStat();

            int pt = className.IndexOf('.');
            string classNameAndRating = className;
            var sub = classNameAndRating;
            char csub = '0';
            if (pt > 0)
            {
                int count = classNameAndRating.Length;
                //if (pt < count - 1)
                //{
                //    csub = classNameAndRating[pt + 1];
                //}
                classNameAndRating = classNameAndRating.Remove(pt);
            }

            if (pt < 0)
            {
                sub = classNameAndRating + csub;
            }
            else
            {
                sub = classNameAndRating;
                if (classNameAndRating.Length > 0)
                    classNameAndRating = classNameAndRating.Remove(classNameAndRating.Length - 1);
            }
            if (DynamicStat.ROWS == 1)
            {
                gener(client, stats[0], sub, 1);
            }
            else if (DynamicStat.ROWS == 3)
            {
                gener(client, stats[0], sub, 3);
                gener(client, stats[1], sub, 1);
                sub += "0";
                gener(client, stats[2], sub, 3);
            }
            else if (DynamicStat.ROWS == 5)
            {
                gener(client, stats[0], classNameAndRating, 1);
                gener(client, stats[1], sub, 3);
                //  gener(stats[2], sub, 2);
                gener(client, stats[2], sub, 1);

                sub += "0";

                gener(client, stats[3], sub, 3);
                //  gener(stats[5], sub, 2);
                gener(client, stats[4], sub, 1);
            }




            return stats;
        }

        public List<Piece> getPieces(string className)
        {
            if (string.IsNullOrEmpty(className))
                className = "3";

            var stats = new List<Piece>();
            int pt = className.IndexOf('.');
            string classNameAndRating = className;
            //  var sub = classNameAndRating;
            //  char csub = '0';
            if (pt > 0)
            {
                classNameAndRating = classNameAndRating.Remove(pt);
            }

            //if (pt < 0)
            //{
            //    sub = classNameAndRating + csub;
            //}
            //else
            //{
            //    sub = classNameAndRating;
            //    if (classNameAndRating.Length > 0)
            //        classNameAndRating = classNameAndRating.Remove(classNameAndRating.Length - 1);
            //}

            gener(client, stats, classNameAndRating, 1);

            return stats;
        }


        private void gener(IClient client, DynamicStatLigne ligne, string className, int sub)
        {


            decimal center = 0;
            decimal realCenter = 0;
            //if (string.IsNullOrEmpty(className))
            //{
            //    className = "3";
            //}

            //string classNameAndRating = className.Replace(".", "").Replace(",", "");
            level = 0;
            if (string.IsNullOrEmpty(className))
                center = 3;
            else
            {
                level = className.Length - 1;
                string strDecimal = className.Insert(1, ",");


                //if (level == 0)
                //{
                //    center = 3;
                //}
                //else
                //{

                if (!decimal.TryParse(strDecimal, out center))
                    return;
                //}

            }

            //if (center == 0)
            //{
            //    // 0=>1 level = 0
            //    // 00 > 01 -> 0.1 level=1
            //    center = Convert.ToDecimal(System.Math.Pow(10, -level));
            //}

            decimal precision = 1m;
            long deltaBase = 1;

            for (int i = 0; i < level; i++)
            {
                precision /= 10m;
                deltaBase *= 10;
            }

            if (sub == 6)
            {
                precision *= 10m;

            }
            else
            {
                precision *= sub;

            }

            //************************************************
            // 213 =>  210  211  212  |213| 214  215  220
            // puis     2113 2120 2123 |2130|2133 2140 2143   
            // puis    2120 2122 2124 |2130|2132 2134 2140
            // puis    2123 2124 2125 |2130|2131 2132 2133
            //****************************************************

            // ok mais avec ""
            //************************************************
            // "" =>  0  1  2  |3| 4  5 
            // puis     2113 2120 2123 |2130|2133 2140 2143   
            // puis    2120 2122 2124 |2130|2132 2134 2140
            // puis    00 01 02 |03|04 05 10
            //****************************************************
            int delta = sub;
            long min = (long)System.Math.Round(System.Math.Round(center, level) * deltaBase, 0);
            long max = 0;
            int col = 0;
            int index = 0;
            int nb = 0;
            decimal current = 0m;

            if (min > 0)
            {
                for (col = -1; col >= -DynamicStatLigne.SEMI_COLS; col--)
                {
                    if (client.Cancel)
                        return;
                    // trouver min en descendant
                    for (int i = 0; i < sub; i++)
                    {
                        min--;
                        while (reg.IsMatch(min.ToString()))
                            min--;
                    }

                    if (min <= 0)
                        break;
                }
            }

            if (col < -DynamicStatLigne.SEMI_COLS)
                col = -DynamicStatLigne.SEMI_COLS;
            for (; col <= DynamicStatLigne.SEMI_COLS; col++)
            {
                if (client.Cancel)
                    return;
                max = min + delta;
                while (reg.IsMatch(max.ToString()))
                    max++;

                if (min >= 6 * deltaBase)
                    return;



                decimal dmin = (decimal)min / deltaBase;

                while (true)
                {
                    if (client.Cancel)
                        return;

                    if (index < count)
                    {
                        current = list[index].ClassementValueDecimal(false);
                        if (current * deltaBase < min - EPSILON)
                        {
                            index++;
                            continue;
                        }
                    }
                    if (index >= count || current * deltaBase + EPSILON >= max)
                    {
                        ligne[col] = nb;
                        nb = 0;
                        min = max;
                        break;

                    }
                    index++;
                    nb++;
                }
            }

        }




        private void gener(IClient client, List<Piece> ligne, string className, int sub)
        {
            decimal center = 0;
            if (string.IsNullOrEmpty(className))
            {
                className = "3";
            }


            level = className.Length - 1;
            string strDecimal = className.Insert(1, ",");


            if (!decimal.TryParse(strDecimal, out center))
                return;



            decimal precision = 1m;
            long deltaBase = 1;

            for (int i = 0; i < level; i++)
            {
                precision /= 10m;
                deltaBase *= 10;
            }

            if (sub == 6)
            {
                precision *= 10m;

            }
            else
            {
                precision *= sub;

            }


            long delta = sub;
            long min = (long)System.Math.Round(System.Math.Round(center, level) * deltaBase, 0);
            long max = 0;
            //  int col = 0;
            int index = 0;
            //  int nb = 0;
            decimal current = 0m;

            //if (min > 0)
            //{
            //    for (col = -1; col >= -DynamicStatLigne.SEMI_COLS; col--)
            //    {
            //        // trouver min en descendant
            //        for (int i = 0; i < sub; i++)
            //        {
            //            min--;
            //            while (reg.IsMatch(min.ToString()))
            //                min--;
            //        }

            //        if (min <= 0)
            //            break;
            //    }
            //}

            //if (col < -DynamicStatLigne.SEMI_COLS)
            //    col = -DynamicStatLigne.SEMI_COLS;
            //for (; col <= DynamicStatLigne.SEMI_COLS; col++)
            //{
            max = min + delta;
            while (reg.IsMatch(max.ToString()))
                max++;

            if (min >= 6 * deltaBase)
                return;



            decimal dmin = (decimal)min / deltaBase;

            while (true)
            {
                if (client.Cancel)
                    return;
                Piece p = null;
                if (index < count)
                {
                    p = list[index];
                    current = p.ClassementValueDecimal(false);
                    if (current * deltaBase < min - EPSILON)
                    {
                        index++;
                        continue;
                    }
                }
                if (index >= count || current * deltaBase + EPSILON >= max)
                {
                    //  ligne[col] = nb;
                    //  nb = 0;
                    min = max;
                    break;

                }
                ligne.Add(p);
                index++;

            }
        }

    }
}
]]></content>
  </file>
</db>
