<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\Player.xaml.cs">
    <content><![CDATA[using System.ComponentModel;
using System.Windows;
using pdb.util;
using System.Collections.Generic;
using pdb.player.ViewModel;
using System.Windows.Input;
using pdb.player.Vue;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class Player : Window
    {

        private static Logger log;
        private static Player _instance;
        //public static RoutedCommand Right = new RoutedCommand(); 
        //public static RoutedCommand Left = new RoutedCommand();
        //public static RoutedCommand Space = new RoutedCommand(); 

        private Memento memento;
        public Player()
        {
            InitializeComponent();
            log = App.log;
            this.BibCtle.BibRoot = App.bib;
            this.Loaded += Player_Loaded;
            this.Closing += new CancelEventHandler(Player_Closing);
            _instance = this;
            DataContext = this;

            memento = Memento.Instance;
            var winpos = memento.winPos;
            if (winpos != null)
            {
                this.Top = winpos.Top;
                this.Width = winpos.Width;
                this.Height = winpos.Height;
                this.Left = winpos.Left;
            }

            var cmpPos = memento.cmpPos;

            if (cmpPos != null)
            {
                cdAlbum.Width = cmpPos.cdAlbum.toGrid();
                cdBib.Width = cmpPos.cdBib.toGrid();
                cdClassment.Width = cmpPos.cdClassement.toGrid();
                cdMain.Width = cmpPos.cdMain.toGrid();
            }



            //Right.InputGestures.Add(new KeyGesture(Key.Right));
            //var bindingRight = new CommandBinding();
            //bindingRight.Command = Right; 
            //bindingRight.CanExecute+=new CanExecuteRoutedEventHandler(bindingRight_CanExecute);
            //Left.InputGestures.Add(new KeyGesture(Key.Left));
            //Space.InputGestures.Add(new KeyGesture(Key.Space)); 


            PlayListViewModel.initSelected(memento.selectedPlaylist); 
           

        }

        void Player_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            var cmpPos = memento.cmpPos;
            if (cmpPos == null)
            {
                cmpPos = new CmpPos();
                memento.cmpPos = cmpPos;
            }
            cmpPos.cdAlbum = new Length(cdAlbum.Width);
            cmpPos.cdBib = new Length(cdBib.Width);
            cmpPos.cdClassement = new Length(cdClassment.Width);
            cmpPos.cdMain = new Length(cdMain.Width);
            var winPos = memento.winPos;

            if (winPos == null)
            {
                winPos = new WindowPos();
                memento.winPos = winPos;
            }
            winPos.Top = Top;
            winPos.Height = Height;
            winPos.Left = Left;
            winPos.Width = Width;

            string strPl = "";
            var pl = PlayListViewModel.SelectedPlayList;
            if (pl != null)
                strPl = pl.PlayList.getPath();
            memento.selectedPlaylist = strPl;

            memento.save();
            App.shutdown();

        }

        void Player_Loaded(object sender, RoutedEventArgs e)
        {
            //new ThreadUtil(() =>
            //App.go(),"go").Start(); 

        }

        public ICommand RightC { get { return PlayerViewModel.Instance.Forward; } }
        public ICommand LeftC { get { return PlayerViewModel.Instance.BackWard; } }
        public ICommand SpaceC { get { return PlayerViewModel.Instance.Play; } }

        // public static List<TrackListViewModel> VisibleItems { get { return _instance.dg_pl.VisibleItems; } }


    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private CPlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        private static List<IRedraw> gui = new List<IRedraw>();
        internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }

        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion

        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        protected static void recordPl(PlayListViewModel pl)
        {
            dictPl.Add(pl.pl.getPath(), pl);
        }

        protected static string getKey(PlayListViewModel pl, int id)
        {
            return pl.pl.getPath() + "|" + id;
        }


        protected static void recordTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Add(getKey(pl, t.PieceId), t);
        }

        public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            return dictT.ContainsKey(getKey(pl, t.PieceId));
        }

        protected static void removeTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Remove(getKey(pl, t.PieceId));
        }

        public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return dictT[key];
            return null;
        }

        public TrackListViewModel FindTrack(int id)
        {
            return findTrack(this, id);
        }

        public static void resetExport(exportState state)
        {
            try
            {
                foreach (var t in dictT.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        //public static void setExport(int id, exportState state)
        //{
        //    try
        //    {
        //        foreach (TrackListViewModel t in dictT.Values)
        //        {
        //            if (t.PieceId == id)
        //                t.ExportStatus = state;
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        misc.log(ex.ToString());
        //    }
        //}

        protected bool contains(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return true;
            return false;
        }


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        private void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlComponent component in pl)
            {

                if (component is CPlayList)
                {
                    var sublist = component as CPlayList;
                    var _pl = new PlayListViewModel(sublist, this);
                    _childs.Add(_pl);
                    _playlists.Add(_pl);
                    recordPl(_pl);
                    //_pl.PropertyChanged += new PropertyChangedEventHandler(_pl_PropertyChanged);
                    //_pl.CollectionChanged += new NotifyCollectionChangedEventHandler(_pl_CollectionChanged);
                    //              __playlists.Add(_pl); 
                }
                else
                {
                    var track = component as TrackList;
                    if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                        continue;
                    var _t = new TrackListViewModel(track, this);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                    recordTrack(_t, this);
                }
            }

            allTracks = new AllTracksViewModel(this, false, false);
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new CPlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue; 
                var sub = get(dir, false); 
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab,0 );
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(CPlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(CPlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public CPlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true; 
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list
                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {
                        try
                        {
                            var dispatcherObject = handler.Target as DispatcherObject;
                            // If the subscriber is a DispatcherObject and different thread
                            if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            {
                                var ope =
                                dispatcherObject.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,
                                                   handler, this, e);
                                ope.Completed += ope_Completed;
                            }
                            else // Execute handler as is
                                handler(this, e);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }
                    }
                }
            }

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new CPlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (contains(this, piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            var tl = new TrackList(piece);
            pl.add(tl);
            var p = piece.Track;
            CPiece cPiece = null;
            if (p is CPiece)
                cPiece = p as CPiece;

            else if (p is TrackListViewModel)
            {
                var pp = ((TrackListViewModel)p).Piece;
                cPiece = pp as CPiece;
            }


            if (cPiece != null)
                pl.addPiece(cPiece);
            var vm = new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm, this);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Track.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl, this);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            // bool isMe = PlayListViewModel.SelectedPlayList == this;
            bool isAlbum = this.isSubList("album");
            bool isGen = this.isSubList("gen");
            int _indexAlbumRead = -1;
            int _indexTrackRead = -1;
            string _currentAlbum = "";
            TrackListViewModel current = TrackListViewModel.CurrentPlaying;
            string currentAlbum = "";
            if (current != null)
                currentAlbum = current.Album;
            var conf = CConf.ConfGen;
            List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
            List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

            var newElements = new List<IFile>(newElements_);

            BgDict<int, bool?> newElt = new BgDict<int, bool?>();
            foreach (IFile elt in newElements_)
            {
                newElt[elt.PieceId] = false;
            }

            int indexAlbumOrg = -1;
            int indexTrackOrg = -1;
            var tracks = _tracks;
            //if (isMe)
            //{
            tracks = new List<TrackListViewModel>(_tracks);
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            // }

            foreach (TrackListViewModel tl in tracks)
            {
                if (tl.Album != _currentAlbum)
                {
                    _currentAlbum = tl.Album;
                    _indexAlbumRead++;
                    _indexTrackRead = 0;
                }
                else
                    _indexTrackRead++;
                var found = newElt[tl.PieceId] != null;
                bool keep = false;
                //if (isMe)
                //{
                if (isAlbum && currentAlbum.Equals(tl.Album))
                {
                    keep = true;
                }
                else if (current != null && current.PieceId == tl.PieceId)
                {
                    keep = true;
                    indexAlbumOrg = _indexAlbumRead;
                    indexTrackOrg = _indexTrackRead;
                }
                //}

                newElt[tl.PieceId] = keep;

                if (!found)
                {
                    if (keep)
                        toKeep.Add(tl);
                    else
                        toDelete.Add(tl);
                }
            }

            //Addition
            List<IFile> toAdd = new List<IFile>();
            foreach (IFile elt in newElements)
            {
                if (writer.Aborted)
                    return;

                bool found = contains(this, elt.PieceId);


                if (!found)
                    toAdd.Add(elt);

            }
            //  log.log("mergeList::fin determination toAdd");

            if (toAdd.Count > 0 && _log)
                log.log("{0} {1} elt to add", this, toAdd.Count);

            if (toDelete.Count > 0 && _log)
                log.log("{0} {1} elt to delete", this, toDelete.Count);




            int count = toAdd.Count;
            for (int i = 0; i < count; i++)
            {
                if (writer.Aborted) return;

                AddTrack(toAdd[i], false);
            }

            foreach (TrackListViewModel vm in toDelete)
            {
                if (writer.Aborted) return;
                RemoveTrack(vm, false);
            }


            var newElements3 = newElements;

            if (isGen)
            {
                HashSet<string> moved = new HashSet<string>();
                newElements3 = new List<IFile>();
                // chercher le premier album non quarantaine
                int ifirst = 0;
                for (; ifirst < newElements.Count; ifirst++)
                {
                    var t = newElements[ifirst] as Piece;

                    if (t.AlbumAbsent)
                    {
                    }
                    else if (t.StackValue > 0)
                    {
                        moved.Add(t.Album);
                        t.Moved = true;
                    }

                    else
                    {
                        break;
                    }
                }

                if (ifirst < newElements.Count)
                {
                    string alb = "";
                    string alb2 = "";
                    string cmp = "";
                    int i = ifirst;
                    while (true)
                    {
                        if (i >= newElements.Count)
                            break;
                        var t = newElements[i] as Piece;
                        if (t.StackValue > 0)
                        {
                            moved.Add(t.Album);
                            t.Moved = true;
                        }
                        else if (t.AlbumAbsent)
                        { }// moved.Add(t.Album); 
                        else
                        {
                            var _alb = t.Album;
                            if (!string.IsNullOrEmpty(cmp) && cmp != _alb)
                            {
                                if (string.IsNullOrEmpty(alb))
                                    alb = cmp;
                                else
                                {
                                    alb2 = cmp;
                                    break;
                                }
                            }
                            cmp = _alb;
                            newElements3.Add(t);
                        }
                        i++;
                    }

                    for (i = 0; i < newElements.Count; i++)
                    {
                        var t = newElements[i] as Piece;
                        if (t.Album != alb && t.Album != alb2)
                            newElements3.Add(t);
                    }
                }
                else
                    newElements3 = newElements;

                allTracks.setNbAlbumMoved(moved.Count);

            }
            else
                allTracks.setNbAlbumMoved(-1);




            var newElements2 = new List<IFile>(newElements3);
            foreach (IFile iFile in newElements3)
            {
                var keep = newElt[iFile.PieceId];
                var t = findTrack(this, iFile.PieceId);
                if (t != null)
                {
                    if (true == keep)
                    {
                        int index0 = t.Index - 1;
                        int index1 = newElements2.IndexOf(iFile);
                        if (index1 > index0)
                        {
                            newElements2.Remove(iFile);
                            insert(t, newElements2);
                        }
                    }

                }
            }

            foreach (TrackListViewModel k in toKeep)
            {
                insert(k, newElements2);
            }

            if (indexAlbumOrg >= 0)
            {
                _indexAlbumRead = -1;
                _currentAlbum = "";
                int newIndex = 0;
                bool dontTouch = false;

                for (int i = 0; i < newElements2.Count; i++)
                {
                    var ifile = newElements2[i] as Piece;
                    if (ifile == null)
                    {
                        dontTouch = true;
                        break;
                    }
                    if (ifile.Album != _currentAlbum)
                    {
                        _indexAlbumRead++;
                        _currentAlbum = ifile.Album;
                    }
                    if (_currentAlbum == currentAlbum)
                    {
                        dontTouch = true;
                        break;
                    }

                    if (_indexAlbumRead == indexAlbumOrg)
                    {
                        newIndex = i;
                        break;
                    }
                }


                if (!dontTouch)
                {
                    var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                    if (currentFile != null)
                    {

                        newElements2.Remove(currentFile);
                        newElements2.Insert(newIndex, currentFile);
                    }
                }


                // for (int i = 0; i < newElements2.Count; i++)
                //{
                //    var ifile = newElements2[i] as Piece;
                //    var keep = newElt[ifile.PieceId];






                //    if (true == keep)
                //    {
                //        var t = findTrack(this, ifile.PieceId);
                //        if (t != null)
                //        {
                //            ///s'il était en position 0 , le placer en début. s"il était en 1....

                //            var album = t.Album; 
                //            if (i + 1 >= newElements2.Count)
                //                break;



                //            var inext = newElements2[i + 1];
                //            var next = findTrack(this, inext.PieceId);
                //            var nextAlbum = next.Album;
                //            if (nextAlbum == album)
                //                break; 

                //            int iCurrent = i - 1;

                //            IFile iprec = null;
                //            TrackListViewModel prec = null;

                //            while (true)
                //            {

                //                if (iCurrent < 0)
                //                    break;
                //                iprec = newElements2[iCurrent];
                //                prec = findTrack(this, iprec.PieceId);
                //                if (prec.Album == nextAlbum)
                //                {
                //                    newIndex = iCurrent;
                //                }
                //                else
                //                    break;

                //                iCurrent--;
                //            }

                //            if (newIndex != i)
                //            {
                //                newElements2.Remove(ifile);
                //                newElements2.Insert(newIndex, ifile);
                //            }
                //        }
                //    }
                //}
            }

            int index = 1;
            for (int i = 0; i < newElements3.Count; i++)
            {
                var ifile = newElements2[i];
                var t = findTrack(this, ifile.PieceId);
                if (t != null)
                {
                    //var keep = newElt[ifile.PieceId];
                    //if (true != keep)
                    t.Index = index;
                }
                index++;
            }





            //if (toAdd.Count > 0 || toDelete.Count > 0)
            //{
            AlltracksVm.refresh();
            //if (alltracksVmd != null)
            //    alltracksVmd.refresh();
            //if (alltracksFather != null)
            //    alltracksFather.refresh();
            //if (alltracksFatherDisabled != null)
            //    alltracksFatherDisabled.refresh();

            //}
        }

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <l:EnhancedDataGrid  Grid.Column="0" DockPanel.Dock="Bottom" 
                       x:Name="dg" x:Uid="93A5ABB5-8716-49B8-B2CF-25D5B852114D"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}"/>
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor},  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->

                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>
        </l:EnhancedDataGrid>

    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\EnhancedDataGrid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Controls;
using System.Windows;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Windows.Media;
using pdb.player.Vue.Util;

namespace pdb.player.Vue
{
    public partial class EnhancedDataGrid : DataGrid
    {

        private bool inWidthChange = false;
        private bool updatingColumnInfo = false;
        public static readonly DependencyProperty ColumnInfoProperty = DependencyProperty.Register("ColumnInfo",
                typeof(ObservableCollection<ColumnInfo>), typeof(EnhancedDataGrid),
                new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, ColumnInfoChangedCallback)
            );

        private static void ColumnInfoChangedCallback(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs e)
        {
            var grid = (EnhancedDataGrid)dependencyObject;
            if (!grid.updatingColumnInfo) { grid.ColumnInfoChanged(); }
        }




        protected override void OnInitialized(EventArgs e)
        {
            EventHandler sortDirectionChangedHandler = (sender, x) => UpdateColumnInfo();
            EventHandler widthPropertyChangedHandler = (sender, x) => inWidthChange = true;
            var sortDirectionPropertyDescriptor = DependencyPropertyDescriptor.FromProperty(DataGridColumn.SortDirectionProperty, typeof(DataGridColumn));
            var widthPropertyDescriptor = DependencyPropertyDescriptor.FromProperty(DataGridColumn.WidthProperty, typeof(DataGridColumn));
            var info = ColSov.get(Uid);
            ColumnInfo = info.list;
            ColumnInfoChanged();
            Loaded += (sender, x) =>
            {
                foreach (var column in Columns)
                {
                    sortDirectionPropertyDescriptor.AddValueChanged(column, sortDirectionChangedHandler);
                    widthPropertyDescriptor.AddValueChanged(column, widthPropertyChangedHandler);
                }
            };
            Unloaded += (sender, x) =>
            {
                foreach (var column in Columns)
                {
                    sortDirectionPropertyDescriptor.RemoveValueChanged(column, sortDirectionChangedHandler);
                    widthPropertyDescriptor.RemoveValueChanged(column, widthPropertyChangedHandler);
                }
            };


            HorizontalGridLinesBrush =   Brushes.Black;
            VerticalGridLinesBrush = Brushes.Black;

            base.OnInitialized(e);
        }
        public ObservableCollection<ColumnInfo> ColumnInfo
        {
            get { return (ObservableCollection<ColumnInfo>)GetValue(ColumnInfoProperty); }
            set { SetValue(ColumnInfoProperty, value); }
        }
        private void UpdateColumnInfo()
        {
            updatingColumnInfo = true;
            ColumnInfo = new ObservableCollection<ColumnInfo>(Columns.Select((x) => new ColumnInfo(x)));
            ColSov.sov(new ColumnInfos(ColumnInfo), Uid);
            updatingColumnInfo = false;
        }
        protected override void OnColumnReordered(DataGridColumnEventArgs e)
        {
            UpdateColumnInfo();
            base.OnColumnReordered(e);
        }
        protected override void OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs e)
        {
            if (inWidthChange)
            {
                inWidthChange = false;
                UpdateColumnInfo();
            }
            base.OnPreviewMouseLeftButtonUp(e);
        }
        private void ColumnInfoChanged()
        {
            Items.SortDescriptions.Clear();
            foreach (var column in ColumnInfo)
            {
                var realColumn = Columns.Where((x) => (column.Header != null && column.Header == x.Header) || column.PropertyPath == ((Binding)((DataGridBoundColumn)x).Binding).Path.Path).FirstOrDefault();
                if (realColumn == null) { continue; }
                column.Apply(realColumn, Columns.Count, Items.SortDescriptions);
            }
        }
    }
    [Serializable]
    public class ColumnInfos
    {
        public ObservableCollection<ColumnInfo> list;
        public ColumnInfos(ObservableCollection<ColumnInfo> list)
        {
            this.list = list;
        }
    }

    public class ColSov
    {
        public static void sov(ColumnInfos info, string name)
        {
            var dict = Memento.Instance.dict;
            if (!dict.ContainsKey(name))
                dict.Add(name, info);
            else
                dict[name] = info;
            //var formater = new BinaryFormatter();
            //using (Stream st = new FileStream(name+".dat", FileMode.Create))
            //{
            //    formater.Serialize(st, info); 
            //}
        }
        public static ColumnInfos get(string name)
        {
            ColumnInfos infos = null;

            var dict = Memento.Instance.dict;
            if (dict.ContainsKey(name))
                infos = dict[name] as ColumnInfos;
            if (infos == null)
                infos = new ColumnInfos(new ObservableCollection<ColumnInfo>());

            return infos;
        }
    }

    [Serializable]
    public struct ColumnInfo
    {
        public ColumnInfo(DataGridColumn column)
        {
            Header = column.Header;
            PropertyPath = ((Binding)((DataGridBoundColumn)column).Binding).Path.Path;
            WidthValue = column.Width.DisplayValue;
            WidthType = column.Width.UnitType;
            SortDirection = column.SortDirection;
            DisplayIndex = column.DisplayIndex;
        }
        public void Apply(DataGridColumn column, int gridColumnCount, SortDescriptionCollection sortDescriptions)
        {
            column.Width = new DataGridLength(WidthValue, WidthType);
            column.SortDirection = SortDirection;
            if (SortDirection != null)
            {
                sortDescriptions.Add(new SortDescription(PropertyPath, SortDirection.Value));
            }
            if (column.DisplayIndex != DisplayIndex)
            {
                var maxIndex = (gridColumnCount == 0) ? 0 : gridColumnCount - 1;
                column.DisplayIndex = (DisplayIndex <= maxIndex) ? DisplayIndex : maxIndex;
            }
        }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} {3} {4}", Header, WidthType, WidthValue, DisplayIndex, PropertyPath);
        }
        public object Header;
        public string PropertyPath;
        public ListSortDirection? SortDirection;
        public int DisplayIndex;
        public double WidthValue;
        public DataGridLengthUnitType WidthType;
    }
}



]]></content>
  </file>
  <file path="\pdb.player\Vue\Memento.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Windows;

namespace pdb.player.Vue
{
    [Serializable]
    class Memento
    {
        [NonSerialized]
        const string PATH = "memento.dat";
        [NonSerialized]
        private static Memento _instance;
        public WindowPos winPos = null;
        public CmpPos cmpPos = null;
        public string selectedPlaylist = ""; 
        public Dictionary<string, object> dict = new Dictionary<string, object>(); 
      
       
        private Memento()
        {
        }
        public static Memento Instance
        {
            get
            {
                if (_instance == null)
                {

                    var formater = new BinaryFormatter();
                    try
                    {
                        using (Stream st = new FileStream(PATH, FileMode.Open))
                        {
                            _instance = (Memento)(formater.Deserialize(st));
                        }
                    }
                    catch (Exception ex)
                    {
                    }


                }

                if (_instance == null)
                    _instance = new Memento();

                return _instance;

            }
        }
        public void save()
        {
            var formater = new BinaryFormatter();
            using (Stream st = new FileStream(PATH, FileMode.Create))
            {
                formater.Serialize(st, this);
            }
        }
    }
    [Serializable]
    class WindowPos
    {
        public double Top;
        public double Left;
        public double Width;
        public double Height;
    }
    [Serializable]
    class CmpPos
    {
        public Length cdBib;
        public Length cdMain;
        public Length cdAlbum;
        public Length cdClassement;
    }

    [Serializable]
    public class Length
    {
        public double value;
        public GridUnitType unit;
        public Length(GridLength ihm)
        {
            value = ihm.Value;
            unit = ihm.GridUnitType; 
        }
        public GridLength toGrid()
        {
            return new GridLength(value, unit); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows.Data;
using pdb.util;
using pdb.player.ViewModel;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.albums;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4;
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str);
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
            second = true;
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is decimal)
            {
                decimal dvalue = (decimal)value;
                if (dvalue <= 0) return "";
                return dvalue.ToString("0.###");

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }

    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        private static SolidColorBrush brSelected;
        private static SolidColorBrush brMoved;
        public static SolidColorBrush brNext;
        private static SolidColorBrush brNextAbsent;
        static BgColorFormatConverter()
        {
            Color color = (Color)ColorConverter.ConvertFromString("#3399ff");

            // #008ae6 - la mienne un peu terne
            //#88a9db
            //#547dab
            // #007acc

            //#3399ff - celle de seven w+r
            //"#ffcc99" peche
            // bleu-vert tres clair #93c8ce
            brSelected = new SolidColorBrush(color);
            color = (Color)ColorConverter.ConvertFromString("#93c8ce");
            brMoved = new SolidColorBrush(color);
            color = (Color)ColorConverter.ConvertFromString("#b5eaf0");
            brNext = new SolidColorBrush(color);
            color = (Color)ColorConverter.ConvertFromString("#c4dfe3");
            brNextAbsent = new SolidColorBrush(color);


        }
        public SolidColorBrush getColor(TrackListViewModel tv)
        {
            if (tv.IsSelected) return brSelected;
            if (tv.PieceGen.IsNext)
            {
                if (tv.Exists)
                    return brNext;
                return brNextAbsent;
            }
            if (tv.PieceGen.Moved) return brMoved;

            exportState es = tv.ExportStatus;
            if (!tv.Exists)
                es = exportState.miss;
            switch (es)
            {
                case exportState.none: return Brushes.White;
                case exportState.miss: return Brushes.LightGray;
                case exportState.present: return Brushes.White;
                case exportState.copy: return Brushes.LightGreen;
                case exportState.delete: return Brushes.DarkGray;
                default:
                    break;
            }

            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class ForeColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv)
        {
            if (tv.IsSelected) return Brushes.White;
            return Brushes.Black;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(ihmInDispo), typeof(Brush))]
    public class ColorDispoConverter : BaseConverter, IValueConverter
    {
        private SolidColorBrush getColor(ihmInDispo info)
        {

            switch (info)
            {
                case ihmInDispo.none: return Brushes.Transparent;
                case ihmInDispo.rot: return Brushes.Gainsboro;
                case ihmInDispo.stat: return Brushes.LightSlateGray;
                default:
                    break;
            }
            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                ihmInDispo info = (ihmInDispo)value;
                return getColor(info);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
            }
            return null;

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null;

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value;
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value);
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime?), typeof(string))]
    public class DateConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null; 
          
            if (value is DateTime)
            {
                if (DateTime.MinValue.Equals(value) || DateTime.MaxValue.Equals(value))
                    return ""; 
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            
            return null;
        }
    }





}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public void initRank()
        {
            _rapportClassement = -1;
            _infoMedianne = infoMedianne.none;
            _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        internal Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved; } set { if (album != null) album.Moved = value; } }
        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>pl
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }

        public void invalidateCache()
        {
            _classNameAndRating = null;
            _classementValueDecimal = -1;
            _rapportClassement = -1;
            _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();

        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                if (_classNameAndRating == null)
                {
                    if (!isClassListNumeric)
                        _classNameAndRating = "";
                    _classNameAndRating = ClassName + ((track.Rating / 20).ToString());
                }
                return _classNameAndRating;
            }
        }

        private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                if (_classementValueDecimal < 0)
                {
                    if (!isClassListNumeric) return 0;
                    string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                    _classementValueDecimal = Convert.ToDecimal(classNameAndRating);
                }
                return _classementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassement;
                if (_rapportClassement != -1)
                    return _rapportClassement;

                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                _rapportClassement = resultat;
                // _classementVirtuel = resultat; 
                return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        public bool checkIdentity(ITrackIdentity other)
        {
            //return track.Location == other.Location; 
            String location = track.Location;
            return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        }
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement; 
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);


        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }



        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            if (album != null)
                            {
                                int rank = album.Rank.Sort;
                                rank = 1 + gen.Albums.Count - rank;
                                sb.Append(rank);
                            }
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }


        private Piece parent;
        public Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == null)
                {
                    if (parent != null)
                    {
                        parent.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = value;
                    this.PieceParentId = value.PieceId;
                    parent.addChild(this);
                }
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        private void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            if (!childs.Contains(child))
                childs.Add(child);
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

        private exportState exportState;
        public exportState ExportStatus
        {
            get
            {
                return exportState; // exportState;
            }
            set
            {
                exportState = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString());
                    list.Add(virt);
                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }
        }

        private Piece createVirtualAlbum(string path)
        {
            var virt = new VirtualAlbumPiece(track, Master, path);
            return virt;
        }

        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        public static DateTime SeuilProvisoire;
        private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        private bool getClassementProvisoireRecent()
        {
            if (!ClassementProvisoire)
                return false;
            var list = DatesClassement;
            var last = CalcDate.getLastModif(list);
            if (last > SeuilProvisoire)
                return true;
            return false;
        }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }
    }

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }


}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        //{
        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {


        //        var _zero = mode.zero;
        //        var medianne = getMedianne_(list, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;

        //        if (list.Count == 1)
        //            return ret0;

        //        if (mode.safe == 0)
        //        {
        //            return calcmedianneVirt(list, mode, 0, 0);
        //        }

        //        int indexV = 0;
        //        int nbAdd = 0;

        //        int count = list.Count;

        //        if (mode.safe > 0)
        //        {

        //            int i0 = count - 1;
        //            int _nbNoAdd = 0;

        //            for (int i = 0; i < count; i++)
        //            {
        //                if (list[i] <= _zero)
        //                {
        //                    i0 = i;
        //                    _nbNoAdd = count - i0;
        //                    break;
        //                }
        //            }
        //            if (i0 == 0)
        //                return ret0;

        //            //for (int i00 = 1; i00 <= i0; i00++)
        //            //{
        //            //    decimal coeff = (decimal)i00 / (decimal)i0;
        //            List<decimal> _list = new List<decimal>(list);
        //            //for (int i = i00; i < count; i++)
        //            //    _list[i] = 0m;
        //            //liste partielle originale
        //            //  List<decimal> _list0 = new List<decimal>(_list);
        //            int _count = System.Math.Min(count, i0 + mode.safe);
        //            decimal[] virt = new decimal[_count];
        //            _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
        //            if (mode.noAdd)
        //            {

        //                decimal _coeff = 1m;
        //                for (int j = _nbNoAdd - 1; j >= 0; j--)
        //                {
        //                    if (j < count)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        _list[j] = _list[j] * _coeff;
        //                    }
        //                }
        //            }
        //            else if (mode.lissage || mode.removeEpsilon || mode.cumul)
        //            {
        //                for (int i = 0; i < i0; i++)
        //                {
        //                    decimal _coeff = 1m;
        //                    decimal _base = _list[i];
        //                    for (int j = i + 1; j < _count; j++)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                    }
        //                }
        //            }
        //            else
        //            {
        //                decimal courant = _list[0];
        //                for (int i = 1; i < _count; i++)
        //                {
        //                    if (_list[i] <= _zero)
        //                    {
        //                        courant /= mode.coeffVirt;
        //                        virt[i] = courant;
        //                    }
        //                    else
        //                        courant = _list[i];
        //                }
        //            }

        //            decimal value = int.MaxValue;
        //            int ii = 0;
        //            if (mode.noAdd)
        //            {
        //                //for (ii = 1; ii < count && ii < _count; ii++)
        //                //{
        //                //    var calc = virt[ii];
        //                //    if (calc > 0m)
        //                //        list[ii] = calc;
        //                //}
        //            }
        //            else
        //            {
        //                for (ii = 1; ii < count && ii < _count; ii++)
        //                {
        //                    value = _list[ii];
        //                    var calc = virt[ii];
        //                    if (value < calc)
        //                    {
        //                        if (mode.lissage || value <= _zero)
        //                        {
        //                            if (value <= _zero)
        //                                nbAdd++;
        //                            value = calc;
        //                            _list[ii] = value;
        //                        }

        //                    }
        //                    else
        //                        indexV = ii;
        //                }
        //                if (mode.removeEpsilon)
        //                {
        //                    // j'ai 5 virtuel alors que j'ai deux safe
        //                    ///xx---
        //                    int nb = 0;
        //                    for (int i = indexV + 1; i < _count; i++)
        //                    {
        //                        nb++;
        //                        if (nb <= mode.safe)
        //                            continue;
        //                        _list[i] = 0m;
        //                    }

        //                }
        //                if (mode.removeFirst)
        //                {
        //                    for (int i = 0; i < nbAdd; i++)
        //                    {
        //                        _list[i] = 0m;
        //                    }
        //                }
        //            }

        //            for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //                pieces[i].setClassementVirtuel(_list[i]);

        //            if (mode.deleteFirst)
        //            {
        //                for (int i = 0; i < nbAdd; i++)
        //                {
        //                    _list.RemoveAt(0);
        //                }
        //            }

        //            if (mode.reSort || mode.removeFirst || mode.noAdd)
        //            {
        //                _list.Sort();
        //                _list.Reverse();
        //                pieces.Sort(new PieceCmp());
        //            }



        //            if (mode.noAdd)
        //                nbAdd = _nbNoAdd;

        //            ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
        //            if (mode.expEnabled != 0)
        //            {
        //                int _nb = pieces.Count<Piece>(p => !p.Enabled);
        //                decimal _c = (decimal)_nb / (decimal)count;
        //                _c = Math.Pow(_c, mode.expEnabled);
        //                ret.d *= _c;
        //            }


        //        }
        //        else
        //            ret = calcmedianneVirt(list, mode, 0, 0);

        //        //if (ret < ret0)
        //        //    ret = ret0; 



        //    }
        //    finally
        //    {
        //        if (signal)
        //        {
        //            try
        //            {
        //                pieces[ret.index].MedianneLight = true;
        //                pieces[ret.indexBorder].Border = true;
        //                pieces[ret.indexBorderEffect].BorderEffect = true;
        //                pieces[ret.indexBorderMin].BorderMin = true;

        //            }
        //            catch { }
        //        }
        //    }

        //    return ret;
        //}

        public static int buildVirtual(List<Piece> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, decimal coeffEnabled, bool main, ref int i0)
        {


            int indexV = 0;
            int nbAdd = 0;

            int count = pieces.Count;
            List<Piece> _pieces = pieces;
            var _zero = mode.zero;
          

            if (modeVirt.safe > 0)
            {
                 i0 = count - 1;
                int _nbNoAdd = 0;


                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }

                if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
                    _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (modeVirt.noAddAll)
                    _nbNoAdd = pieces.Count;
                if (modeVirt.noAddEnd)
                {
                    // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                    // morceaux déjà notés
                    var nb2 = pieces.Count<Piece>(p => !p.Enabled && p.RapportClassement > 0);
                    _nbNoAdd = _nbNoAdd - nb2;
                    if (_nbNoAdd < 0)
                        _nbNoAdd = 0;
                }
                if (i0 == 0)
                    return 0;
                //}

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>();
                for (int i = 0; i < _pieces.Count; i++)
                    _list.Add(_pieces[i].VirtualClassement);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = System.Math.Min(count, i0 + modeVirt.safe);
                decimal[] virt = new decimal[_count];
                _nbNoAdd = System.Math.Min(modeVirt.safe, _nbNoAdd);
                if (modeVirt.noAdd)
                {
                    var _coeffVirt = modeVirt.coeffVirt;
                    if (count < modeVirt.safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)modeVirt.safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;
                    decimal prec = 0m;
                    if (modeVirt.virtAlignPrec)
                    {
                        if (_nbNoAdd < _list.Count)
                            prec = _list[_nbNoAdd];
                    }

                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < _pieces.Count)
                        {

                            if (!modeVirt.virtOnlyDisabled || !_pieces[j].Enabled)
                            {
                                _coeff /= _coeffVirt;
                                var cand = _list[j] * _coeff;
                                if (modeVirt.virtAlignPrec)
                                {
                                    if (cand < prec)
                                        cand = prec + EPSILON;
                                }

                                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                                {
                                    // quel serait le score s'il était coché
                                    var vu = _list[j] / coeffEnabled;
                                    // en plus une petite marge
                                    //  vu *= mode.coeffVirt; 
                                    if (cand < vu)
                                        cand = vu;
                                }
                                _list[j] = cand;
                            }
                            else if (modeVirt.forceCoeffVirt)
                                _coeff /= _coeffVirt;
                            prec = _list[j];
                        }
                    }

                }
                else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= modeVirt.coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
                else
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] <= _zero)
                        {
                            courant /= modeVirt.coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                if (modeVirt.noAdd)
                {
                    //for (ii = 1; ii < count && ii < _count; ii++)
                    //{
                    //    var calc = virt[ii];
                    //    if (calc > 0m)
                    //        list[ii] = calc;
                    //}
                }
                else
                {
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (modeVirt.lissage || value <= _zero)
                            {
                                if (value <= _zero)
                                    nbAdd++;
                                value = calc;
                                _list[ii] = value;
                            }

                        }
                        else
                            indexV = ii;
                    }
                    if (modeVirt.removeEpsilon)
                    {
                        // j'ai 5 virtuel alors que j'ai deux safe
                        ///xx---
                        int nb = 0;
                        for (int i = indexV + 1; i < _count; i++)
                        {
                            nb++;
                            if (nb <= modeVirt.safe)
                                continue;
                            _list[i] = 0m;
                        }

                    }
                    if (mode.removeFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            _list[i] = 0m;
                        }
                    }
                }

                for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                {
                    if (main)
                        _pieces[i].setClassementVirtuel(_list[i]);
                    else
                        _pieces[i].setClassementVirtuel2(_list[i]);
                }

                if (mode.deleteFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces.RemoveAt(0);
                    }
                }

                if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
                {
                    //_list.Sort();
                    //_list.Reverse();
                    if (main)
                        pieces.Sort(new PieceCmp());
                    else
                        pieces.Sort(new PieceCmp2()); 
                }



                if (modeVirt.noAdd)
                    nbAdd = _nbNoAdd;
            }
            return nbAdd;
        }

        public static DecimalIndex getMedianneLight(List<Piece> pieces, decimal coeffEnabled, ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {
                var _zero = mode.zero;
                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;
                ret = ret0;
                if (pieces.Count == 1)
                    return ret0;

                //if (mode.safe == 0)
                //{
                //    return calcmedianneVirt(pieces, mode, 0, 0);
                //}

                //int indexV = 0;
                //int nbAdd = 0;

                //int count = pieces.Count;
                //List<Piece> _pieces = pieces;
                ////if (mode.virtOnlyDisabled)
                ////{
                ////    _pieces = pieces.FindAll(p => !p.Enabled && p.VirtualClassement > 0m);
                ////    _pieces.Sort(new PieceCmp());
                ////}


                //if (mode.safe > 0)
                //{
                //    int i0 = count - 1;
                //    int _nbNoAdd = 0;
                //    //if (mode.virtOnlyDisabled)
                //    //{
                //    //    _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);
                //    //}
                //    //else
                //    //{

                //    for (int i = 0; i < count; i++)
                //    {
                //        var pp = pieces[i];
                //        if (pp.VirtualClassement == 0m)
                //        {
                //            i0 = i;
                //            _nbNoAdd = count - i0;
                //            break;
                //        }
                //    }

                //    if (mode.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
                //        _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);  // || p.VirtualClassement == 0m);
                //    if (mode.noAddAll)
                //        _nbNoAdd = pieces.Count;
                //    if (mode.noAddEnd)
                //    {
                //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                //        // morceaux déjà notés
                //        var nb2 = pieces.Count<Piece>(p => !p.Enabled && p.RapportClassement > 0);
                //        _nbNoAdd = _nbNoAdd - nb2;
                //        if (_nbNoAdd < 0)
                //            _nbNoAdd = 0;
                //    }
                //    if (i0 == 0)
                //        return ret0;
                //    //}

                //    //for (int i00 = 1; i00 <= i0; i00++)
                //    //{
                //    //    decimal coeff = (decimal)i00 / (decimal)i0;
                //    List<decimal> _list = new List<decimal>();
                //    for (int i = 0; i < _pieces.Count; i++)
                //        _list.Add(_pieces[i].VirtualClassement);
                //    //for (int i = i00; i < count; i++)
                //    //    _list[i] = 0m;
                //    //liste partielle originale
                //    //  List<decimal> _list0 = new List<decimal>(_list);
                //    int _count = System.Math.Min(count, i0 + mode.safe);
                //    decimal[] virt = new decimal[_count];
                //    _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                //    if (mode.noAdd)
                //    {
                //        var _coeffVirt = mode.coeffVirt;
                //        if (count < mode.safe && mode.coeffVirtAuto)
                //        {
                //            if (mode.coeffVirtAdjust)
                //                _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                //            else
                //            {
                //                // ex 2^10 = 1024
                //                // je veux obtenir 1024 avec 3
                //                _coeffVirt = Math.Pow(_coeffVirt, (decimal)mode.safe / (decimal)count);
                //            }
                //        }

                //        decimal _coeff = 1m;
                //        decimal prec = 0m;
                //        if (mode.virtAlignPrec)
                //        {
                //            if (_nbNoAdd < _list.Count)
                //                prec = _list[_nbNoAdd];
                //        }

                //        for (int j = _nbNoAdd - 1; j >= 0; j--)
                //        {
                //            if (j < _pieces.Count)
                //            {

                //                if (!mode.virtOnlyDisabled || !_pieces[j].Enabled)
                //                {
                //                    _coeff /= _coeffVirt;
                //                    var cand = _list[j] * _coeff;
                //                    if (mode.virtAlignPrec)
                //                    {
                //                        if (cand < prec)
                //                            cand = prec + EPSILON;
                //                    }

                //                    if (mode.virtAlignSelected && mode.virtOnlyDisabled)
                //                    {
                //                        // quel serait le score s'il était coché
                //                        var vu = _list[j] / coeffEnabled;
                //                        // en plus une petite marge
                //                        //  vu *= mode.coeffVirt; 
                //                        if (cand < vu)
                //                            cand = vu;
                //                    }
                //                    _list[j] = cand;
                //                }
                //                else if (mode.forceCoeffVirt)
                //                    _coeff /= _coeffVirt;
                //                prec = _list[j];
                //            }
                //        }

                //    }
                //    else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                //    {
                //        for (int i = 0; i < i0; i++)
                //        {
                //            decimal _coeff = 1m;
                //            decimal _base = _list[i];
                //            for (int j = i + 1; j < _count; j++)
                //            {
                //                _coeff /= mode.coeffVirt;
                //                virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                //            }
                //        }
                //    }
                //    else
                //    {
                //        decimal courant = _list[0];
                //        for (int i = 1; i < _count; i++)
                //        {
                //            if (_list[i] <= _zero)
                //            {
                //                courant /= mode.coeffVirt;
                //                virt[i] = courant;
                //            }
                //            else
                //                courant = _list[i];
                //        }
                //    }

                //    decimal value = int.MaxValue;
                //    int ii = 0;
                //    if (mode.noAdd)
                //    {
                //        //for (ii = 1; ii < count && ii < _count; ii++)
                //        //{
                //        //    var calc = virt[ii];
                //        //    if (calc > 0m)
                //        //        list[ii] = calc;
                //        //}
                //    }
                //    else
                //    {
                //        for (ii = 1; ii < count && ii < _count; ii++)
                //        {
                //            value = _list[ii];
                //            var calc = virt[ii];
                //            if (value < calc)
                //            {
                //                if (mode.lissage || value <= _zero)
                //                {
                //                    if (value <= _zero)
                //                        nbAdd++;
                //                    value = calc;
                //                    _list[ii] = value;
                //                }

                //            }
                //            else
                //                indexV = ii;
                //        }
                //        if (mode.removeEpsilon)
                //        {
                //            // j'ai 5 virtuel alors que j'ai deux safe
                //            ///xx---
                //            int nb = 0;
                //            for (int i = indexV + 1; i < _count; i++)
                //            {
                //                nb++;
                //                if (nb <= mode.safe)
                //                    continue;
                //                _list[i] = 0m;
                //            }

                //        }
                //        if (mode.removeFirst)
                //        {
                //            for (int i = 0; i < nbAdd; i++)
                //            {
                //                _list[i] = 0m;
                //            }
                //        }
                //    }

                //    for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                //        _pieces[i].setClassementVirtuel(_list[i]);

                //    if (mode.deleteFirst)
                //    {
                //        for (int i = 0; i < nbAdd; i++)
                //        {
                //            pieces.RemoveAt(0);
                //        }
                //    }

                //    if (mode.reSort || mode.removeFirst || mode.noAdd)
                //    {
                //        //_list.Sort();
                //        //_list.Reverse();
                //        pieces.Sort(new PieceCmp());
                //    }



                //    if (mode.noAdd)
                //        nbAdd = _nbNoAdd;
                int i0 = 0;
                int count = pieces.Count; 
                int nbAdd = buildVirtual(pieces, mode, mode.Main, coeffEnabled, true, ref i0); 
                    ret = calcmedianneVirt(pieces, mode, nbAdd, System.Math.Min(i0, mode.Main.safe));
                    if (mode.expEnabled != 0)
                    {
                        int _nb = pieces.Count<Piece>(p => !p.Enabled);
                        decimal _c = (decimal)_nb / (decimal)count;
                        _c = Math.Pow(_c, mode.expEnabled);
                        ret.d *= _c;
                    }


                //}
                //else
                //    ret = calcmedianneVirt(pieces, mode, 0, 0);

                //if (ret < ret0)
                //    ret = ret0; 

            }
            finally
            {

                if (signal)
                {
                    try
                    {
                        pieces[ret.index].MedianneLight = true;
                        pieces[ret.indexBorder].Border = true;
                        pieces[ret.indexBorderEffect].BorderEffect = true;
                        pieces[ret.indexBorderMin].BorderMin = true;

                    }
                    catch { }
                }
            }

            return ret;
        }




        private class PieceCmp : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp2 : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        private static DecimalIndex calcmedianneVirt(IList<Piece> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<Piece>(list);
            var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);
            int count = _list.Count;

            int nbEnabled = classes.Count<Piece>(p => p.Enabled);
            int nbDisabled = classes.Count<Piece>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            //int _nbSuppDisabled = 0;
            //int _nbSuppEnabled = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {
                    //var d = _list[count - i];
                    //if (d.Enabled)
                    //    nbEnabled--;
                    //else
                    //    nbDisabled--;

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                ret.indexBorderMin = count - i - 1;
                var p = _list[count - i - 1];

                if (p.VirtualClassement > conf.zero)
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considèere qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }

                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                        // }


                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        private static decimal getMedianne_(IList<Piece> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0].VirtualClassement;
            if (coeffMedianne == 0)
                return list[0].VirtualClassement;
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1].VirtualClassement;
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].VirtualClassement;
            var val1 = list[i1].VirtualClassement;
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\PlComponent.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.util;

namespace pdb.obj
{
    public abstract class PlComponent
    {
        private PlayListComposite parent;
        public PlComponent()
        {
        }
        public void setParent(PlayListComposite parent)
        {
            this.parent = parent;
        }
        public PlayListComposite Parent { get { return parent; } }

        public virtual void Delete()
        {
            DeleteBase();
        }

        public void DeleteBase()
        {
            if (parent == null) return;
            parent.remove(this);
            parent = null;

        }

        public override bool Equals(object obj)
        {
            if (obj is PlComponent)
            {
                var o = obj as PlComponent;
                return Location.Equals(o.Location);
            }
            else
                return false;

        }

        public override int GetHashCode()
        {
            return Location.GetHashCode();
        }

        public override abstract string ToString();
        public abstract string Location { get; }
        public virtual string getPath() { return ""; }

        /// <summary>
        /// ID legacy
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        public virtual int ID
        {
            get { return m_id; }
            set
            {
                if (m_id < 0)
                {
                    m_id = value;
                }
            }
        }

      

    }
    public abstract class PlayListComposite : PlComponent, IEnumerable<PlComponent>
    {
        private String name = "";
        private List<PlComponent> childs = new List<PlComponent>();
        private List<PlComponent> leafs = new List<PlComponent>();
        public PlayListComposite(String name)
        {
            this.name = name;
        }

        public const char SEP = '\\'; 

        protected abstract PlComponent create(object o); 
        public void addObj(object o)
        {
            add(create(o)); 
        }

        public virtual bool add(PlComponent component)
        {
            lock (this)
            {
                childs.Add(component);
                component.setParent(this);
                if (component is PlayListComposite)
                {
                }
                else
                {
                    leafs.Add(component);
                }
                return true;
            }
        }

        public bool HasSubComposites
        {
            get
            {
                return leafs.Count < childs.Count; 
            }
        }

        public List<PlComponent> AllTracks
        {
            get
            {
                var list = new List<PlComponent>();
                buildAllTraks(list);
                return list;
            }
        }

        protected void buildAllTraks(List<PlComponent> container)
        {
            foreach (PlComponent t in this)
            {
                if (t is PlayListComposite)
                    (t as PlayListComposite).buildAllTraks(container); 
                else
                container.Add(t);
            }
          
        }

        public bool Contains(PlComponent pl)
        {
            return childs.Contains(pl);
        }

        public virtual bool Contains(string location)
        {
            if (location == null)
                return false;

            return childs.Exists(p => location.Equals(p.Location));
        }

        public PlComponent Find(Predicate<PlComponent> p)
        {
            return childs.Find(p);
        }

        public int IndexOf(PlComponent leaf)
        {
            return leafs.IndexOf(leaf);
        }

        public bool ContainsLeaf(PlComponent leaf)
        {
            return leafs.Contains(leaf);
        }

        public PlComponent this[int index]
        {
            get
            {
                if (index < 0 || index >= leafs.Count)
                    return null;
                return leafs[index];
            }
        }



        public override string ToString()
        {
            return getPath();          
        }

        public override string getPath()
        {
            if (Parent == null) return name;
            return Parent.getPath() + SEP + name;
        }

        private  PlayListComposite _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(name))
                    continue;
                var sub = getComposite(name);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1); 
            }

            return null; 

        }

        public PlayListComposite getFromPath(string path)
        {
            var tab = path.Split(SEP);
            return _getFromPath(tab, 0); 
        }

        public String Name { get { return name; } set { name = value; } }

        public bool isSubList(string a_name)
        {
            if (name == a_name)
                return true;
            if (Parent == null)
                return false;
            return Parent.isSubList(a_name);
        }

        public bool isSubList(PlayListComposite other)
        {
            if (other == this)
                return true;
            if (Parent == null)
                return false;
            return Parent.isSubList(other);
        }

        public virtual void DeleteChilds()
        {
            lock (this)
            {
                try
                {
                    foreach (PlComponent pl in new List<PlComponent>(childs))
                    {
                        var plc = pl as PlayListComposite;
                        if (plc != null)
                        {
                            plc.DeleteChilds();
                        }

                        pl.DeleteBase();

                    }

                    leafs.Clear();
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    throw;
                }
            }

        }
        public int ChildsCount { get { return childs.Count; } }
        public int LeafsCount { get { return leafs.Count; } }
        public List<PlComponent> Leafs { get { return leafs; } }

        public virtual bool remove(PlComponent child)
        {
            leafs.Remove(child);
            return childs.Remove(child);
        }

        public virtual PlayListComposite getComposite(String name)
        {
            foreach (PlComponent item in childs)
            {
                if (item.GetType().IsSubclassOf(typeof(PlayListComposite)))
                {
                    PlayListComposite composite = item as PlayListComposite;
                    if (composite.Name == name)
                        return composite;
                }
            }

            return null;
        }

        public virtual PlayListComposite getComposite(int id)
        {
            foreach (PlComponent item in childs)
            {
                if (item is PlayListComposite)
                {
                    PlayListComposite composite = item as PlayListComposite;
                    if (composite.ID == id)
                        return composite;
                }
            }

            return null;
        }



        public sealed override void Delete()
        {
            DeleteChilds();
            base.Delete();
        }


        public IEnumerator<PlComponent> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }
    }
    public class PieceInAList : PlComponent
    {
        private ITrackMetaData piece;
        public PieceInAList(ITrackMetaData piece)
        {
            if (piece == null)
                throw new ArgumentNullException();
            this.piece = piece; }
        public override string ToString()
        {
            return piece.ToString();
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public ITrackMetaData Piece { get { return piece; } }

        public string Name { get { return piece.Name; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } }

    }

    public class DefautComponentCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            return new PieceInAList(source as ITrackMetaData); 
        }
    }
}]]></content>
  </file>
</db>
