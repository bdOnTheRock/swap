<db path="C:\Bernard\db1\db4">
  <file path="\pdb.sln">
    <content><![CDATA[
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb", "pdb.csproj", "{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.it", "pieceDb.iT\pdb.it.csproj", "{CF5DB63F-4790-4351-9050-B30DED32F052}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.obj", "PieceDb.obj\pdb.obj.csproj", "{9B849072-2B8E-4CE4-8AD7-D173724A9644}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.db", "PieceDb.Db\pdb.db.csproj", "{43D27B47-E615-451D-AD25-67C5B8447C4A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.gen", "PieceDb.Consolid\pdb.gen.csproj", "{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.gen.it", "PieceDb.iT.listGen\pdb.gen.it.csproj", "{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testMoveTree", "testMoveTree\testMoveTree.csproj", "{FF82B72D-A119-4B53-9D35-2269FF6E5384}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "podcast", "podcast\podcast.csproj", "{CF22411A-0D1B-4301-9087-DFBCF85AB16A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.util", "pdb.util\pdb.util.csproj", "{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "hello", "WPF\hello\hello.csproj", "{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.podcast", "pdb.podcast\pdb.podcast.csproj", "{6503C759-0373-4B68-A28B-1CB5FF0E6208}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "grant", "grant\grant.csproj", "{5E84FD2F-0954-4D9B-AF17-36F857490C6A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testSDK", "testSDK\testSDK.csproj", "{30459276-DDC7-4BF5-AF55-CDD7211FD791}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "purgeZique", "purgeZique\purgeZique.csproj", "{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.daemon", "pdb.daemon\pdb.daemon.csproj", "{D69D572F-67C8-47E8-93B0-CC33FA4BC704}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "podcastCopy", "podcastCopy\podcastCopy.csproj", "{F916911A-B4FF-4B0A-BA80-B8349E3E0130}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testFormar", "testFormar\testFormar.csproj", "{32A79657-7A1F-4F72-99D8-4406838182F2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.ordo", "pdb.ordo\pdb.ordo.csproj", "{30823D1D-851C-456B-AC4C-B0BEEC173361}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "engine", "engine", "{B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "vlc", "vlc", "{C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine", "engine\pdb.player.engine\pdb.player.engine.csproj", "{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.build", "engine\pdb.player.engine.build\pdb.player.engine.build.csproj", "{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.vlc.pluginI", "engine\vlc\pdb.player.engine.vlc.pluginI\pdb.player.engine.vlc.pluginI.csproj", "{610EF011-6738-49D6-8426-4B162726D57E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.vlc.plugin", "engine\vlc\pdb.player.engine.vlc.plugin\pdb.player.engine.vlc.plugin.csproj", "{3CD9378E-BE8C-4E38-B362-51363357988C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testStats", "testStats\testStats.csproj", "{07095C40-49A3-4001-8671-4285D9633596}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "2001", "2001\2001.csproj", "{37020161-0E95-46F0-9FD1-DE43C491FA08}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player", "pdb.player\pdb.player.csproj", "{4166FA60-B33F-4496-9352-EDD8F3214021}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testmatchalbum", "..\testmatchalbum\testmatchalbum.csproj", "{B901D21E-A546-4628-9136-B8D5E3FF4A1A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x64.ActiveCfg = Debug|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x64.Build.0 = Debug|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x86.ActiveCfg = Debug|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x86.Build.0 = Debug|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Any CPU.Build.0 = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x64.ActiveCfg = Release|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x64.Build.0 = Release|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x86.ActiveCfg = Release|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x86.Build.0 = Release|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x64.ActiveCfg = Debug|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x64.Build.0 = Debug|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x86.ActiveCfg = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x86.Build.0 = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Any CPU.Build.0 = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x64.ActiveCfg = Release|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x64.Build.0 = Release|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x86.ActiveCfg = Release|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x86.Build.0 = Release|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x64.ActiveCfg = Debug|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x64.Build.0 = Debug|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x86.ActiveCfg = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x86.Build.0 = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Any CPU.Build.0 = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x64.ActiveCfg = Release|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x64.Build.0 = Release|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x86.ActiveCfg = Release|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x86.Build.0 = Release|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x64.ActiveCfg = Debug|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x64.Build.0 = Debug|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x86.ActiveCfg = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x86.Build.0 = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Any CPU.Build.0 = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x64.ActiveCfg = Release|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x64.Build.0 = Release|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x86.ActiveCfg = Release|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x86.Build.0 = Release|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x64.ActiveCfg = Debug|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x64.Build.0 = Debug|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x86.ActiveCfg = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x86.Build.0 = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Any CPU.Build.0 = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x64.ActiveCfg = Release|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x64.Build.0 = Release|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x86.ActiveCfg = Release|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x86.Build.0 = Release|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x64.ActiveCfg = Debug|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x64.Build.0 = Debug|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x86.ActiveCfg = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x86.Build.0 = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Any CPU.Build.0 = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x64.ActiveCfg = Release|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x64.Build.0 = Release|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x86.ActiveCfg = Release|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x86.Build.0 = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|Any CPU.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x64.ActiveCfg = Debug|x64
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x86.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x86.Build.0 = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Any CPU.ActiveCfg = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Mixed Platforms.Build.0 = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|x64.ActiveCfg = Release|x64
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|x86.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x64.ActiveCfg = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x86.ActiveCfg = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x86.Build.0 = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Any CPU.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Mixed Platforms.Build.0 = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|x64.ActiveCfg = Release|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|x86.ActiveCfg = Release|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x64.ActiveCfg = Debug|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x64.Build.0 = Debug|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x86.ActiveCfg = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x86.Build.0 = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Any CPU.Build.0 = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x64.ActiveCfg = Release|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x64.Build.0 = Release|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x86.ActiveCfg = Release|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x86.Build.0 = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|Any CPU.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x64.ActiveCfg = Debug|x64
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x86.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x86.Build.0 = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Any CPU.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Mixed Platforms.Build.0 = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x64.ActiveCfg = Release|x64
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x86.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x86.Build.0 = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x64.ActiveCfg = Debug|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x64.Build.0 = Debug|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x86.ActiveCfg = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x86.Build.0 = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Any CPU.ActiveCfg = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Mixed Platforms.Build.0 = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x64.ActiveCfg = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x64.Build.0 = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x86.ActiveCfg = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x86.Build.0 = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x64.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x86.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x86.Build.0 = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Any CPU.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Mixed Platforms.Build.0 = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x64.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x86.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x86.Build.0 = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|Any CPU.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x64.ActiveCfg = Debug|x64
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x86.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x86.Build.0 = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Any CPU.ActiveCfg = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Mixed Platforms.Build.0 = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|x64.ActiveCfg = Release|x64
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|x86.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|Any CPU.ActiveCfg = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x64.ActiveCfg = Debug|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x86.ActiveCfg = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x86.Build.0 = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Any CPU.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Mixed Platforms.Build.0 = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|x64.ActiveCfg = Release|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|x86.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x64.ActiveCfg = Debug|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x86.ActiveCfg = Debug|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x86.Build.0 = Debug|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Mixed Platforms.Build.0 = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x64.ActiveCfg = Release|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x64.Build.0 = Release|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x86.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x86.Build.0 = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Any CPU.ActiveCfg = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x64.ActiveCfg = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x86.ActiveCfg = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x86.Build.0 = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Any CPU.ActiveCfg = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Mixed Platforms.Build.0 = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|x64.ActiveCfg = Release|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|x86.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|Any CPU.ActiveCfg = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x64.ActiveCfg = Debug|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x86.ActiveCfg = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x86.Build.0 = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Any CPU.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Mixed Platforms.Build.0 = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|x64.ActiveCfg = Release|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|x86.ActiveCfg = Release|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x64.ActiveCfg = Debug|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x64.Build.0 = Debug|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x86.ActiveCfg = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x86.Build.0 = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Any CPU.Build.0 = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x64.ActiveCfg = Release|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x64.Build.0 = Release|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x86.ActiveCfg = Release|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x86.Build.0 = Release|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Any CPU.Build.0 = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|x64.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|x86.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Any CPU.Build.0 = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|x64.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|x86.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Any CPU.Build.0 = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|x64.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|x86.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x86.ActiveCfg = Debug|x86
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x86.Build.0 = Debug|x86
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Any CPU.Build.0 = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|x64.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|x86.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|x64.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|x86.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Any CPU.Build.0 = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|x64.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|x86.ActiveCfg = Release|Any CPU
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Any CPU.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x64.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x86.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x86.Build.0 = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Any CPU.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Mixed Platforms.Build.0 = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x64.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x86.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x86.Build.0 = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x64.ActiveCfg = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x86.ActiveCfg = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x86.Build.0 = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Any CPU.Build.0 = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x64.ActiveCfg = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x86.ActiveCfg = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x86.Build.0 = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x64.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x86.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x86.Build.0 = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Any CPU.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Mixed Platforms.Build.0 = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x64.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x86.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{C7DF1F85-A6D6-4771-8870-2CC0F2A0041E} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{610EF011-6738-49D6-8426-4B162726D57E} = {C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}
		{3CD9378E-BE8C-4E38-B362-51363357988C} = {C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}
	EndGlobalSection
EndGlobal
]]></content>
  </file>
  <file path="\engine\pdb.player.engine.build\PlayerBuilder.cs">
    <content><![CDATA[using pdb.player.engine.vlc.pluginI;

namespace pdb.player.engine.build
{
    public class PlayerBuilder
    {
        private static IPlayerEngine player;
        private static IPlayerEngineList playerList; 
        public static IPlayerEngine create(string type)
        {
            if (player == null)
                player = new VlcWrapper();
            return player;
        }

        //public static IPlayerEngineList createEngineList(string type)
        //{
        //    if (playerList == null)
        //        playerList = new VlcWrapperList();
        //    return playerList;
        //}

        public static IPlayerEngine Player { get { return player; } }
        public static IPlayerEngineList PlayerList { get { return playerList; } }
    }
}
]]></content>
  </file>
  <file path="\engine\vlc\pdb.player.engine.vlc.pluginI\VlcWrapper.cs">
    <content><![CDATA[using AXVLC;
using pdb.util;
using System;
using pdb.obj;
using System.Threading;
using System.Text.RegularExpressions;
using System.IO;
using System.Globalization;

namespace pdb.player.engine.vlc.pluginI
{
    public class VlcWrapper : IPlayerEngine
    {

        private Logger logger;
#if NONI
        private VLCPlugin2Class vlc;
        Equalization eq = Equalization.Instance; 
#else
        private VLCPlugin2 vlc;
#endif
        public event EventHandler mediaEndReached;
        // public static VlcWrapper Instance = new VlcWrapper();
        public VlcWrapper()
        {
            logger = Logger.getLogger("vlc");
            try
            {
#if NONI
          vlc = new VLCPlugin2Class();
     //     vlc.setVariable(Equalization.VARGAIN, eq.getVarGain());
     //     vlc.setVariable(Equalization.VARFREQ, eq.getVarFreq()); 
                
#else
                vlc = new VLCPlugin2();


#endif
            }
            catch (Exception e)
            {
                logger.log("impossible de récupérer vlc " + e.ToString());
            }

            catch
            {
            }

#if NONI
            vlc.DVLCEvents_Event_pause += vlc_DVLCEvents_Event_pause;
            vlc.DVLCEvents_Event_play += vlc_DVLCEvents_Event_play;
            vlc.DVLCEvents_Event_stop += vlc_DVLCEvents_Event_stop;
            
#else
            vlc.MediaPlayerEncounteredError += vlc_MediaPlayerEncounteredError;
            vlc.MediaPlayerEndReached += vlc_MediaPlayerEndReached;
            vlc.MediaPlayerPaused += vlc_pause; //  new DVLCEvents_pauseEventHandler(vlc_pause);
            vlc.AutoLoop = false;
            vlc.AutoPlay = false;

#endif
        }

        void vlc_pause()
        {
            log("vlc_pause");
        }

        #region event
        void vlc_MediaPlayerEndReached()
        {
            vlc.playlist.stop();
            log("vlc_MediaPlayerEndReached");
            if (mediaEndReached != null)
                mediaEndReached(this, EventArgs.Empty);
        }

        void vlc_MediaPlayerEncounteredError()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_stop()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_play()
        {
            log("vlc_DVLCEvents_Event_play");
        }

        void vlc_DVLCEvents_Event_pause()
        {
            log("vlc_DVLCEvents_Event_pause");
        }

        private void log(string txt)
        {
            logger.log(txt);
        }
        #endregion

        #region commande
        string location;
        int currentItem;
        public void play(string location, bool reload)
        {
            if (reload || location != this.location)
            {
                this.location = location;
#if NONI
                vlc.playlistClear();
                vlc.addTarget(new Uri(location).AbsoluteUri, null, VLCPlaylistMode.VLCPlayListReplaceAndGo, 0);
#else
                vlc.playlist.items.clear();
                currentItem = vlc.playlist.add(new Uri(location).AbsoluteUri);
                vlc.playlist.playItem(currentItem);
#endif
            }
            else
                vlc.playlist.play();


#if NONI
            vlc.play();
#else

#endif
        }

        public void pause()
        {
#if NONI
            vlc.pause();
#else
            vlc.playlist.pause();
#endif
        }

        public void stop()
        {
#if NONI
            vlc.stop();
#else
            vlc.playlist.stop();
#endif
        }

        public TimeSpan Duration
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.length);
            }
        }
        public TimeSpan getDurationOrThrow()
        {
            var l = vlc.input.length;
            if (l < 100)
                throw new ApplicationException("trop court");

            return TimeSpan.FromMilliseconds(l);
        }

        public TimeSpan Elapsed
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.time);
            }
        }

        public double Position
        {
            get
            {

                var input = vlc.input;
                if (input == null)
                    return 0;
                return input.position;
            }

            set
            {
                var input = vlc.input;
                if (input == null)
                    return;
                input.position = value;
            }
        }

        public double Volume
        {
            set
            {
                try
                {
                    vlc.volume = (int)(200 * value);
                }
                catch { }
            }

            get
            {
                return 200 * vlc.volume;
            }
        }

        #endregion

        #region equalizer
        #endregion





        private playerstate state = playerstate.stop;
        public playerstate State
        {
            get { return state; }
        }

        private void insist(string phase, Action action)
        {
            DateTime end = DateTime.Now.AddSeconds(1);
            int nb = 1; 
            while (true)
            {
                //vlc.volume = 0;
                //vlc.playlist.play();
                try
                {
                    action();
                    return;
                }
                catch (Exception ex)
                {
                    misc.log(ex.Message + " " + nb + " " + phase);
                    Thread.Sleep(100);
                    if (DateTime.Now > end)
                    {
                        misc.log("abandon " + phase);
                        return;
                    }

                    // vlc.volume = 0;
                    //vlc.playlist.items.clear();
                    //currentItem = vlc.playlist.add(new Uri(location).AbsoluteUri);
                    //vlc.playlist.playItem(currentItem);
                    Thread.Sleep(100 * nb);
                    nb++; 
                }
            }
        }

        public void getDuration(ITrackMetaData track)
        {
            int vol = vlc.volume;
            try
            {
                vlc.playlist.items.clear();
                location = track.Location;
                currentItem = vlc.playlist.add(new Uri(location).AbsoluteUri);
                vlc.volume = 0;
                vlc.playlist.play();

                while (!vlc.playlist.isPlaying)
                    Thread.Sleep(100);
                // vlc.playlist.pause();


                //vlc.playlist.play();
                //vlc.volume = 0;

                insist("Duration", () => track.Duration = getDurationOrThrow());



            }

            finally
            {
                vlc.playlist.stop();
                vlc.volume = vol;
            }
        }


        public void load(ITrackMetaData track)
        {
            int vol = vlc.volume;
            var cur = currentItem;
            var oldLocation = this.location;
            try
            {
                vlc.playlist.items.clear();

                //vlc.volume = 0;
                this.location = track.Location;
                currentItem = vlc.playlist.add(new Uri(location).AbsoluteUri);
                vlc.playlist.playItem(currentItem);

                while (!vlc.playlist.isPlaying)
                    Thread.Sleep(100);
                // vlc.playlist.pause();


                //  vlc.playlist.play();
                // vlc.volume = 0;

                insist("Duration", () => track.Duration = getDurationOrThrow());

                if (string.IsNullOrEmpty(track.Album))
                {
                    insist("Album", () =>
                        {
                            var album = vlc.mediaDescription.album;
                            if (album != null)
                            {
                                track.Album = album;

                            }

                        });
                }
                if (string.IsNullOrEmpty(track.Artist))
                    insist("Artist", () => track.Artist = vlc.mediaDescription.artist);

                if (string.IsNullOrEmpty(track.Name))
                    insist("Name", () => track.Name = vlc.mediaDescription.title);
                if (track.TrackNumber <= 0)
                {
                    insist("TrackNumber", () =>
                    {
                        string tn = vlc.mediaDescription.trackNumber;

                        //if (!string.IsNullOrEmpty(tn))
                        //{
                        //    try
                        //    {
                        track.TrackNumber = Convert.ToInt32(tn);
                        //    }
                        //    catch
                        //    {
                        //    }
                        //}
                    });
                }
                if (track.Year <= 0)
                {
                    insist("Year", () =>
                    {

                        string date = vlc.mediaDescription.date;
                        //DateTime dateC = DateTime.MinValue;
                        //if (!string.IsNullOrEmpty(date))
                        //{
                        //    try
                        //    {
                        track.Year = Convert.ToInt32(date);
                        //    }
                        //    catch
                        //    {
                        //    }
                        //}
                    });
                }

            }

            finally
            {
                //vlc.volume = vol;
                if (!string.IsNullOrEmpty(oldLocation))
                {
                    location = oldLocation;
                    vlc.playlist.items.clear();
                    currentItem = vlc.playlist.add(new Uri(location).AbsoluteUri);
                }
            }
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;
using pdb.db.obj;
using pdb.gen.albums;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {

                pdb.player.ViewModel.Colors.MementoColor.recover();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0); 
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }


        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList(), true);



            if (CConf.ResetOneCl)
            {
                Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                foreach (Piece p in gen.sortByClass())
                {
                    decimal clValue = p.ClassementValueDecimal;
                    if (clValue > zer0d)
                    {
                        if (clValue >= zer0d)
                        {
                            var dPiece = Db.getPiece(p.PieceId);
                            var strNewCl = "0000" + dPiece.getClassement().ToString();
                            var newCl = Classement.create(strNewCl);
                            p.Enabled = true;

                            p.setClassement(newCl.ClassList, newCl.Rating);
                            dPiece.Classement.eraseClassement2(newCl);
                        }
                        else
                            p.Enabled = false;
                    }
                }
                /*
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = int.MaxValue;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue > zer0d)
                        {
                            if (clValue < pluspetitNonNull)
                                pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.Classement.eraseClassement2();
                                }
                            }
                        }
                    }
                }*/
                gen.MakeConsolid(Db.List.getList(), true);
            }


            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;

                if (refreshAlbum != null && _currentTrack != null)
                {
                    gen.Albums.makeSort(_currentTrack.PieceGen);
                    _currentTrack.refresh();
                    refreshAlbum("", EventArgs.Empty);
                }

                _currentTrack = null;


                // if (__end || __go) return;

                if (PlayerViewModel.Instance.CreateRot)
                {
                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(), _updateStats); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);



                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none);

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;
                    }
                }
            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\RoutedCommandWrapper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;

namespace pdb.player.Vue
{
    public class RoutedCommandWrapper 
    {
        private ICommand command;
        private RoutedCommand routed;
        private CommandBinding binding;
        public RoutedCommandWrapper(ICommand command, RoutedCommand routed, CommandBinding binding)
        {
            this.command = command;
            this.routed = routed;
            this.binding = binding; 
            
        }
        
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Simulation\AutoParam.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace pdb.podcast.Simulation
{
    public class AutoParam
    {
        public timeSpan d;
        public timeSpan fd;
        public timeSpan nb;
        public timeSpan date; 
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\ILimitItemBase.cs">
    <content><![CDATA[using System;
namespace pdb.podcast.Tuning
{
    
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\WriterTask.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.obj;
using pdb.util;

namespace pdb.gen
{
    public class WriterTask
    {
        private readonly string folder;
        private readonly string name;
        private readonly ICollection<IFile> list;
        private IListWriter writer;


        public WriterTask(string folder, string name, ICollection<IFile> list, IListWriter writer)
        {
            this.folder = folder;
            this.name = name;
            this.list = list;
            this.writer = writer;
           // misc.log("{0} enqueue task {1}", writer.Type, name);
        }
        public void execute()
        {
            try
            {
              //  misc.log("{0} execute task {1}", writer.Type, name);
                writer.writePlayList(folder, name, list); 
            }
            catch (Exception e)
            {
                misc.log("name {0} {1} {2}", writer.Type, name, e.ToString());
            }
        }
       
    }

 
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\DataConf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using pdb.util;

namespace pdb.gen.Tuning
{
   public class DataConf
    {
       public readonly FileInfo dbLocal;
       public readonly FileInfo dbRemote;
       public readonly FileInfo dbTrace; 

       public readonly FileInfo dbSov;
      
       public string sZip = @"C:\Program Files\7-Zip\7z.exe"; 

       public DataConf(XmlElement node)
       {
           XMLTool l_xmlConf = new XMLTool(node);
           string str = l_xmlConf.getNodeValue("dbLocal");
           dbLocal = new FileInfo(str);

           str = l_xmlConf.getNodeValue("dbRemote");
           dbRemote = new FileInfo(str);

           str = l_xmlConf.getNodeValue("dbSov");
           dbSov = new FileInfo(str);

           str = l_xmlConf.getNodeValue("dbTrace");
           dbTrace = new FileInfo(str);

           str = l_xmlConf.getNodeValue("zip");
           sZip = str; 


       }
       public string Zip { get { return sZip; } }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\TuningData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.gen.conf;
using System.Globalization;

namespace pdb.gen.Tuning
{
    public class TuningData : IComparable <TuningData>
    {
        /// <summary>
        /// rang dans le tri des listes
        /// </summary>
        private int rankList;
        public int Rank { set { rankList = value; } }

        /// <summary>
        /// reste de temps
        /// </summary>
        private double rest;
        public double Rest { get { return rest; } set { rest = value; } }

        private int nbLect;
        public int NbLect { get { return nbLect; } set { nbLect = value; } }

        private int nblectAndDeltaClass;

        public int NblectAndDeltaClass { get { return nblectAndDeltaClass; } set { nblectAndDeltaClass = value; } }


        private double sort;
        public double Sort { set { sort = value; } }

        public override string ToString()
        {
            if (this == _null)
                return "";
            return string.Format(CultureInfo.InvariantCulture,"{0} {1} {2} {3:0} {4:0}",  CTuning.getFormat(rankList),nbLect, nblectAndDeltaClass, (100 *rest), (100 *sort)); 
        }

        private static TuningData _null = new TuningData() { rankList = -1 , rest = double.MaxValue}; 
        public static TuningData Null
        {
            get
            {
                return _null; 
            }
        }



        public int Compare(TuningData x, TuningData y)
        {
            return x.sort.CompareTo(y.sort); 
        }

        public int CompareTo(TuningData other)
        {
            return -sort.CompareTo(other.sort); 
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math;

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        // const string ZIP_KEY = "db"; 
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        //private bool loadLastFull;
        //private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            if (conf.compressID)
            {
                compressIds();
                WriteDB1();

                return;
            }
            else if (conf.synchroID)
            {
                synchroIds();
                WriteDB1();
                return;
            }
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        // r�cup�ration des infos externes
        public void LegacyConsolid(CListPiece list, DateTime date)
        {
            misc.log("Cdb::LegacyConsolid");

            DateTime now = DateTime.Now;
            ChronoData.refreshDate(date);

            foreach (CPiece ext in list)
            {
                m_list.legacyConsolid(ext);
            }

            m_list.bilanNatives();

            // setAlbumArtistFromFile();

        }

        public void LegacyConsolid(CPiece ext)
        {
            m_list.legacyConsolid(ext);
        }

        public void SynchroNative(DateTime date)
        {
            misc.log("Cdb::SynchroNative");
            ChronoData.refreshDate(date);
            foreach (CPiece piece in m_list)
            {
                piece.SynchroNative();
            }

        }

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        //public void Sov(string fileIt)
        //{
        //    if (SOV == null)
        //        return;
        //    var list = new List<string> { fileIt, LOCAL_FILE.FullName };
        //    if (loadRemote)
        //        list.Add(REMOTE_FILE.FullName);
        //    if (loadTrace)
        //        list.Add(remoteTrace.FullName);

        //    ZipUtil.compress(SOV.FullName, sovRep, list);
        //}

        public void SovIni()
        {
            ZipUtil.Enter();
            if (SOV == null)
                return;
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni);

            ZipUtil.CompressAsync(SOV.FullName, sovRep, list);
            ZipUtil.Release();
        }


        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                ZipUtil.Enter();
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
                ZipUtil.Release();
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        public void export(string filename, List<CPiece> l)
        {

            var list = new List<CPiece>();
            var hs = new HashSet<int>();
            foreach (CPiece p in l)
            {
                if (hs.Add(p.PieceId))
                    list.Add(p);
                if (p.PieceParentId > 0)
                {
                    var parent = m_list.getPiece(p.PieceParentId);
                    if (hs.Add(parent.PieceId))
                        list.Add(p);
                }
            }

            m_list.Sort(list);

            var f = conf.getFilename(filename);
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(f, settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());


                writer.WriteStartElement(CListPiece.PIECES);

                foreach (CPiece l_piece in list)
                {
                    l_piece.write(writer);
                }
                writer.WriteEndElement();


                writer.WriteEndDocument();
                writer.Flush();
            }
        }

        private void write()
        {
            try
            {
                ZipUtil.Enter();
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
                {
                    writer.WriteStartElement("db");
                    writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                    m_list.write(writer);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



                if (lastFull != null)
                {
                    try
                    {
                        var diff = DiffFile.FullName;
                        if (mode == dbMode.full)
                            diff = diff.Replace(".xml", ".d.xml");

                        using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                        {
                            writer.WriteStartElement("db");
                            writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                            writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                            m_list.writeDiff(writer, lastFull);
                            writer.WriteEndDocument();
                            writer.Flush();
                        }

                        File.Copy(diff + ".tmp", DiffFile.FullName, true);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }



                WriteDB2();
            }
            finally
            {
                ZipUtil.Release();
            }
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        private void WriteDB2()
        {

            misc.log("CDb:WriteDB2");

            lock (lockSave)
            {
                ZipUtil.Enter();
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
                ZipUtil.Release();
            }
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff);
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }
            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.CompressAsync(SOV.FullName, sovRep, list, withHorodate);
            //   ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece);
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }


        public void synchroIds()
        {
            misc.log("WARNING:::::::::::Compressids");
            lastFull = loadData(LastFullFile);


            m_list = loadData(LOCAL_FILE);

            List<CPiece> listC = m_list.getList();

            for (int i = 0; i < listC.Count; i++)
            {
                var p = listC[i];
                var parent = p.Parent;


                var org = lastFull.tryGetPiece(p);
                // var org0 = lastFull.tryGetPieceWithoutId(p);
                if (org.Location != p.Location)
                {
                    org = lastFull.tryGetPieceWithoutId(p);
                }

                if (p.PieceId == org.PieceId)
                {

                }
                else
                {
                    // ????
                    p.setId(org.PieceId);
                }



                if (parent != null)
                {
                    var porg = lastFull.tryGetPiece(parent);

                    if (porg.Location != parent.Location)
                        porg = lastFull.tryGetPieceWithoutId(parent);


                    if (parent.PieceId == porg.PieceId)
                    {

                    }
                    else
                    {
                        // ????
                        p.PieceParentId = porg.PieceId;
                    }
                }

            }
            m_list.refresh(); 

        }


        public void compressIds()
        {
            misc.log("WARNING:::::::::::Compressids");

            lastFull = loadData(LastFullFile);


            List<CPiece> listFull = lastFull.getList();
            // loadList(LastFullFile, listFull);
            listFull.Sort((x, y) => x.PieceId.CompareTo(y.PieceId));
            var dict = new Dict<int, int>();

            int newID = 0;
            for (int i = 0; i < listFull.Count; i++)
            {
                newID++;
                var p = listFull[i];
                dict[p.PieceId] = newID;
            }

            pieceSequenceId = newID;

            for (int i = 0; i < listFull.Count; i++)
            {
                var p = listFull[i];
                p.setId(dict[p.PieceId]);
                if (p.PieceParentId > 0)
                {
                    p.PieceParentId = dict[p.PieceParentId];
                }
            }

            //     lastFull = new CListPiece(listFull, LastFullFile.LastWriteTime);
            lastFull.refresh();
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(LastFullFile.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                lastFull.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(LastFullFile.FullName + ".tmp", LastFullFile.FullName, true);

            m_list = loadData(LOCAL_FILE);

            List<CPiece> listC = m_list.getList();

            for (int i = 0; i < listC.Count; i++)
            {
                var p = listC[i];
                var parent = p.Parent;

                var newId = dict[p.PieceId];
                if (newID > 0)
                {
                    var org = lastFull.tryGetPiece(p);
                    var org0 = lastFull.tryGetPieceWithoutId(p);
                    if (org == org0)
                    {
                        p.setId(newId);

                        if (parent != null)
                        {
                            var newPId = dict[parent.PieceId];
                            if (newPId > 0)
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                var porg0 = lastFull.tryGetPieceWithoutId(parent);

                                if (porg == porg0)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }
                            else
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                if (porg.Location == parent.Location)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }

                        }

                    }
                    else
                    {
                        if (org0.Location == p.Location)
                        {
                            p.setId(org0.PieceId);
                        }
                    }
                }
                else
                {
                    var org = lastFull.tryGetPiece(p);
                    if (org.Location == p.Location)
                    {
                        p.setId(org.PieceId);

                        if (parent != null)
                        {
                            var newPId = dict[parent.PieceId];
                            if (newPId > 0)
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                var porg0 = lastFull.tryGetPieceWithoutId(parent);

                                if (porg == porg0)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }
                            else
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                if (porg.Location == parent.Location)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }

                        }
                    }
                    else
                    {

                    }



                }


            }
            m_list.refresh();
            //  m_list = new CListPiece(listC, LOCAL_FILE.LastWriteTime); 

        }

        private CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }




        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(PlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
  <file path="\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_FOLDER = "f";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private PlayList listes = new PlayList("listes");
        public PlayList Listes { get { return listes; } }

        public const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            init(a_list); 

            //foreach (CPiece l_file in a_list)
            //{
            //    htIds[l_file.PieceId] = l_file;
            //    foreach (CFile file in l_file.Files)
            //    {
            //        htLoc[file.Path] = l_file;
            //    }
            //}
            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            //DateTime maxEnabled = DateTime.MinValue;
            //foreach (CPiece l_file in a_list)
            //{
            //    Add(l_file);
            //    //if (l_file.Enabled)
            //    //{
            //    //    var t = l_file.LastModifClass;
            //    //    if (t > maxEnabled)
            //    //        maxEnabled = t;
            //    //}
            //}
            //misc.log("***********************************************************");
            //misc.log("maxEnabled: {0}", maxEnabled);
            //misc.log("***********************************************************");
        }


        public void refresh()
        {
            var list = getList(); 
            ht = new DictRef<CPiece>();
            htIds = new BgDict<int, CPiece>();
            htLoc = new BgDictString<CPiece>();

            init(list); 
        }

        private void init(ICollection<CPiece> a_list)
        {
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
            }
        }

        public CListPiece()
        {

        }

        #endregion


        public void checkId(CPiece toCheck)
        {
            foreach (CFile f in toCheck.Files)
            {
                if (htLoc.ContainsKey(f.Path))
                {
                    var pOrg = htLoc[f.Path];
                    toCheck.setId(pOrg.PieceId);
                    toCheck.PieceParentId = pOrg.PieceParentId;
                }
            }
        }

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        public void bilanNatives()
        {
            misc.log("Bilan Natives");
            foreach (CPiece piece in this)
            {
                if (piece.HasNoNative)
                    misc.logNoDate(piece.ToString());
            }
        }

        private void merge(CPiece org, CPiece cand)
        {
            misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
            org.merge(cand);
        }

        public void AddOrMerge(CPiece piece, CPiece org)
        {
            if (org != null)
            {
                org.consolid(piece, mergePriority.right);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.addDataLink(toDelete);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            if (remote.PieceParentId > 0)
            {
                if (remote.Parent == null)
                    remote.Parent = htIds[remote.PieceParentId];


            }
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (remote.PieceParentId > 0)
                {
                    var parent = htIds[remote.PieceParentId];
                    misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                    l_pieceOrg.PieceParentId = remote.PieceParentId;
                    l_pieceOrg.Parent = parent;
                }
                //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                l_pieceOrg.consolid(remote, a_priority);
            }
        }

        /// <summary>
        /// synchro enrte base locale et liste native
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece native)
        {
            CPiece l_pieceOrg = getPiece(native);

            if (l_pieceOrg == null)
            {
                log("add from business:" + native.ToString());
                l_pieceOrg = new CPiece(native);
                l_pieceOrg.legacyConsolid(native);
                Add(l_pieceOrg);
            }
            else
            {
                l_pieceOrg.legacyConsolid(native);
            }

        }

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece tryGetPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.Try(key); 
        }

        public CPiece tryGetPieceWithoutId(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.TryWithoutId(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        public void moveId(int oldId, CPiece piece)
        {

        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, PIECES);
            foreach (CPiece l_piece in this)
            {
                l_piece.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, PIECES);
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            Sort(list);

            return list;
        }

        public void Sort(List<CPiece> list)
        {
            list.Sort(new PieceComparer());
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, PlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    PlayList sub = new PlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];

                    // var tl = new TrackList(piece);
                    parent.add(piece);
                }
            }
        }

        private void writeList(XmlWriter w, PlayList parent)
        {
            foreach (PlayList pl in parent.PlayLists)
            {
                w.WriteStartElement(TOKEN_LIST);
                w.WriteAttributeString("id", pl.ID.ToString());
                w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                writeList(w, pl);
                w.WriteEndElement();
            }

            foreach (IItem t in parent.Items)
            {
                w.WriteStartElement(TOKEN_LIST_TRACK);
                w.WriteAttributeString("id", t.ID.ToString());
                w.WriteEndElement();
            }
            //foreach (PlComponent c in parent)
            //{
            //    if (c is CPlayList)
            //    {
            //        var pl = c as CPlayList;
            //        w.WriteStartElement(TOKEN_LIST);
            //        w.WriteAttributeString("id", pl.ID.ToString());
            //        w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
            //        writeList(w, pl);
            //        w.WriteEndElement();
            //    }
            //    else if (c is TrackList)
            //    {
            //        var t = c as TrackList;
            //        w.WriteStartElement(TOKEN_LIST_TRACK);
            //        w.WriteAttributeString("id", t.PieceId.ToString());
            //        w.WriteEndElement();
            //    }
            //}
        }

        public void buildLists(PlayList listes)
        {
            this.listes.DeleteChilds();
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                CDb.checkId(sub);
                subExt.ID = sub.ID;

                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }
        }
        #endregion
    }

}






]]></content>
  </file>
  <file path="\PieceDb.Db\DataConf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using pdb.util;

namespace pdb.db
{

    public class DataConf : TuningBase
    {
        public readonly FileInfo dbLocal;
        public readonly FileInfo dbRemote;
        public readonly FileInfo dbTrace;
        public readonly FileInfo dbSov;
        public readonly FileInfo dbLastFull;
        public readonly FileInfo dbDiff;
        public readonly dbMode mode;
        public int sovNb = 10;
        public TimeSpan sovMin = TimeSpan.FromHours(1);

        public string sZip = @"C:\Program Files\7-Zip\7z.exe";
        public readonly string defaultFolder;
        private string root;
        public List<string> othersIni = new List<string>();
        public List<string> othersDiff = new List<string>();

        public bool compressID;
        public bool synchroID; 
        public string getFilename(string str)
        {
            return root + str;
        }

        public DataConf(XmlElement node)
            : base()
        {
            if (node == null)
                return;

            root = DIR_CONF;

            var dataNode = XMLTool.NodeLookUp(node, "data");
            if (dataNode == null)
                return;

            var att = dataNode.Attributes["root"];
            if (att != null)
            {
                root = root + att.Value;
            }
            this.child = dataNode;
            XMLTool l_xmlConf = new XMLTool(dataNode);
            string str = l_xmlConf.getNodeValue("dbLocal");
            dbLocal = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbRemote");
            dbRemote = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbSov");
            if (string.IsNullOrEmpty(str))
                dbSov = null;
            else
                dbSov = new FileInfo(DIR_CONF + str);

            str = l_xmlConf.getNodeValue("dbTrace");
            dbTrace = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbLastFull");
            dbLastFull = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbDiff");
            dbDiff = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("mode");
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);


            str = l_xmlConf.getNodeValue("zip");
            sZip = str;

            defaultFolder = l_xmlConf.getNodeValue("defaultFolder");

            buildi("sovNb", (v) => sovNb = v);
            double _deltaMin = -1;
            buildd("sovMin", (v) => _deltaMin = v);
            if (_deltaMin > 0)
                sovMin = TimeSpan.FromMinutes(_deltaMin);

            compressID = l_xmlConf.getBoolValue("compressID");
            synchroID = l_xmlConf.getBoolValue("synchroID"); 

            var xother = XMLTool.NodeLookUp(dataNode, "others");
            if (xother != null)
            {
                foreach (XmlNode xsub in xother.ChildNodes)
                {
                    if (xsub is XmlElement)
                    {
                        var name = xsub.Name;
                        var content = DIR_CONF + xsub.InnerText;
                        if (name == "ini")
                            othersIni.Add(content);
                        else if (name == "diff")
                            othersDiff.Add(content);
                    }
                }
            }

        }
        public string Zip { get { return sZip; } }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes, IItem
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
        private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";
        private const string TOKEN_ADDED = "added";

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private DateTime added;
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
        private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        public DateTime Added { get { return added; } }
        public void setAdded(DateTime dt) { added = dt; }

        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        //private void OnCommentChange(String value)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.Comment = value;
        //}
        //private void OnGroupingChange(String value, bool prior)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.setGrouping(value, prior);
        //}
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement();
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
            this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(className, ext.Rating);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;

            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable();
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement();

            }





            var xtool = new XMLTool(a_xml);
            artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);




            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            string strAdded = "";
            var attAdded = a_xml.Attributes[TOKEN_ADDED];
            if (attAdded != null)
                strAdded = attAdded.Value;
            else
                strAdded = xtool.getNodeValue(TOKEN_ADDED);

            if (!string.IsNullOrEmpty(strAdded))
            {
                try
                {
                    added = Convert.ToDateTime(strAdded);
                }
                catch (Exception ex)
                {
                    log(string.Format("impossible de parser {0} {1} {2}", strAdded, this, ex));
                }
            }


            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        private void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        public void addDataLink(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement);
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                if (remote.added > DateTime.MinValue && remote.added < DateTime.MaxValue && remote.added != added)
                    added = remote.added; 

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece l_native)
        {



            //TODO éviter de créer un objet juste pour la comparaison
            //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



            //this.grouping = l_native.Grouping;
            //this.m_comment = l_native.Comment; 







            l_native.m_ref.legacyConsolid(this.m_ref);
            l_native.m_infos.legacyConsolid(this.m_infos);

            l_native.setClassPlayList(this);
            l_native.Classement.LegacyConsolid(this.Classement);
            l_native.Checked.LegacyConsolid(this.Checked);

            //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

            addData(l_native);

            this.m_playList = l_native.PLayLists;
            this.m_classPlayLists = l_native.ClassPlayLists;
            this.m_duration = l_native.Duration;
            raiseChangeRefEvent();

            //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
            this.native = l_native.native;

            checkNative();
        }

        /// <summary>
        /// Synchro directe entre la Db et le track Itunes (mode daemon)
        /// </summary>
        public void SynchroNative()
        {
            checkNative();
            if (native == null)
                return;

            m_ref.SynchroNative(native);
#if VOL
            m_infos.SynchroNative(native.Year, native.Volume);
#else
            m_infos.SynchroNative(native.Year);
#endif
            var newClassList = getClassName(native);
            Classement newCl = new Classement(newClassList, native.Rating);
            Classement.SynchroNative(newCl);
            Checked.SynchroNative(native.Enabled);

            this.ListDates.merge(native.PlayedDate);



            //  this.m_playList = native.PLayLists;
            this.m_classPlayLists = native.ClassPlayLists;
            if (native.Duration.TotalMilliseconds > 1)
                this.m_duration = native.Duration;
            raiseChangeRefEvent();
        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }



        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        private void setClassPlayList(ITrackNative pieceDb)
        {
            string dbClasslist = pieceDb.ClassName;
            int count = m_classPlayLists.Count;
            if (count > 0)
            {
                string className = m_classPlayLists[0].Name;
                if (count > 1)
                {
                    m_classPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in m_classPlayLists)
                    {
                        className = list.Name;
                        if (className == dbClasslist)
                            continue;
                        break;
                    }
                }

                if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
                {
                    misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                    return;
                }

                Classement.ClassList = className;

            }
        }

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        //utilisé par le player maison
        public void setClassPlayList(String name)
        {
            Classement.ClassList = name;
            // TODO Gérer l'absence de classList
        }

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            if (artWork.NotNullOrEmpty())
                XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
            if (added > DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_ADDED, added.ToString());

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (added > DateTime.MinValue)
                    w.WriteAttributeString(TOKEN_ADDED, added.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }



                if (artWork.NotNullOrEmpty())
                    w.WriteElementString(TOKEN_ARTWORK, artWork);



                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0} {1}", this, ex);
                throw;
            }
        }


        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());
            if (added != lastFull.added)
                w.WriteAttributeString("added", added.ToString()); 

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }






            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;

            if (added != lastFull.Added)
                return true; 

            //if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
            //    return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }




        public CListFile Files
        {
            get { if (parent == null) return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id == value)
                return; 
            if (value > 0)
            {
                key = null; 
                if (m_id > 0)
                    misc.log("id from {0} to {1} {2}", m_id, value, this);
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value;
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }





        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId);
            return string.Format("{0} {1}{2}{3} {4} {5}", Classement.Value, PieceId, parent, Name, Album, getLocation());
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return getLocation() + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return Files.Path;
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public string getLocation()
        {
            return Files.getLocation();
        }

        public bool Exists { get { return Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        //private string _comment;
        //public string Comment
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return "";
        //        if (_comment == null)
        //        {
        //            if (native != null)
        //                _comment = native.Comment;
        //        }
        //        return _comment;

        //        //string l_pref = "";
        //        //string l_str = "";

        //        //string l_strList = "";
        //        //if (ClassPlayList != null)
        //        //    l_strList = ClassPlayList.Name;

        //        //if (Classement.Imported)
        //        //{
        //        //    if (l_strList != ClassList)
        //        //    {
        //        //        l_pref = "m (" + ClassList + ") ";
        //        //    }
        //        //}
        //        //int l_rank = m_rank.Twice;
        //        //if (l_rank > 0)
        //        //{
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }

        //        //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
        //        //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //    //getTx(m_rank.Lenght)
        //        //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
        //        //}

        //        //return l_pref + l_str + getClassementEvol();

        //    }
        //    set
        //    {
        //        if (parent != null)
        //            return;
        //        if (value != _comment)
        //        {
        //            _comment = value;
        //            //if (value != Comment)
        //            //{
        //            // m_comment = value;
        //            OnCommentChange(value);
        //        }
        //        // }
        //    }
        //}
        //private string _grouping;
        //public string Grouping
        //{
        //    get
        //    {
        //        if (_grouping == null)
        //        {
        //            if (native != null)

        //                _grouping = native.Grouping;
        //        }
        //        return _grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (value != Grouping)
        //    //    //{
        //    //    //  grouping = value;
        //    //    OnGroupingChange(value);
        //    //    //}
        //    //}
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    if (value != _grouping)
        //    {
        //        _grouping = value;
        //        OnGroupingChange(value, prior);
        //    }
        //}

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }


        private CPiece parent;

        public void setParent(CPiece parent)
        {
            this.parent = parent;
        }
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {

                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    parent = null;
                    return;
                }
                else
                {
                    value.Master.addDataLink(this);
                    parent = value.Master;
                    PieceParentId = parent.PieceId;
                }



            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState;
        public exportState ExportStatus
        {
            get
            {
                return _exportState;
            }
            set
            {
                _exportState = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return Classement.getDates();
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }
    }
}






]]></content>
  </file>
  <file path="\PieceDb.obj\BgTask.cs">
    <content><![CDATA[using System;
using System.Linq;
using System.Text;
using System.Threading;
using pdb.util;
using System.Collections.Generic; 

namespace pdb.obj
{
   public interface IBgtask
    {
        void exec();
        void abort(); 
        bool Success { get; }
        bool Abort { get; }
        int Try { get; set; }
    }

    public abstract class BgTask : IBgtask
    {
        public abstract void exec();
        protected bool success;
        protected bool _abort; 
        private int _try; 
        public bool Success { get { return success; } }
        public int Try { get { return _try; } set { _try = value; } }
        public virtual void abort()
        {
            _abort = true; 
        }

        public bool Abort { get { return _abort; } }
    }

    public delegate void execDel();
    public class Bgtask : BgTask
    {
        public Bgtask(execDel impl)
        {
            this.impl = impl;
        }
        private execDel impl;


        public override void exec()
        {
            try
            {
                impl();
                success = true;
            }
            catch (Exception e)
            { misc.log("NIET " + e.Message); }

        }


    }


    public class BackGroundTaskMgr
    {
        private Thread th;
        private bool async = true;

        private string name;
        public BackGroundTaskMgr(string name)
        {
            this.name = name;
            list.Add(this); 
        }

        private static List<BackGroundTaskMgr> list = new List<BackGroundTaskMgr>();
        public static void End()
        {
            foreach (BackGroundTaskMgr mgr in list)
                mgr.end(); 
        }


        public bool Async { set { async = value; } }
        private volatile object _lock = new object();
        private LinkedTask first;
        private LinkedTask last;

        private bool _end;
        private bool _abort;

        public void end()
        {
            _end = true; 
        }

        public void Abort()
        {
            _abort = true; 
        }

        private void start()
        {

            if (async)
            {
                if (th != null)
                    return; 
                misc.log("démarrage de la pile " + name); 
                th = new Thread(loop);
                th.Name = name;
                th.Start();
            }
        }



        private const int NB=100; 
        public void add(IBgtask task)
        {
            if (async)
            {
                if (task.Try >= NB)
                {
                    misc.log("tache abandonnées après {0} essais", NB);
                    return;
                }
                var ll = new LinkedTask(task);
                lock (_lock)
                {
                    start(); 
                    if (last != null)
                    {
                        last.Next = ll;
                    }

                    last = ll;

                    if (first == null)
                        first = last;
                }

            }
            else
                task.exec();
        }

        private void loop()
        {
            while (!_abort)
            {
                Thread.Sleep(30);

                if (first == null)
                {
                    if (_end)
                    {
                        misc.log("{0} end requested, waiting 3 s", name);
                        DateTime now = DateTime.Now;
                        while (DateTime.Now < now.AddSeconds(3))
                        {
                            if (first != null)
                            {
                                misc.log("{0} un retardataire, on continue à dépiler", name);
                                break;
                            }
                        }
                        if (first == null)
                        {
                            misc.log("{0} fin du dépilage ", name);
                            return;
                        }
                    }
                    else
                        continue; 
                }
                   



                IBgtask task = null;
                lock (_lock)
                {
                    if (first == null)
                        continue;

                    task = first.task;
                    first = first.Next;
                    if (first == null)
                        last = null;
                }

                task.exec();
               

                if (task.Abort)
                {
                    misc.log("{0} tâche interrompue ", name);
                    return; 
                }

                if (!task.Success)
                {
                    task.Try++;
                    add(task);
                }
                    


            }
        }

       
        private class LinkedTask
        {
            public readonly IBgtask task;
            public LinkedTask Next;
            public LinkedTask(IBgtask task) { this.task = task; }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Copie de pdb.obj.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.obj</RootNamespace>
    <AssemblyName>pdb.obj</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CPlayList.cs" />
    <Compile Include="CPlayListComparer.cs" />
    <Compile Include="DictRef.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="IBgTask.cs" />
    <Compile Include="ILoader.cs" />
    <Compile Include="Interfaces.cs" />
    <Compile Include="TrackIdentity.cs" />
    <Compile Include="TrackPlayListManager.cs" />
    <Compile Include="PlComponent.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.obj\CUtil.cs">
    <content><![CDATA[using System;
using System.IO;
namespace pdb.util
{
    public static class CUtil
    {

        /// <summary>
        /// Compararaison sans tenir compe de la casse +  Trim
        /// </summary>
        /// <param name="a_str"></param>
        /// <param name="b_str"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool EqualsNoCase(string a_str, string b_str)
        {
            return a_str.Equals(b_str, StringComparison.InvariantCultureIgnoreCase);
        }

        /// <summary>
        /// Compararaison sans tenir compe de la casse +  Trim
        /// </summary>
        /// <param name="a_str"></param>
        /// <param name="b_str"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool diff(string a_str, string b_str)
        {
            return !a_str.Trim().Equals(b_str.Trim(), StringComparison.InvariantCultureIgnoreCase);
        }


        /// <summary>
        /// Différence caractérisée
        /// On ne fait pas la comparaison quand l'une des valeurs n'est pas définie
        /// </summary>
        /// <param name="a_str"></param>
        /// <param name="b_str"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool DefinedDiff(string a_str, string b_str)
        {
            if (string.IsNullOrEmpty(a_str) || string.IsNullOrEmpty(b_str))
                return false;
            return diff(a_str, b_str);
        }

        /// <summary>
        /// Différence caractérisée
        /// On ne fait pas la comparaison quand l'une des valeurs n'est pas définie
        /// </summary>
        /// <param name="a_nb"></param>
        /// <param name="b_nb"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool DefinedDiff(int a_nb, int b_nb)
        {
            if (a_nb == -1 || b_nb == -1)
                return false;
            return a_nb != b_nb;
        }


        /// <summary>
        /// Différence caractérisée
        /// On ne fait pas la comparaison quand l'une des valeurs n'est pas définie
        /// </summary>
        /// <param name="a_str"></param>
        /// <param name="b_str"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public static bool DefinedEquals(this string a_str, string b_str)
        {
            if (string.IsNullOrEmpty(a_str) || string.IsNullOrEmpty(b_str))
                return false;
            return EqualsNoCase(a_str, b_str);
        }
        public static bool DefinedEquals(this int a_nb, int b_nb)
        {
            if (a_nb == -1 || b_nb == -1)
                return false;
            return a_nb == b_nb;
        }

        public static string getSovPath(string a_base, string a_file, int a_i)
        {
            string l_stri = "";
            if (a_i > 0)
                l_stri = "_" + a_i.ToString();
            return a_base + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension(a_file) + l_stri + Path.GetExtension(a_file);
        }

        /// <summary>
        /// déterminer si une chaine ne contient que du numérique
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public static bool isInteger(this String name)
        {
            if (String.IsNullOrEmpty(name))
                return false;
            for (int i = 0; i < name.Length; i++)
            {
                char l_xChar = name[i];

                int l_x = Convert.ToInt16(l_xChar);

                if (!char.IsDigit(l_xChar))
                {
                    return false;
                }
            }
            return true;

        }
        /// <summary>
        /// récupérer les valeurs entières d'une chaine de caractère composée exclusivement de chiffres
        /// </summary>
        /// <param name="name"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public static int getInt(this String name, int index)
        {
            char[] cha = name.ToCharArray();
            if (index < name.Length)
            {
                if (Char.IsDigit(cha[index]))
                return int.Parse(cha[index].ToString());
                return -1;
            }
            return 0;
        }

        public static String TrimSafe(this String str)
        {
            if (str == null) return "";
            return str.Trim();
        }

        public static bool DefinedEquals(String artist, String album, String name, int trackNumber, String oartist, String oalbum, String oname, int otrackNumber)
        {
            if (!DefinedEquals(artist, oartist))
                return false;
            if (!DefinedEquals(album, oalbum))
                return false;
            if (!DefinedEquals(name, oname))
                return false;
            if (!DefinedEquals(trackNumber, otrackNumber))
                return false;
            return true;
        }

        public static bool isNullorEmpty(this String str)
        {
            if (str == null) return true;
            return (str.Trim().Length == 0); 
        }
        public static bool NotNullOrEmpty(this String str)
        {
            return !String.IsNullOrEmpty(str);
        }

    }
}



]]></content>
  </file>
  <file path="\PieceDb.obj\Dict.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Collections;
using System; 

namespace pdb.obj
{
    public class Dict<K, V> where V : class
    {
        private Dictionary<K, V> dict = new Dictionary<K, V>();
        private volatile object _lock = new object();
        public Dict()
        {
        }

        public bool ContainsKey(K key)
        {
            return dict.ContainsKey(key);
        }

        public V this[K ID]
        {
            get
            {

                if (!dict.ContainsKey(ID))
                    return null;
                return dict[ID];
            }
            set
            {
                if (value == null)
                    throw new ArgumentException("pas de clé nulle"); 

                if (dict.ContainsKey(ID))
                    dict[ID] = value;
                else
                    dict.Add(ID, value);

            }
        }


        public void Clear()
        {
            dict.Clear();
        }

        public bool Remove(K key)
        {
            return dict.Remove(key);
        }

        public IEnumerator GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }
        public System.Collections.Generic.IEnumerator<V> GetEnumerator1()
        {
            return dict.Values.GetEnumerator();
        }

        public int Count { get { return dict.Values.Count; } }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\DictRef.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.util;

namespace pdb.obj
{
    public class DictRef<T> where T : class,  ITrackIdentity
    {
        private Dict<string, T> htId = new Dict<string, T>();
        private Dict<string, T> htLocation = new Dict<string, T>();
        private Dict<string, T> htTri = new Dict<string, T>();
        private Dict<string, T> htComplet = new Dict<string, T>();
        private List<T> list = new List<T>();

        public T this[TrackIdentity key]
        {
            get
            {
                string _key = key.Key;
                var level = key.Level;
                if (level == identiyComplet.none) throw new ApplicationException();

                T piece = null;

                //on regarde id
                if (level == identiyComplet.id)
                    piece = htId[key.getKey(identiyComplet.id)];
                if (piece != null)
                    return piece; 
                // on regarde info complete
                if (level == identiyComplet.quadri)
                    piece = htComplet[key.getKey(identiyComplet.quadri)];

                if (piece == null)
                {
                    // o regarde info partielle
                    if (level >= identiyComplet.tri)
                        piece = htTri[key.getKey(identiyComplet.tri)];

                    if (piece == null)
                    {
                        if (level >= identiyComplet.file)
                            piece = htLocation[key.getKey(identiyComplet.file)];
                        if (piece == null)
                        {
                            if (level >= identiyComplet.id)
                                piece = htId[key.getKey(identiyComplet.id)];
                            if (piece == null)
                                return null; 
                        }

                        // ici on a trouvé avec la loc
                        if (level > identiyComplet.file && piece.Key.Level > identiyComplet.file)
                            return null;
                        return piece;
                    }

                    // ici on a trouvé sans le numéro de piste
                    if (level >= identiyComplet.quadri)
                    {
                        var keyFound = piece.Key;
                        // si la piece trouvée a un numéro de piste différent (mêmes album, artiste et nom exemple : Lecture Bashung); 
                        // ce n'est pas le même
                        if (keyFound.Level == level)
                            return null;
                    }


                }

                return piece;

                //switch (level)
                //{

                //    case identiyComplet.file: piece = htLocation[key.getKey(identiyComplet.file)]; break;
                //    case identiyComplet.tri: piece = htTri[key.getKey(identiyComplet.tri)]; break;
                //    case identiyComplet.quadri: piece = htComplet[key.getKey(identiyComplet.quadri)];
                //    default: throw new ApplicationException();
                //}

            } 

        }


        public T Try(TrackIdentity key)
        {
          
                string _key = key.Key;
                var level = key.Level;
                if (level == identiyComplet.none) throw new ApplicationException();

                T piece = null;

                //on regarde id
                if (level == identiyComplet.id)
                    piece = htId[key.getKey(identiyComplet.id)];
                if (piece != null)
                    return piece;
                // on regarde info complete
                if (level >= identiyComplet.quadri)
                    piece = htComplet[key.getKey(identiyComplet.quadri)];

                if (piece == null)
                {
                    // o regarde info partielle
                    if (level >= identiyComplet.tri)
                        piece = htTri[key.getKey(identiyComplet.tri)];

                    if (piece == null)
                    {
                        if (level >= identiyComplet.file)
                            piece = htLocation[key.getKey(identiyComplet.file)];
                        if (piece == null)
                        {
                            if (level >= identiyComplet.id)
                                piece = htId[key.getKey(identiyComplet.id)];
                            if (piece == null)
                                return null;
                        }

                        // ici on a trouvé avec la loc
                        if (level > identiyComplet.file && piece.Key.Level > identiyComplet.file)
                            return null;
                        return piece;
                    }

                    // ici on a trouvé sans le numéro de piste
                    if (level >= identiyComplet.quadri)
                    {
                        var keyFound = piece.Key;
                        // si la piece trouvée a un numéro de piste différent (mêmes album, artiste et nom exemple : Lecture Bashung); 
                        // ce n'est pas le même
                        if (keyFound.Level == level)
                            return null;
                    }


                }

                return piece;

                //switch (level)
                //{

                //    case identiyComplet.file: piece = htLocation[key.getKey(identiyComplet.file)]; break;
                //    case identiyComplet.tri: piece = htTri[key.getKey(identiyComplet.tri)]; break;
                //    case identiyComplet.quadri: piece = htComplet[key.getKey(identiyComplet.quadri)];
                //    default: throw new ApplicationException();
                //}

           

        }


        public T TryWithoutId(TrackIdentity key)
        {

            string _key = key.Key;
            var level = key.Level;
            if (level == identiyComplet.none) throw new ApplicationException();

            T piece = null;

            //on regarde id
        
          
            // on regarde info complete
            if (level >= identiyComplet.quadri)
                piece = htComplet[key.getKey(identiyComplet.quadri)];

            if (piece == null)
            {
                // o regarde info partielle
                if (level >= identiyComplet.tri)
                    piece = htTri[key.getKey(identiyComplet.tri)];

                if (piece == null)
                {
                    if (level >= identiyComplet.file)
                        piece = htLocation[key.getKey(identiyComplet.file)];
                    if (piece == null)
                    {
                        return null; 
                    }

                    // ici on a trouvé avec la loc
                    if (level > identiyComplet.file && piece.Key.Level > identiyComplet.file)
                        return null;
                    return piece;
                }

                // ici on a trouvé sans le numéro de piste
                if (level >= identiyComplet.quadri)
                {
                    var keyFound = piece.Key;
                    // si la piece trouvée a un numéro de piste différent (mêmes album, artiste et nom exemple : Lecture Bashung); 
                    // ce n'est pas le même
                    if (keyFound.Level == level)
                        return null;
                }


            }

            return piece;

            //switch (level)
            //{

            //    case identiyComplet.file: piece = htLocation[key.getKey(identiyComplet.file)]; break;
            //    case identiyComplet.tri: piece = htTri[key.getKey(identiyComplet.tri)]; break;
            //    case identiyComplet.quadri: piece = htComplet[key.getKey(identiyComplet.quadri)];
            //    default: throw new ApplicationException();
            //}



        }


        public void set(T piece, TrackIdentity key)
        {
            var level = key.Level;
            string strId = key.getKey(identiyComplet.id); 
            if (!string.IsNullOrEmpty(strId))
                htId[strId] = piece; 
            if (level >= identiyComplet.file)
                htLocation[key.getKey(identiyComplet.file)] = piece;
            if (level >= identiyComplet.tri)
                htTri[key.getKey(identiyComplet.tri)] = piece;
            if (level >= identiyComplet.quadri)
                htComplet[key.getKey(identiyComplet.quadri)] = piece;
            list.Add(piece); 
        }

        public bool Remove(T piece)
        {
            var key = piece.Key;
            bool remove1 = htComplet.Remove(key.getKey(identiyComplet.quadri));
            bool remove2 = htTri.Remove(key.getKey(identiyComplet.tri));
            bool remove3 = htLocation.Remove(key.getKey(identiyComplet.file));
            bool ret = remove1 || remove2 || remove3;
            if (ret)
                list.Remove(piece);
            return ret;
        }

        public IEnumerator GetEnumerator()
        {
            return list.GetEnumerator();
        }
        public IEnumerator<T> GetEnumerator1()
        {
            return list.GetEnumerator();
        }

        public int Count { get { return list.Count; } }

        //public T find(string location)
        //{
        //    return htLocation[TrackIdentity.getKeyLocation(location)];
        //}


    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\ILoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{
    public interface ILoader
    {

       // /// <summary>
       // /// Ajout d'une playlist à partir dune liste de fichiers
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // /// <param name="list"></param>
       // void addList(PlayListComposite folder, String name, ICollection<IFile> list);
        /// <summary>
        /// création d'une piste native
        /// </summary>
        /// <param name="piece"></param>
        ITrackInfoItunes createLegacyTrack(ITrackNative piece);
       // /// <summary>
       // /// Chemin du fichier de base de données
       // /// </summary>
       // string DbPath { get; }
       // /// <summary>
        /// réépertoire principal où est stockée la musique
        /// </summary>
        string DefaultFolder { get; }
       // /// <summary>
       // /// Suppression d'une piste de PlayList ( sans suppression de la base ) 
       // /// </summary>
       // /// <param name="trackList"></param>
       //// void deleteTrackInList(PieceInAList trackList);
       // /// <summary>
       // /// Récupération de la playlist associée à la playlist native
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // /// <returns></returns>
       // CPlayList getList(PlayListComposite folder, string name);
       // /// <summary>
       // /// récupération ou création du dossier de playlists
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <returns></returns>
       // PlayListComposite getOrCreateFolder(string folder);
       // /// <summary>
       // /// Liste des pistes
       // /// </summary>
       // IEnumerable<ITrackInfoItunes> ListTracks { get; }
        /// <summary>
        /// Chargement des listes
        /// </summary>
        void loadLists();
        /// <summary>
        /// Chargement des pises
        /// </summary>
        void loadTracks(List<ITrackInfoItunes> list);

       // PlayListComposite TreePlayList { get; }

       // /// <summary>
       // /// Suppression dune liste native
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // void removeList(PlayListComposite folder, string name);
        /// <summary>
        /// placement d'une piste en rapport avec son classement
        /// </summary>
        /// <param name="piece"></param>
        /// <param name="listName"></param>
        void setClassPlayList(ITrackMetaData piece, string listName);

        void deleteTrack(String location);

        ITrackInfoItunes createTrack(int id,String location);

        void checkDetect(DateTime ini); 

    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\ILogger.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util
{
    public interface ILogger
    {
        void log(string txt, params object[] other);
        void logNoDate(String txt, params object[] other);
    }

    public class DefaultLogger : ILogger
    {

        #region ILogger Membres

        public void log(string txt, params object[] other)
        {
            Console.WriteLine(DateTime.Now + " " + txt, other); 
        }

        public void logNoDate(string txt, params object[] other)
        {
            Console.WriteLine(txt, other); 
        }

        #endregion
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\misc.cs">
    <content><![CDATA[using System;
using System.IO;

namespace pdb.util
{
    /// <summary>
    /// utilitaires divers
    /// </summary>
    /// <remarks></remarks>
    public static class misc
    {
        private static ILogger logger = new DefaultLogger(); 
        public static void init (ILogger a_logger) {logger = a_logger ;}


        public static void logNoDate(String txt)
        {
            logger.logNoDate(txt); 
        }
        
        public static void log(string txt, params object[] other)
        {
            logger.log(txt, other); 
        }

        public static void moveTree(this FileInfo org, String dest)
        {
            String[] dirs = dest.Split(Path.DirectorySeparatorChar);

            int i= 0 ;
            DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar); 
            for ( i = 1; i < dirs.GetLength(0) -1 ; i++)
            {
                String strDir0 = dirs[i] + Path.DirectorySeparatorChar; 
                String StrDir = root.FullName + strDir0;
                DirectoryInfo dir = new DirectoryInfo(StrDir);
                if (!dir.Exists)
                    dir.Create();
                root = dir;
            }
            object o;

            FileInfo orgg = new FileInfo(org.FullName);
            org.CopyTo(dest, true);
            org.Delete(); 
            DirectoryInfo current = orgg.Directory; 

            while(current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                current.Delete();
                current = parent; 
            }

        }


    }
}]]></content>
  </file>
</db>
