<db path="C:\Bernard\db1\PieceDb3Ref">
    <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;

namespace pdb.player.ViewModel.Commande.PlayList
{
    public enum compressState
    {
        none,
        record,
        enCours,
        end,
        reload,
        cancel
    }
    class ExportCmd : CommandeBase
    {
        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
       // protected static string dir;
        static PlayListViewModel lastpl;
        protected static List<PiecePrior> presents;
        protected static Dict<int, PiecePrior> dict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();

        protected static Dictionary<int, object> ids;
        protected static Dict<int, PiecePrior> idCopie;
        protected static BgDictString<PiecePrior> idCopieLoc; 
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";

        protected static compressState state;
        public static void CalculExport()
        {
            switch (state)
            {
                case compressState.none:
                    break;
                case compressState.record:
                    break;
                case compressState.enCours:
                    state = compressState.reload;
                    break;
                case compressState.end:
                    state = compressState.reload;
                    break;
                case compressState.reload:
                    break;
                case compressState.cancel:
                    break;
                default:
                    break;
            }
        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly CPiece Piece;
            public PiecePrior(CPiece piece, int prior)
            {
                this.Piece = piece;
                this.prior0 = prior;
            }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            public int MasterId { get { return Piece.MasterId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public override string ToString()
            {
                return "p=" + prior0 + " " + prior1 + " " + Piece.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (state <= compressState.record)
                record();
            else
                state = compressState.cancel;
            OnPropertyChanged("Header");
        }

        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {
            bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
            bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;
            var list = new List<PiecePrior>();
            var ids = new Dictionary<int, object>();
            int i = 0;
            var tracks = new List<TrackListViewModel>(pl.ExportTracks);
            int lastI = 0;
            string lastAlbum = "";
            int nbByAlbum = int.MaxValue;
            if (conf.modeAlbum)
                nbByAlbum = conf.nbMax;
            int nbLot = 0;
            while (true)
            {
                int nbInThisAlbum = 0;
                foreach (TrackListViewModel track in tracks)
                {
                    if (!onlyEnabled || track.Enabled)
                    {
                        CPiece piece = track.Piece;
                        if (piece.Exists)
                        {
                            int id = piece.MasterId;
                            if (ids.ContainsKey(id))
                                continue;
                            if (!_modeAlbum)
                            {
                                if (piece.Album == lastAlbum)
                                {
                                    if (track.Enabled)
                                    {
                                        nbInThisAlbum++;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                }
                                else
                                {
                                    nbInThisAlbum = 1;
                                    lastAlbum = piece.Album;
                                    nbLot++;
                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                    }
                                }
                                var pp = dict[id]; // list.Add(piece);
                                pp.setPrior(i);
                                list.Add(pp);
                                ids.Add(id, pp);
                                i++;

                            }
                            else
                            {
                                if (conf.modeAlbum)
                                {
                                    if (piece.Album == lastAlbum)
                                        continue;
                                    else
                                    {
                                        nbLot++;
                                        if (nbLot > conf.lot)
                                        {
                                            nbLot = 0;
                                            nbByAlbum--;
                                            if (nbByAlbum < conf.nbMin)
                                                nbByAlbum = conf.nbMin;
                                        }
                                    }
                                }

                                var album = App.gen.getTracksAlbumByNumber(piece);
                                if (album != null)
                                {
                                    nbInThisAlbum = 0;
                                    lastAlbum = piece.Album;
                                    foreach (var p in album)
                                    {
                                        CPiece pp = p.Track as CPiece;
                                        if (pp.Exists)
                                        {
                                            if (!onlyEnabled || pp.Enabled)
                                            {
                                                id = pp.MasterId;

                                                if (ids.ContainsKey(id))
                                                    continue;
                                                var ppp = dict[id];
                                                ppp.setPrior(i);
                                                list.Add(ppp);
                                                ids.Add(id, ppp);
                                                i++;
                                                if (pp.Enabled)
                                                {
                                                    nbInThisAlbum++;
                                                    if (nbInThisAlbum >= nbByAlbum)
                                                        break;
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
                if (!modeAlbum)
                    break;
                if (nbByAlbum == int.MaxValue)
                    break;
                if (i == lastI)
                    break;

                lastI = i;
                lastAlbum = "";
               
                if (conf.resetAfterLoop)
                    nbByAlbum = conf.nbMax;
            }
            listes.Add(list);
            //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
            OnPropertyChanged("Header");
            return list;
        }

        public override string Header
        {
            get
            {
                if (state > compressState.record)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (state == compressState.none)
            {
                state = compressState.record;
                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

              //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    state = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                listes = null;
                playlists.Clear();
                state = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            state = compressState.enCours;
            OnPropertyChanged("Header");

            var th = new Thread(export__);
            th.SetApartmentState(ApartmentState.STA);
            th.Start();
        }

        private void buildListIni()
        {

            listes = new List<List<PiecePrior>>();
            presents = new List<PiecePrior>();
            dict = new Dict<int, PiecePrior>();


            if (!conf.dir.EndsWith("\\"))
                conf.dir += "\\";

            List<Piece> l = null;


            if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
            {
                l = App.gen.sortByAlbum();
                l.Reverse();
            }
            else
                l = App.gen.sortByClass();
            // l.Reverse();

            int i = 0;
            foreach (Piece p in l)
            {
                var piece = p.Track as CPiece;
                if (!dict.ContainsKey(piece.MasterId))
                {
                    var pp = new PiecePrior(piece, i);
                    i++;
                    presents.Add(pp);
                    dict[piece.MasterId] = pp;
                }
            }

        }

        [STAThread]
        private void export__()
        {


            while (true)
            {
                switch (state)
                {
                    case compressState.none:
                        return;
                    case compressState.enCours:
                        break;
                    case compressState.end: Thread.Sleep(1000); continue;
                    case compressState.reload:
                        break;
                    case compressState.cancel:
                        {
                            state = compressState.none;
                            nbLoop = 0;
                            return;
                        }

                    default:
                        break;
                }
                state = compressState.enCours;
                nbLoop++;

                buildListIni();

                foreach (PlayListViewModel pl in playlists)
                {
                    buildList(pl);
                }

                // concaténation
                int max = 0;
                list = new List<PiecePrior>();
                foreach (var _l in listes)
                {
                    var count_ = _l.Count;
                    if (count_ > max)
                        max = count_;
                }
                int count = listes.Count;
                ids = new Dictionary<int, object>();


                for (int i = 0; i < max; i++)
                {
                    for (int j = 0; j < count; j++)
                    {
                        var l = listes[j];
                        if (i < l.Count)
                        {
                            var p = l[i];
                            int id = p.MasterId;
                            if (!ids.ContainsKey(id))
                            {
                                ids.Add(id, p);
                                list.Add(p);
                            }
                        }
                    }
                }






                App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                _export();

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        private void _export()
        {

            try
            {

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new Dict<int, PiecePrior>(); idCopieLoc = new BgDictString<PiecePrior>(); 
                presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;

                        int id = piece.MasterId;
                        if (idCopie.ContainsKey(id))
                            continue;
                        var files = piece.Piece.Files;
                        bool contFile = false; 
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.ContainsKey(file.File))
                            {
                                contFile = true;
                                break; 
                            }
                        }
                        if (contFile)
                            continue; 

                        idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc[file.File] = piece;                             
                        }


                       

                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    exists = true;
                                    break;
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                            continue;

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                FileInfo f = new FileInfo(pertinent.Path);
                                App.log.log(piece.Piece.DurationInSec + "s\tcopie vers " + conf.dir + pertinent.File + " ( " + piece + " )");
                                f.copyTree(conf.dir + pertinent.File, null);
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            finally
            {
                App.log.log(string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : "")), CAPTION);
                //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                list = null;
                listes = null;

                if (state == compressState.enCours)
                    state = compressState.end;
                OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <DataGrid  Grid.Column="0" DockPanel.Dock="Bottom" 
                       Name="dg" 
                       AutoGenerateColumns="False" 
                       ScrollViewer.CanContentScroll="True" 
                       SelectedItem="{Binding SelectedTrackInAlbumView}">

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>

            <DataGrid.Columns>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />
                <DataGridTextColumn Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>

            </DataGrid.Columns>

        </DataGrid>

    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.player.ViewModel;
using System.ComponentModel;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for AlbumCtl.xaml
    /// </summary>
    public partial class AlbumCtl : UserControl, ItrackProvider
    {

        private DetailAlbumViewModel model;
        public AlbumCtl()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(AlbumCtl_Loaded);
        }

        void AlbumCtl_Loaded(object sender, RoutedEventArgs e)
        {
            this.model = new DetailAlbumViewModel();
            init();
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentHumanSelectedChanged);

        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            init();
        }

        private void init()
        {
            SortDescriptionCollection sort = null;
            ICollectionView view = null;

            view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
            if (view != null)
                sort = view.SortDescriptions;

            List<SortDescription> _sort = null;
            if (sort != null)
                _sort = new List<SortDescription>(sort);
            base.DataContext = null;

            dg.ItemsSource = null;
            object sel;
            if (dg.Items.Count > 0)
            {
                sel = dg.SelectedItem;
            }
            var alb = model.Album;
            dg.ItemsSource = alb;
            base.DataContext = model;

            view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

            if (_sort != null && _sort.Count > 0)
            {
                view.SortDescriptions.Clear();
                foreach (var _s in _sort)
                {
                    view.SortDescriptions.Add(_s);
                    foreach (DataGridColumn _c in dg.Columns)
                    {
                        if (_s.PropertyName == _c.SortMemberPath)
                        {
                            _c.SortDirection = _s.Direction;
                            break;
                        }
                    }
                    break;

                }
            }
            //dgStat.ItemsSource = null;

            //var stats = model.Stats;
            //dgStat.DataContext = null;
            //dgStat.DataContext = stats.DefaultView;
            //dgStat.ItemsSource = stats.DefaultView;


            //base.DataContext = model;
        }




        private void dgAlbum_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            PlayerViewModel.reset(this, t);
        }

        public System.ComponentModel.ICollectionView PresentationTracks
        {
            get { return CollectionViewSource.GetDefaultView(dg.ItemsSource); }
        }

        public PlayListViewModel PlayList
        {
            get { return null; }
        }

        public void Focus(int index)
        {

        }

        public void doFilter(string filter)
        {

        }


        public List<TrackListViewModel> SelectedTracks
        {
            get
            {
                var list = new List<TrackListViewModel>();
                foreach (TrackListViewModel track in PresentationTracks)
                    list.Add(track);
                return list;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ClassementCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.player.ViewModel;
using pdb.gen.stat;
using pdb.player.Vue.Adorn;
using System.ComponentModel;
using pdb.gen;
using System.Text.RegularExpressions;

namespace pdb.player.Vue
{
    public class TB : UIElement
    {
        private Border border;
        private TextBlock tb;
        public TB()
        {
            border = new Border();
            border.BorderThickness = new Thickness(0.3);
            border.BorderBrush = Brushes.Gray;

            tb = new TextBlock();
            tb.TextAlignment = TextAlignment.Center;
            border.Child = tb;
            tb.FontSize = 10;
            tb.HorizontalAlignment = HorizontalAlignment.Stretch;
            tb.Visibility = System.Windows.Visibility.Visible;
        }

        public Brush Background { set { tb.Background = value; } }
        public string Content { set { tb.Text = value; } }

        protected override bool IsEnabledCore
        {
            get
            {
                return true;
            }
        }




    }


    /// <summary>
    /// Interaction logic for ClassementCtl.xaml
    /// </summary>
    public partial class ClassementCtl : UserControl
    {



        private DetailClassementViewModel model;
        private StatCtl[,] tbs = new StatCtl[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        private Border[,] borders = new Border[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        public ClassementCtl()
        {

            InitializeComponent();
            TbClass.PreviewTextInput += new TextCompositionEventHandler(TbClass_PreviewTextInput);

            for (int i = -DynamicStatLigne.SEMI_COLS; i <= DynamicStatLigne.SEMI_COLS; i++)
            {
                var col = new ColumnDefinition();
                col.Width = new GridLength(1, GridUnitType.Star);
                tab.ColumnDefinitions.Add(col);
            }

            for (int j = 0; j <= DynamicStat.ROWS; j++)
            {
                var row = new RowDefinition();
                row.Height = new GridLength(1, GridUnitType.Star);
                tab.RowDefinitions.Add(row);
            }

            for (int c = 0; c < DynamicStatLigne.COLS; c++)
            {
                var border = new Border();
                border.BorderThickness = new Thickness(0.3);
                border.BorderBrush = Brushes.Gray;
                border.Background = Brushes.LightGray;
                border.VerticalAlignment = System.Windows.VerticalAlignment.Center;
                border.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                border.ClipToBounds = true;
                var tb = new TextBlock();
                tb.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                tb.Background = Brushes.LightGray;
                tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                tb.TextAlignment = TextAlignment.Center;
                border.Child = tb;
                tab.Children.Add(border);
                Grid.SetRow(border, 0);
                Grid.SetColumn(border, c);
            }


            for (int r = 1; r <= DynamicStat.ROWS; r++)
            {
                for (int c = 0; c < DynamicStatLigne.COLS; c++)
                {
                    var tb = new StatCtl();
                    //var border = new Border();
                    //border.BorderThickness = new Thickness(0.3);
                    //border.BorderBrush = Brushes.Gray;

                    //border.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                    ////var tb = new TextBlock();
                    ////tb.TextAlignment = TextAlignment.Center;

                    //////tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    ////tb.VerticalAlignment = System.Windows.VerticalAlignment.Center;
                    ////tb.FontSize = 10;


                    //border.Child = tb;
                    //    border.ClipToBounds = true;
                    tbs[r, c] = tb;
                    // borders[r, c] = border;


                    // AdornedControl ac = new AdornedControl(); 

                    // tb.BorderThickness = new Thickness(0.2) ;
                    // tb.BorderBrush = Brushes.Gray;
                    // tb.FontSize = 10;


                    tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    tb.Margin = new Thickness(0);
                    tb.Padding = new Thickness(0);

                    //tab.Children.Add(border);

                    //Grid.SetRow(border, r);
                    //Grid.SetColumn(border, c);

                    tab.Children.Add(tb);
                    Grid.SetRow(tb, r);
                    Grid.SetColumn(tb, c);

                    //if (r == 0)
                    //{
                    //    tb.Background = Brushes.LightGray;
                    //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                    //}


                    if (c == DynamicStatLigne.SEMI_COLS || r == 3)
                        tb.FontWeight = FontWeights.Bold;
                }
            }




            this.Loaded += new RoutedEventHandler(ClassementCtl_Loaded);
        }
        Regex regex = new Regex(@"[0-5.\ ]+");
        void TbClass_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            var text = e.Text;
            if (!string.IsNullOrEmpty(text))
            {
                //regex that matches disallowed text
                if (!regex.IsMatch(text))
                    e.Handled = true;
            }

        }

        void ClassementCtl_Loaded(object sender, RoutedEventArgs e)
        {
            this.classProvider = new Provider(dg);
            // this.albumProvider = new Provider(dgAlbum); 
            this.model = new DetailClassementViewModel();
            model.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(model_PropertyChanged);
            model.Classement = "";
            init();
        }

        void model_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            init();
        }

        private class CPieceComparerByQualityAndLength2 : IComparer<TrackListViewModel>
        {
            int IComparer<TrackListViewModel>.Compare(TrackListViewModel x, TrackListViewModel y)
            {
                return -x.Track.Piece.Rank.Twice.CompareTo(y.Track.Piece.Rank.Twice);
            }
        }

        private void init()
        {
            SortDescriptionCollection sort = null;
            ICollectionView view = null;

            view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
            if (view != null)
                sort = view.SortDescriptions;

            List<SortDescription> _sort = null;
            if (sort != null)
                _sort = new List<SortDescription>(sort);



            base.DataContext = null;
            try
            {

                dg.ItemsSource = null;
                var tracks = model.Tracks;

                if (tracks == null)
                    return;
                tracks.Sort(new CPieceComparerByQualityAndLength2());
                dg.ItemsSource = tracks;

                //ICollectionView source = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                //if (source != null)
                //{
                //    if (source.SortDescriptions != null)
                //        source.SortDescriptions.Clear();
                //    source.SortDescriptions.Add(new SortDescription("Classement", ListSortDirection.Descending));
                //}
                tracks.init();
                //dgAlbum.ItemsSource = null;
                //object sel; 
                //if (dgAlbum.Items.Count > 0)
                //{
                //    sel = dgAlbum.SelectedItem; 
                //}
                //dgAlbum.ItemsSource = model.Album;
                //dgStat.ItemsSource = null;

                //var stats = model.Stats;
                //dgStat.DataContext = null; 
                //dgStat.DataContext = stats.DefaultView;
                //dgStat.ItemsSource = stats.DefaultView; 

                var stats = model.getStats();
                if (stats == null)
                    return;

                //for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                //{
                //    var tb = tbs[0, c + DynamicStatLigne.SEMI_COLS];
                //    tb.Background = Brushes.LightGray;
                //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                //    tb.InvalidateVisual();
                //}

                for (int r = 1; r <= DynamicStat.ROWS; r++)
                {
                    int max = 0;
                    for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                    {
                        int nb = stats[r - 1][c];
                        if (nb > max)
                            max = nb;
                    }
                    for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                    {
                        try
                        {
                            //  var row = stats.Rows[r-1][c.ToString()]; 
                            int nb = stats[r - 1][c];
                            var tb = tbs[r, c + DynamicStatLigne.SEMI_COLS];
                            if (nb > 0)
                                tb.Text = nb.ToString();
                            else
                                tb.Text = "";
                            tb.setValue(nb, max);
                            tb.InvalidateVisual();
                            //var b = borders[r, c + DynamicStatLigne.SEMI_COLS];
                            //var layer = AdornerLayer.GetAdornerLayer(b);
                            //try { layer.Remove((layer.GetAdorners(b))[0]); }
                            //catch { }
                            //layer.Add(new BarAdorner(b, nb, max));


                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }


                        // tbs[r, c + DynamicStatLigne.SEMI_COLS].Text = stats.Rows[r - 1][c.ToString()].ToString(); 
                    }
                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());
            }
            finally
            {
                base.DataContext = model;
                view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

                if (_sort != null && _sort.Count > 0)
                {
                    view.SortDescriptions.Clear();
                    foreach (var _s in _sort)
                    {
                        view.SortDescriptions.Add(_s);
                        foreach (DataGridColumn _c in dg.Columns)
                        {
                            if (_s.PropertyName == _c.SortMemberPath)
                            {
                                _c.SortDirection = _s.Direction;
                                break;
                            }
                        }
                        break;

                    }
                }
            }
        }

        private void btRecord_Click(object sender, RoutedEventArgs e)
        {
            model.record();

        }

        private ItrackProvider classProvider;
        private ItrackProvider albumProvider;

        private void dgMouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            PlayerViewModel.reset(classProvider, t);
        }

        private void dgAlbum_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            PlayerViewModel.reset(albumProvider, t);
        }

        private class Provider : ItrackProvider
        {
            private DataGrid dt;
            public Provider(DataGrid dt)
            {
                this.dt = dt;
            }

            public System.ComponentModel.ICollectionView PresentationTracks
            {
                get { return CollectionViewSource.GetDefaultView(dt.ItemsSource); }
            }

            public PlayListViewModel PlayList
            {
                get { return null; }
            }

            public void Focus(int index)
            {

            }


            public void doFilter(string filter)
            {

            }

            public List<TrackListViewModel> SelectedTracks
            {
                get
                {
                    var list = new List<TrackListViewModel>();
                    foreach (TrackListViewModel track in PresentationTracks)
                        list.Add(track);
                    return list;
                }
            }
        }

        //public System.ComponentModel.ICollectionView PresentationTracks
        //{
        //    get { return CollectionViewSource.GetDefaultView(dgAlbum.ItemsSource); }
        //}

        public PlayListViewModel PlayList
        {
            get { return null; }
        }

        public void Focus(int index)
        {

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <DataGrid Grid.Row="0" Name="dg" AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False" 
                  SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"              
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
            
          
            <DataGrid.Columns>
                

                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}"/>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}"/>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" >
                    <DataGridCheckBoxColumn.ElementStyle>
                        <Style TargetType="CheckBox">
                            <Style.Triggers>
                                
                            </Style.Triggers>
                        </Style>
                    </DataGridCheckBoxColumn.ElementStyle>
                </DataGridCheckBoxColumn>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                
               
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay}"/>
               
                
                
               
              


            </DataGrid.Columns>
            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>                      
                    </Style.Triggers>                    
                </Style>
            </DataGrid.ItemContainerStyle>
        </DataGrid>
        <DockPanel Grid.Row="1" >
            <TextBlock DockPanel.Dock="Bottom" Text="{Binding Resume}"></TextBlock>
        </DockPanel>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private int albumRating;
        private bool ratingComputed;

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            this.albumRating = track.AlbumRating;
            this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed; 

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            if (track.PlayedCount > 0)
            {
                played = markAsPlayed(Rating, PlayedDate);
            }

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment � partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de g�rer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }
        public static bool markAsPlayed(int rating, DateTime date)
        {
            if (maxPlayed.ContainsKey(rating))
                return date > maxPlayed[rating];
            return true;
        }
        public override void build(XmlNode xTrack)
        {
            base.build(xTrack);
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Rating Computed")
                        ratingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break;
                    case "Play Count": int playCount = Convert.ToInt32(value);
                        if (playCount > 0)
                            played = markAsPlayed(Rating, PlayedDate);
                        break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }

            //for (int i = 0; i < xTrack.ChildNodes.Count; i += 2)
            //{
            //    XmlNode xKey = xTrack.ChildNodes[i];
            //    string value = xTrack.ChildNodes[i + 1].InnerText;
            //    string key = xKey.InnerText;

            //    if (string.IsNullOrEmpty(value))
            //        continue;
            //    switch (xKey.InnerText)
            //    {
            //        case "Date Added": added = Convert.ToDateTime(value); break;
            //        case "Release Date": pub = Convert.ToDateTime(value); break;
            //        case "Play Count": int playCount = Convert.ToInt32(value); if (playCount > 0) played = true; break;
            //        case "Album Rating": albumRating = Convert.ToInt32(value); break;


            //    }
            //}


            new PubLoader(this).setPub();

            #region move vers pubLoader
            //
            //string _comment = Comment;
            //DateTime dateComment = DateTime.MinValue;

            //try
            //{
            //    dateComment = Convert.ToDateTime(_comment);
            //}
            //catch
            //{
            //}

            //if ((pub < MIN || pub.DayOfYear == 1)  && (dateComment > MIN && dateComment.DayOfYear > 1))
            //{
            //    pub = dateComment; 
            //}
            //string name = Name;
            //checkDate1(name);
            //checkDate2(name);
            //checkDate3(name);

            //bool pubYear = false;

            //if (!string.IsNullOrEmpty(Location))
            //{
            //    string fileName = Path.GetFileName(Location);
            //    checkDate1(fileName);
            //    checkDate2(fileName);
            //    checkDate3(fileName);
            //}

            //if (pub <= MIN)
            //{
            //    if (Year > 1970)
            //    {
            //        DateTime dtYear = new DateTime(Year, 1, 1);
            //        pub = dtYear;
            //        pubYear = true;
            //    }
            //}



            //if (added < MIN) added = MIN;

            //// DateTime dt_ = pub;
            //if (pub <= MIN)
            //    pub = added;
            //string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            //if (this.Comment != comment)
            //{
            //    try
            //    {
            //        string commentFound = this.Comment;
            //        string truc = commentFound;
            //        if (truc.Contains("_")) 
            //        {
            //            //d�j� fait
            //            return; 
            //        }
            //          //  truc = truc.Split('_')[0];

            //        DateTime iComment = Convert.ToDateTime(truc);
            //        if (iComment.DayOfYear != 1 && pub.DayOfYear == 1)
            //        {
            //            pub = iComment;
            //        }
            //        else
            //        {

            //            this.Comment = comment;
            //        }
            //    }
            //    catch
            //    {
            //        this.Comment = comment;
            //    }
            //}


            //

            #endregion




            duree = new util.timeSpan(Duration);
        }



        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>();
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;
                int volume = Volume;
                if (Album.Contains("RFI"))
                {
                    if (volume != -20)
                        Volume = -20;
                }
                else if (volume < volumeMin)
                    Volume = volumeMin;


                if (pub > MIN)
                {


                    string infoShort = pub.ToString("dd.MM.yy");
                    string infoPubName = pub.ToString("dd.MM.yyyy");
                    string infoPubName2 = pub.ToString("dd/MM/yyyy");
                    string infoPubName3 = pub.ToString("dd/MM/yy");
                    string infoYear = Year.ToString();
                    if (pub.DayOfYear == 1)
                    {
                        infoPubName = pub.Year.ToString();
                        infoPubName2 = infoPubName;
                        infoPubName3 = infoPubName;
                        infoShort = infoPubName;
                    }

                    string name = Name;
                    string str = name;

                    if (regInfoShort.IsMatch(str))
                    {
                        var strdate = regInfoShort.Match(str).Groups[1].Value;
                        str = str.Replace(strdate, "");
                    }






                    if (str.Contains(infoPubName))
                        str = str.Replace(infoPubName, infoShort);
                    else if (name.Contains(infoPubName2))
                        str = str.Replace(infoPubName2, infoShort);

                    else
                    {
                        if (!str.Contains(infoShort))
                        {
                            str = str + " " + infoShort;
                        }
                        else
                        {
                            if (Year > 1980 && str.Contains(infoYear))
                                str = str.Replace(infoYear, "").Trim();
                        }
                    }
                    var strBUG = "30.12.99";
                    if (str.Contains(strBUG))
                        str = str.Replace(strBUG, "");

                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ").Trim();

                    if (!str.Equals(name))
                        Name = str;
                }

            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree { get { return duree; } }


    }
}



]]></content>
  </file>
 
</db>
