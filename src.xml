<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;
using pdb.util.Generic.Parse;
using pdb.util.Generic;
using System.Reflection;

namespace pdb.podcast.DB
{
    class Db
    {
        public const int CURRENT_VERSION = 1;
        const string SEQ_PIECE = "seq";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
     //   private XmlSerializer xmlSerializer;

        public Db()
        {
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};

          
        }


        public void write(string file)
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(file + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                foreach (TrackInfoItunes track in dict.Values)
                {
                    write(writer, track); 
                }
                writer.WriteEndDocument();
                writer.Flush();
            }

            //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
        }

        private static void write(XmlWriter writer, TrackInfoItunes track)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("alb", track.Album);
            writer.WriteAttributeString("name", track.Name);
            writer.WriteAttributeString("pub", track.Pub.ToString());
            writer.WriteAttributeString("date", track.PlayedDate.ToString());
            writer.WriteAttributeString("rating", track.Rating.ToString());
            writer.WriteAttributeString("albumRating", track.AlbumRating.ToString()); 

            if (track.RatingComputed)
                writer.WriteAttributeString("computed", "y"); 
            if (track.Rare)
                writer.WriteAttributeString("rare", "y"); 
            if (track.Info)
                writer.WriteAttributeString("info", "y"); 
            writer.WriteEndElement(); 

        }
        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed
      

        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed
      
        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album


        private static void write(XmlWriter writer, PropertyInfo prop)
        {

        }
      
    }
}
]]></content>
  </file>
 </db>
