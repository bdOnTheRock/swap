<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return piece.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return piece.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                    
                    
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->
                  
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>

                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2"  Visibility="{Binding HasArtWork, Converter={StaticResource boolVis}}">
            <Image Source="{Binding ArtWork}" ></Image>
            <!--<ListView ItemsSource="{Binding Images}">
                <ListView.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <Image Source="{Binding}"  />
                        </StackPanel>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch" VerticalAlignment="Stretch"></StackPanel>
                    </ItemsPanelTemplate>
                </ListView.ItemsPanel>

            </ListView>-->

            <Image Source="{Binding ArtWork}" ></Image>
           
        </Grid>
        <Grid Grid.Row="3">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                
                                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="RankRev" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                    <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>


                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />                        
                    </Style>
                </DataGrid.ItemContainerStyle>
                
                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">                        
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>

       
    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />
                





            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left"  Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }
        public int RankAlbumZero { get { if (album == null) return 0; return album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true;
                    default:
                        return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }

        public string ClassementCompact
        {
            get
            {
#if COMPACT
                if (string.IsNullOrEmpty(_classementCompact))
                    return ClassementCache.strClassement;
                return _classementCompact;
#else 
                return ClassementCache.strClassement; 
#endif
            }
        }
        private static ClassementHash classementHash = new ClassementHash();
        private ClassementCache _classementCache;
        private ClassementCache ClassementCache
        {
            get
            {


                if (_classementCache == null)
                {
                    if (parent != null)
                        _classementCache = parent.ClassementCache;
                    if (_classementCache == null)
                    {
#if COMPACT
                        if (string.IsNullOrEmpty(_classementCompact))
                            _classementCache = classementHash.getCache(track.ClassName, track.Rating);
                        else
                            _classementCache = classementHash.getCache(_classementCompact);
#else
                         _classementCache = classementHash.getCache(track.ClassName, track.Rating);
#endif
                    }
                }
                return _classementCache;
            }
        }

#if COMPACT
        private string _classementCompact;
        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache();
            _classementCompact = classement;
            var _compact = classementHash.getCache(_classementCompact);
            var org = classementHash.getCache(track.ClassName, track.Rating);
            if (org.ClassementValueDecimal < _compact.ClassementValueDecimal)
            {
                _classementCache = org;
                return false;
            }
            else
            {
                _classementCache = _compact;
                return true;
            }
        }


#endif

        public decimal ClassementValueDecimal0
        {
            get
            {
#if COMPACT
                return classementHash.getCache(track.ClassName, track.Rating).ClassementValueDecimal;
#else
                return ClassementValueDecimal;
#endif
            }
        }
        public virtual void invalidateCache()
        {

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //  _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();
            else
            {
                _classementCache = null;
#if COMPACT
                _classementCompact = null;
#endif
                foreach (Piece p in childs)
                {
#if COMPACT
                    p._classementCompact = null;
#endif
                    p._classementCache = null;
                }
            }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        // private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                return ClassementCache.ClassNameAndRating;
            }
        }

        // private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                return ClassementCache.ClassementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

        // private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                return ClassementCache.RapportClassement;
                //if (parent != null)
                //    return parent.RapportClassement;
                //if (_rapportClassement != -1)
                //    return _rapportClassement;

                //decimal resultat = 0;
                //try
                //{
                //    return getRapport(ClassNameAndRating);
                //}
                //catch
                //{
                //}
                //_rapportClassement = resultat;
                //// _classementVirtuel = resultat; 
                //return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + 5)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > 4)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return;
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        public static DateTime SeuilCompact;
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\ClassStruct.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.gen.stat
{
    class ClassStruct
    {
        const int SIX = 6;
        const int NB = 9;
        private int[] tab = new int[NB];
        private int head;

        private int Level { get { return head + 4; } }

        private HashSet<decimal> occupés = new HashSet<decimal>();
        public List<int> getValues()
        {
            var list = new List<int>();
            for (int i = 0; i < Level && i < NB; i++)
                list.Add(tab[i]);
            return list;

        }
        public ClassStruct()
        {
            occupés.Add(0);
        }



        public void init(int head)
        {
            this.head = head;
        }

        public void position()
        {
            // voir si entamé
            //level 4 1.324.5 ==> level 2 1.4
           //  this.level = newLevel;
            bool hasMoved = false;
            for (int i = Level - 1; i < NB; i++)
            {
                if (tab[i] > 0)
                {
                    tab[i] = 0;
                    hasMoved = true;
                }
            }

            if (hasMoved)
            {
                //level 4 1.324.5 ==> level 2 1.4
                increment(this.Level - 1);
            }
            //else
            //    increment(newLevel); 

            //if (this.level != newLevel)
            //{
            //    int toto = 0; 
            //}


        }

        public bool isOccupe(decimal base10)
        {
            return occupés.Contains(base10);
        }
        public bool isOccupe()
        {
            return occupés.Contains(getValueBase10());
        }

        public bool occupe(decimal base10)
        {
            return occupés.Add(base10);
        }

        public void move()
        {
            increment(this.Level);
        }



        public decimal getValue()
        {
            decimal k = 1m;
            decimal ret = 0m;
            for (int i = 0; i < Level; i++)
            {
                ret += k * tab[i];
                k /= SIX;
            }
            return ret;
        }

        public decimal getValueBase10()
        {
            decimal k = 1m;
            decimal ret = 0m;
            for (int i = 0; i < Level; i++)
            {
                ret += k * tab[i];
                k /= 10;
            }
            return ret;
        }

        public decimal getNextValue(int level)
        {
            decimal k = 1;
            decimal ret = 0;
            for (int i = 0; i < level && i < NB; i++)
            {
                var v = tab[i];
                if (i == level - 1)
                    v++;
                ret += k * v;
                k /= SIX;
            }
            return ret;
        }



        private void increment(int level)
        {
            if (level < head)
            head = level;
            int index =  level-1;
            if (index < 0)
                return;

        

            int v = tab[index];
            v++;
            if (v < SIX)
            {
                tab[index] = v;
                //if (occupés.Contains(getValueBase10()))
                //    increment(l); 
            }
            else
            {
                tab[index] = 0;
                increment(level - 1);
            }


        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < Level && i < NB; i++)
            {

                sb.Append(tab[i]);
                if (i == Level - 2)
                    sb.Append(".");
                else if ((i + 1) % 4 == 0)
                    sb.Append(" ");
            }

            //sb.Append(" reste:");
            //for (int i = level; i < NB; i++)
            //{
            //    sb.Append(" ");
            //    sb.Append(tab[i]);
            //}


            sb.Append(" head:");
            sb.Append(head);

            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\Condenseur.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Text.RegularExpressions;
using System;
using pdb.util;

namespace pdb.gen.stat
{
    class Condenseur
    {
        private Regex reg = new Regex("[6789]");
        private List<NewClassement> list;
        private int total;
        const int MIN = 6;
        const int MAX = 36;
        const double PART = 6;
        const int MAX_LEVEL = 9;
        double moy;
        int nbPiece = 0;
        int nbList = 0;
        /// <summary>
        /// Classement courant
        /// </summary>
        decimal currentClassement;
        /// <summary>
        /// Liste candidate 1234.2  au million 1234.2 ==> 1 234 200
        /// </summary>
        ClassStruct currentListLevel = new ClassStruct();
        double milieuCand;
        double _objectif;
        int nbPieceByLevel = 2;
        int _current0;

        const int MILLION = 1000 * 1000;

        int index = 0;


        /// <summary>
        /// Liste à placer
        /// </summary>
        List<NewClassement> nextList = new List<NewClassement>();




        NewClassement lastItemInConstruction;
        public Condenseur(IEnumerable<Piece> list)
        {
            this.list = new List<NewClassement>();
            foreach (Piece piece in list)
                this.list.Add(new NewClassement(piece));
            this.list.Reverse();
            this.total = this.list.Count;

        }

        public List<NewClassement> NewClass { get { return list; } }

        private NewClassement lastItem;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m;
        int headLevel = 5;
        private void affect(int level, int nb)
        {
            if (index >= total)
                return;


            if (nb <= 6)
            {
                int nbRange = 0;
                currentListLevel.position();

                while (true)
                {
                    if (nbRange >= nb)
                        break;

                    var item = list[index];
                    lastItem = item;

                    if (currentListLevel.isOccupe())
                    {
                        nbRange++;
                        currentListLevel.move();
                        continue;
                    }


                    var values = currentListLevel.getValues();


                    bool compacte = false;
                    Piece piece = item.Piece;
                    if (piece.Enabled && piece.ClassementACompacter)
                    {
                        item.setLevel(values);

#if COMPACT

                        if (!piece.setClassementCompact(item.getClassement()))
                        {
                            misc.log("fin du compactage pour ", piece);
                            index = total;
                        }
#else
                            piece.setClassement(item.ClassList, item.Rating);
#endif
                        nbRange++;
                        compacte = true;

                    }
                    else
                    {
                        currentListLevel.occupe(item.Piece.ClassementValueDecimal);
                    }

                    index++;
                    if (index >= total)
                        return;


                    if (compacte)
                    {
                        var cl = lastItem.Piece.ClassementValueDecimal;
                        var curr = currentListLevel.getValueBase10();

                        if (curr - EPSILON <= cl)
                        {
                            currentListLevel.move();
                        }
                    }

                }


            }
            else
            {
                // répartition
                int nbRestant = nb;
                for (int idir = 0; idir < 6; idir++)
                {
                    decimal nbth = (decimal)nbRestant / ((decimal)6 - (decimal)idir);
                    int subNb = (int)System.Math.Ceiling(nbth);
                    affect(level + 1, subNb);
                    nbRestant -= subNb;
                }
            }



        }

        public void gener2()
        {
            decimal densite = 1.0m;

            moy = total + 100;
            for (int i = 0; i < MAX_LEVEL; i++)
            {
                moy /= PART;
            }
            currentListLevel = new ClassStruct(); // list[0].Piece.ClasssementValue;
            currentListLevel.init(5);
            int phase = 0;
            while (true)
            {
                if (index >= total)
                    break;
                NewClassement nPiece = list[index];
                Piece piece = nPiece.Piece;
                var classement = piece.ClassementValueDecimal;
                if (classement <= 0)
                {
                    index++;
                    continue;
                    // moy = 90; nbPieceByLevel = 10;
                }

                // 
                var v = currentListLevel.getValue();
                var v2 = piece.RapportClassement;

                if (v2 > v)
                    v = v2;

                if (v < 1)
                {
                    if (phase == 0)
                        densite = 6;
                    else if (phase < 3)
                        densite = 6 - phase;
                    else
                    {
                        //if (currentListLevel < 0.1 * MILLION)
                        densite = 4 - 2 * v;
                        //else
                        //    densite = 6.444444444444 - 4.44444444 * (double)currentListLevel / MILLION; 
                    }

                }
                else if (v < 2)
                    densite = 3 - v;
                //else if (currentListLevel < 2 * MILLION)
                //{
                //    densite = 3 - (double)currentListLevel / MILLION;
                //}
                else
                    densite = 1;

                //densité = 1 ==> 6t par liste pour une profondeur de 4 (1234.5)
                // je veux une distribution correspondant à une densité de 1 (6 par liste)

                /*
type    ex      nb	    niveau
d	    1	    1296	1
d	    1,2	    216	    2
d	    1,23	36	    3
l	    1,234	6	    4
i	    1,234,5	1	    5

// pour éviter de m'emmerder, je peux simplement remplir chaque niveau 3 avec les 36 * densité éléments. en descendant plus bas si nécessaire
// soit 36 éléments normalement, mais 216 avec une densité 6 par exemple
                 * 
                 * A chaque passe , je positionne la structure au pas suivant profondeur 3 
                 * je calcule le nb d'éléments à répartir
                 * ex densité 1.1 : 36 *1.1 = 39.6 soit 7 + 7 + 7 + 6 +6
                 * pour chaque répartition, je descend en profondeur jusqu'à obtenir une densité relative <=1
                 * Soit : 2+1+1+1+1+1
                 *        2+1+1+1+1+1
                 *        2+1+1+1+1+1
                 *        1+1+1+1+1+1
                 *        1+1+1+1+1+1
                 *        
                 * au niveau 3
                
                 * 
                 * Comment on fait ? 
                 * fonction récursive? 
                 * */

                //var d1 = densite;
                //var incr = 1;
                //var depth = 4; 

                //while (true)
                //{
                //    if (d1 <= 1)
                //        break;
                //    depth++;
                //    d1 /= 6; 
                //}



                //  densite = densite * 0.5; 
                //else if (classement < 0.1)
                //{ moy = 36; nbPieceByLevel = 6; }
                //else if (classement < 0.2)
                //{ moy = 24; nbPieceByLevel = 4; }
                //else if (classement < 1)
                //{ moy = 18; nbPieceByLevel = 3; }
                //else if (classement < 2)
                //{ moy = 12; nbPieceByLevel = 2; }
                //else { moy = 6; nbPieceByLevel = 1; }

                // 1234.2  au million 1234.2 ==> 1 234 200
                //cas densite 1 100
                //cas densite 2 100
                // cas densite 3 100

                // valeurs possibles de l'increment 1,2,3,10,20,30,100,200
                //// maintenant 1234.2 ==> 1 234 200
                //int increment = 200; // par 3
                //int depth = 4;
                //if (densite > 1)
                //{ increment = 100; }
                //if (densite > 2)
                //{ increment = 30; depth = 5; }
                //if (densite > 3)
                //    increment = 20;
                //if (densite > 6)
                //{ increment = 10; }
                //if (densite > 12)
                //{ increment = 3; depth = 6; }
                //if (densite >= 24)
                //    increment = 1;
                //var _current0 = currentListLevel;

                misc.log("compact phase {0} courant {1} classement={2} densite {3} ", phase, currentListLevel, piece.ClassementValueDecimal, densite);

                if (index >= total)
                    break;
                decimal nbth = densite * 1296.0m;
                int nbARepartir = (int)System.Math.Ceiling(nbth);

                affect(headLevel, nbARepartir);
                //  headLevel = currentListLevel.Level; 

                phase++;
                //if (phase >= 35)
                //{
                //    int toto = 0;
                //}

            }


            //    while (currentListLevel < _current0 + 1000)
            //    {
            //        do
            //        {
            //            currentListLevel = currentListLevel + 1;
            //        }
            //        while (reg.IsMatch(currentListLevel.ToString()));
            //        nPiece.setLevel(currentListLevel); 
            //    }


            //    if (currentListLevel >= _current0 + 1000)
            //    {
            //        _current0 = currentListLevel;
            //        doWork2();
            //        nextList.Clear();

            //    }               
            //    nextList.Add(nPiece);

            //}
            //doWork2();

            //            foreach (NewClassement np in list)
            //            {
            //                Piece piece = np.Piece;
            //#if COMPACT
            //                piece.setClassementCompact(np.getClassement());
            //#else
            //                 piece.setClassement(np.ClassList, np.Rating);
            //#endif


            //            }
        }



        //private void doWork2()
        //{
        //    //   milieuCand = nbPiece + 0.5 * nextList.Count;

        //    foreach (NewClassement _new in nextList)
        //    {
        //        _new.setLevel(currentListLevel, 5);
        //        lastItemInConstruction = _new;
        //        nbPiece++;
        //    }


        //    incrementCurrentListLevelMinus();
        //}

        //    while (true)
        //    {
        //        if (milieuCand <= _objectif)
        //        {

        //            if (lastItemInConstruction != null)
        //            {
        //                incrementCurrentListLevelMinus();
        //            }

        //            foreach (NewClassement _new in nextList)
        //            {
        //                _new.Level = currentListLevel;
        //                lastItemInConstruction = _new;
        //                nbPiece++;
        //            }

        //            nextList.Clear();

        //            break;
        //        }

        //        changeCurrentList();

        //    }
        //}

        #region OLD
        //public void gener()
        //{
        //    //1. total
        //    total = list.Count;
        //    moy = total + 100;
        //    for (int i = 0; i < MAX_LEVEL; i++)
        //    {
        //        moy /= PART;
        //    }



        //    currentClassement = list[0].Piece.ClassementValueDecimal;
        //    for (int i = 0; i < total; i++)
        //    {
        //        NewClassement nPiece = list[i];
        //        Piece piece = nPiece.Piece;
        //        var classement = piece.ClassementValueDecimal;
        //        if (classement != currentClassement)
        //        {
        //            currentClassement = classement;
        //            doWork();
        //        }

        //        nextList.Add(nPiece);

        //    }

        //    doWork();

        //    foreach (NewClassement np in list)
        //    {
        //        Piece piece = np.Piece;
        //        piece.setClassement(np.ClassList, np.Rating);

        //    }
        //}

        //private void doWork()
        //{
        //    milieuCand = nbPiece + 0.5 * nextList.Count;
        //    while (true)
        //    {
        //        if (milieuCand <= _objectif)
        //        {

        //            if (lastItemInConstruction != null)
        //            {
        //                incrementCurrentListLevelMinus();
        //            }

        //            foreach (NewClassement _new in nextList)
        //            {
        //                //  _new.setLevel(currentListLevel, 4);
        //                lastItemInConstruction = _new;
        //                nbPiece++;
        //            }

        //            nextList.Clear();

        //            break;
        //        }

        //        changeCurrentList();

        //    }
        //}

        //private void incrementCurrentListLevel()
        //{
        //    nbList++;
        //    do
        //    {
        //        //     currentListLevel = (int)(currentListLevel) + 10;
        //    }
        //    while (reg.IsMatch(currentListLevel.ToString()));
        //    calculObj();

        //}

        //private void incrementCurrentListLevelMinus()
        //{
        //    var _old = currentListLevel;
        //    do
        //    {
        //        //        currentListLevel = currentListLevel + 1;
        //    }
        //    while (reg.IsMatch(currentListLevel.ToString()));
        //    //if ((int)_old != (int)currentListLevel)
        //    //{
        //    //    nbList++;
        //    //    lastItemInConstruction = null;
        //    //}
        //    calculObj();

        //}

        //private void calculObj()
        //{
        //    _objectif = moy * nbList;
        //}

        //private void changeCurrentList()
        //{
        //    incrementCurrentListLevel();
        //    lastItemInConstruction = null;
        //}

        #endregion



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\StatBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using pdb.util;
using Math = pdb.util.Math; 

namespace pdb.gen.stat
{
    class StatBuilder
    {


        private List<Piece> list;
        private StreamWriter st;
        private int level;
        private int sub;
        private int delta;

        private decimal coeff;

        public const int VAL_MAX = 6000;
        private int min;
        private int nbCurrent;
        private int index; 
        private Regex reg = new Regex("[6789]");
        public const int NB_MEDIANE = 36;
        private StatConteneur conteneur = new StatConteneur();
        public StatBuilder(IEnumerable<Piece> list)
        {
            this.list = new List<Piece>(list);
            this.list.Reverse();
        }

        private void record()
        {
            st.Write((double)min / 1000);
            st.Write("\t");
            st.WriteLine(nbCurrent);
        }
        private void record3()
        {
            var _min = (decimal)min / 100000m; 
            st.Write(_min);
            st.Write("\t");
            var v = (decimal)nbCurrent / coeff;
            st.Write(v.ToString("0.#####"));

            st.Write("\t");
            decimal cur = Piece.getRapport(_min);            
            st.WriteLine(cur.ToString("0.######")); 
        }

        private void record4()
        {
            var _min = (decimal)min / (10000 * loupeCoeff); 
            st.Write(_min);
            st.Write("\t");
            double v = (double)nbCurrent / (double)coeff;
            st.Write(v.ToString("0.#####"));

            st.Write("\t");
            decimal cur = Piece.getRapport(_min);
            st.WriteLine(cur.ToString("0.######")); 

        }

        private void record2()
        {
            conteneur.record(level, sub, min, nbCurrent);
        }

        public void gener()
        {
            gener("stats.txt");
        }

        public void gener0()
        {
            gener0("stats.txt");
        }


        public void gener0(string file)
        {
            decimal EPSILON = 0.00000001m;
            int count = list.Count;
            if (count == 0)
                return;
            using (Stream stream = new FileStream(@"..\" + file, FileMode.Create))
            {
                using (st = new StreamWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = 10000;
                        for (level = 0; level < 4; level++)
                        {
                            deltaBase /= 10;
                            int nb = VAL_MAX / deltaBase;
                            //  var tab = new int[nb]; 
                            for (sub = 3; sub >= 1; sub--)
                            {
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                delta = sub * deltaBase;
                                //   nb =(int)( 6 / sub * Math.Pow(10, 4 - level)); 
                                // level = 1 =>600

                                // parcourir la liste triée
                                // pour chaque pièce comparer classNameAndRating
                                int index = 0;
                                st.WriteLine();
                                st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                min = 0;
                                int max = delta;


                                var current = list[index].ClassementValueDecimal0;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 1000 + EPSILON >= max || _end)
                                    {
                                        //if (!reg.IsMatch(min.ToString()))
                                        record();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal0;
                                    }
                                }

                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }
                    st.WriteLine();

                    try
                    {
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        const int DETAIL = 1000;

                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            tranches.Add(new Tranche(i));
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    decimal rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal0;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * (decimal)div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.WriteLine();
                        st.Write("\t");
                        st.Write("\t");
                        st.Write("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Write(i + 2);
                            st.Write("\t");
                            st.Write(i + 2);
                            st.Write("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.WriteLine();
                            st.Write((double)tranche.index / DETAIL);
                            st.Write("\t");

                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Write(densite);
                                st.Write("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Write(densite);
                                }
                                else
                                    st.Write(0);
                                st.Write("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                    }
                }
            }
        }


        //public void gener3(bool generDistrib)
        //{
        //    gener3("stats3.txt", generDistrib);
        //}
        public void gener3(string file, bool generDistrib)
        {
            decimal EPSILON = 0.00000001m;
            int VAL_MAX = StatBuilder.VAL_MAX * 100;
            int count = list.Count;
            if (count == 0)
                return;
            while (true)
            {
                try
                {
                    misc.log("gener " + file);


                    var filename = Path.GetFileNameWithoutExtension(file);
                    var ext = Path.GetExtension(file);
                    string _file = @"..\" + filename + "_med" + ext;
                    string f0 = @"..\" + file;
                    string f0tmp = f0 + ".tmp";
                    string f1tmp = _file + ".tmp";
                    int NBLINE = 65500;
                    int nbLine = 0;
                    using (Stream stream = new FileStream(f0tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream, Encoding.ASCII))
                        {
                            try
                            {
                                int deltaBase = 1000000;
                                for (level = 5; level >= 0; level--)
                                {
                                    if (nbLine >= NBLINE) break;
                                    deltaBase /= 10;
                                    int nb = VAL_MAX / deltaBase;

                                    for (sub = 3; sub >= 1; sub--)
                                    {
                                        if (nbLine >= NBLINE) break;
                                        coeff = Math.Pow(6, level - 1) * (decimal)sub;
                                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                        delta = sub * deltaBase;
                                        index = 0;
                                        st.WriteLine(); nbLine++;
                                        st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub); nbLine++;

                                        min = 0;
                                        int max = delta;


                                        decimal current = list[index].ClassementValueDecimal0;
                                        nbCurrent = 0;

                                        bool _end = false;
                                        while (true)
                                        {
                                            if (min >= VAL_MAX)
                                                break;

                                            if (current * 100000 + EPSILON >= max || _end)
                                            {

                                                record3();

                                                nbLine++;
                                                if (nbLine >= NBLINE) break;


                                                min = max;
                                                while (reg.IsMatch(min.ToString()))
                                                    min += deltaBase;

                                                max = min + delta;
                                                nbCurrent = 0;

                                            }
                                            else
                                            {
                                                nbCurrent++;
                                                index++;
                                                if (index >= list.Count)
                                                {

                                                    _end = true;
                                                    continue;
                                                }
                                                current = list[index].ClassementValueDecimal0;
                                            }
                                        }

                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex);
                                throw; 
                            }

                        }
                    }

                    File.Copy(f0tmp, f0, true);
                    File.Delete(f0tmp);

                    misc.log("fin gener " + file);

                    if (!generDistrib)
                        return;

                    misc.log("gener distrib " + _file);

                    using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream2, Encoding.UTF8))
                        {

                            try
                            {
                                //phase deux déterminer les tantièmes
                                //1,2,3..10,20,30..100,
                                double nbTot = count;
                                double portion = nbTot;
                                int K = 1;
                                decimal valueFrom = 0;

                                decimal classTo = 6.0m;
                                decimal classFrom = 0.0m;

                                List<Tranche> tranches = new List<Tranche>();
                                Dict<int, Tranche> dict = new Dict<int, Tranche>();
                                const int DETAIL = 10000;

                                for (int i = 0; i < 6 * DETAIL; i++)
                                {
                                    if (reg.IsMatch(i.ToString()))
                                        continue;
                                    var tranche = new Tranche(i);
                                    tranches.Add(tranche);
                                    dict[i] = tranche;
                                }
                                for (level = 1; level < 2; level++)
                                {



                                    for (int div = 2; div <= NB_MEDIANE; div++)
                                    {


                                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                        valueFrom = 0;
                                        int iFrom = 0;
                                        int iTo = count - 1;
                                        portion = nbTot / div;
                                        classFrom = 0;
                                        for (sub = 1; sub <= div; sub++)
                                        {

                                            double to = sub * portion;
                                            iTo = 0;
                                            if (to > 0)
                                                iTo = (int)to - 1;
                                            if (iTo >= list.Count)
                                                iTo = list.Count - 1;
                                            if (iTo < 0)
                                                iTo = 0;
                                            decimal rapport = list[iTo].RapportClassementDecimal;
                                            classTo = list[iTo].ClassementValueDecimal0;


                                            //st.Write(classFrom);
                                            ////st.Write("\t");
                                            //st.Write(classTo);
                                            //st.Write("\t");
                                            ////st.Write(valueFrom);
                                            ////
                                            //st.Write(rapport);
                                            //st.Write("\t");


                                            //int nb = (iTo - iFrom + 1);                          
                                            //st.Write(nb);
                                            //st.Write("\t");
                                            decimal densite = 0m;
                                            if (rapport != valueFrom)
                                                densite = 1.0m / ((rapport - valueFrom) * div);
                                            //st.Write("\t");
                                            //st.Write(densite);
                                            //st.WriteLine(); 

                                            for (int i = 0; i < 6 * DETAIL; i++)
                                            {
                                                if (i < classFrom * DETAIL)
                                                    continue;
                                                if (i > classTo * DETAIL)
                                                    continue;
                                                if (reg.IsMatch(i.ToString()))
                                                    continue;
                                                Tranche tranche = dict[i];
                                                //  Tranche tranche = tranches.Find(t => t.index == i);
                                                tranche.densites[div - 1] = densite;
                                            }

                                            valueFrom = rapport;
                                            iFrom = iTo;
                                            classFrom = classTo;
                                        }
                                    }
                                    K *= 10;
                                }

                                st.WriteLine();
                                st.Write("\t");
                                st.Write("\t");
                                st.Write("\t");

                                for (int i = 0; i < NB_MEDIANE; i++)
                                {
                                    st.Write(i + 2);
                                    st.Write("\t");
                                    st.Write(i + 2);
                                    st.Write("\t");
                                }
                                Tranche last = null;
                                foreach (Tranche tranche in tranches)
                                {
                                    st.WriteLine();
                                    st.Write((double)tranche.index / DETAIL);
                                    st.Write("\t");

                                    for (int i = 0; i < NB_MEDIANE; i++)
                                    {
                                        var densite = tranche.densites[i];
                                        st.Write(densite);
                                        st.Write("\t");
                                        if (last == null || last.densites[i] != densite)
                                        {
                                            st.Write(densite);
                                        }
                                        else
                                            st.Write(0);
                                        st.Write("\t");
                                    }
                                    last = tranche;
                                }

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine(e);
                                throw; 
                            }
                        }

                    }

                    File.Copy(f1tmp, _file, true);
                    File.Delete(f1tmp);

                    misc.log("fin gener distrib " + _file);
                    break; 
                }
                catch (Exception e)
                {
                    misc.log(e.ToString()); 
                }
            }
        }

        private int loupe;
        private decimal loupeCoeff;
        public int Loupe { set { loupe = value; loupeCoeff =  pdb.util.Math.Pow(1000, loupe); } }
        public void gener4(string file)
        {
            decimal EPSILON = 0.00000001m / loupeCoeff;
            decimal VAL_MAX = StatBuilder.VAL_MAX * 10; // on laisse inchangé pour faire seulement une partie
            int count = list.Count;
            if (count == 0)
                return;
           // misc.log("gener " + file + loupe);

            while (true)
            {
                try
                {
                    var filename = Path.GetFileNameWithoutExtension(file);
                    var ext = Path.GetExtension(file);
                    var str = "";
                    if (loupe > 0)
                        str = loupe.ToString();
                    string _file = @"..\" + filename + "_med" + str + ext;
                    string f0 = @"..\" + filename + str + ext;

                    misc.log("gener " + f0);

                    string f0tmp = f0 + ".tmp";
                    //   string f1tmp = _file + ".tmp";
                    using (Stream stream = new FileStream(f0tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream, Encoding.ASCII))
                        {
                            try
                            {
                                int deltaBase = (int)(100000);
                                for (level = 4; level >= 0; level--)
                                {
                                    deltaBase /= 10;
                                    //int nb = VAL_MAX / deltaBase;

                                    for (sub = 3; sub >= 1; sub--)
                                    {
                                        coeff = Math.Pow(6, level - 3 * loupe) * sub; /// loupeCoeff;
                                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                        int delta = (int)(sub * deltaBase);
                                        index = 0;
                                        st.WriteLine();
                                        st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                        min = 0;
                                        var max = delta;


                                        var current = list[index].ClassementValueDecimal0;
                                        nbCurrent = 0;

                                        bool _end = false;
                                        while (true)
                                        {
                                            if (min >= VAL_MAX)
                                                break;

                                            if (current * 10000 * loupeCoeff + EPSILON >= max || _end)
                                            {

                                                record4();

                                                min = max;
                                                while (reg.IsMatch(min.ToString()))
                                                    min += (int)deltaBase;

                                                max = min + delta;
                                                nbCurrent = 0;

                                            }
                                            else
                                            {
                                                nbCurrent++;
                                                index++;
                                                if (index >= list.Count)
                                                {

                                                    _end = true;
                                                    continue;
                                                }
                                                current = list[index].ClassementValueDecimal0;
                                            }
                                        }

                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex);
                                throw;
                            }

                        }
                    }

                    File.Copy(f0tmp, f0, true);
                    File.Delete(f0tmp);

                    misc.log("fin gener " + f0);
                    /*
                    if (!generDistrib)
                        return;

                    misc.log("gener distrib " + _file);

                    using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream2, Encoding.UTF8))
                        {

                            try
                            {
                                //phase deux déterminer les tantièmes
                                //1,2,3..10,20,30..100,
                                double nbTot = count;
                                double portion = nbTot;
                                int K = 1;
                                decimal valueFrom = 0;

                                decimal classTo = 6.0m;
                                decimal classFrom = 0.0m;

                                List<Tranche> tranches = new List<Tranche>();
                                Dict<int, Tranche> dict = new Dict<int, Tranche>();
                                const int DETAIL = 10000;

                                for (int i = 0; i < 6 * DETAIL; i++)
                                {
                                    if (reg.IsMatch(i.ToString()))
                                        continue;
                                    var tranche = new Tranche(i);
                                    tranches.Add(tranche);
                                    dict[i] = tranche;
                                }
                                for (level = 1; level < 2; level++)
                                {



                                    for (int div = 2; div <= NB_MEDIANE; div++)
                                    {


                                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                        valueFrom = 0;
                                        int iFrom = 0;
                                        int iTo = count - 1;
                                        portion = nbTot / div;
                                        classFrom = 0;
                                        for (sub = 1; sub <= div; sub++)
                                        {

                                            double to = sub * portion;
                                            iTo = 0;
                                            if (to > 0)
                                                iTo = (int)to - 1;
                                            if (iTo >= list.Count)
                                                iTo = list.Count - 1;
                                            if (iTo < 0)
                                                iTo = 0;
                                            decimal rapport = list[iTo].RapportClassementDecimal;
                                            classTo = list[iTo].ClassementValueDecimal;


                                            //st.Write(classFrom);
                                            ////st.Write("\t");
                                            //st.Write(classTo);
                                            //st.Write("\t");
                                            ////st.Write(valueFrom);
                                            ////
                                            //st.Write(rapport);
                                            //st.Write("\t");


                                            //int nb = (iTo - iFrom + 1);                          
                                            //st.Write(nb);
                                            //st.Write("\t");
                                            decimal densite = 0m;
                                            if (rapport != valueFrom)
                                                densite = 1.0m / ((rapport - valueFrom) * div);
                                            //st.Write("\t");
                                            //st.Write(densite);
                                            //st.WriteLine(); 

                                            for (int i = 0; i < 6 * DETAIL; i++)
                                            {
                                                if (i < classFrom * DETAIL)
                                                    continue;
                                                if (i > classTo * DETAIL)
                                                    continue;
                                                if (reg.IsMatch(i.ToString()))
                                                    continue;
                                                Tranche tranche = dict[i];
                                                //  Tranche tranche = tranches.Find(t => t.index == i);
                                                tranche.densites[div - 1] = densite;
                                            }

                                            valueFrom = rapport;
                                            iFrom = iTo;
                                            classFrom = classTo;
                                        }
                                    }
                                    K *= 10;
                                }

                                st.WriteLine();
                                st.Write("\t");
                                st.Write("\t");
                                st.Write("\t");

                                for (int i = 0; i < NB_MEDIANE; i++)
                                {
                                    st.Write(i + 2);
                                    st.Write("\t");
                                    st.Write(i + 2);
                                    st.Write("\t");
                                }
                                Tranche last = null;
                                foreach (Tranche tranche in tranches)
                                {
                                    st.WriteLine();
                                    st.Write((double)tranche.index / DETAIL);
                                    st.Write("\t");

                                    for (int i = 0; i < NB_MEDIANE; i++)
                                    {
                                        var densite = tranche.densites[i];
                                        st.Write(densite);
                                        st.Write("\t");
                                        if (last == null || last.densites[i] != densite)
                                        {
                                            st.Write(densite);
                                        }
                                        else
                                            st.Write(0);
                                        st.Write("\t");
                                    }
                                    last = tranche;
                                }

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine(e);
                            }
                        }

                    }

                    File.Copy(f1tmp, _file, true);
                    File.Delete(f1tmp);

                    misc.log("fin gener distrib " + _file);
                     * 
                     * */

                    break; 
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString()); 
                }

            }
        }

        public void gener(string file)
        {
            int count = list.Count;
            if (count == 0)
                return;
            decimal EPSILON = 0.00000001m;

            var filename = Path.GetFileNameWithoutExtension(file);
            var ext = Path.GetExtension(file);
            string _file = @"..\" + filename + "2" + ext;
            using (Stream stream = new FileStream(_file, FileMode.Create))
            {
                using (pdb.util.TextWriter st = new pdb.util.TextWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = 10000;
                        for (level = 3; level >= 0; level--)
                        {
                            deltaBase /= 10;
                            int nb = VAL_MAX / deltaBase;
                            //  var tab = new int[nb]; 
                            for (sub = 3; sub >= 1; sub--)
                            {
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                delta = sub * deltaBase;
                                int index = 0;


                                min = 0;
                                int max = delta;


                                var current = list[index].ClassementValueDecimal0;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 1000 + EPSILON >= max || _end)
                                    {
                                        record2();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal0;
                                    }
                                }

                            }
                        }

                        var datas = conteneur.Datas;

                        var results = new List<ResultLine>();

                        min = 0;
                        while (true)
                        {
                            while (reg.IsMatch(min.ToString()))
                                min++;
                            if (min >= VAL_MAX)
                                break;
                            results.Add(new ResultLine(min));
                            min++;
                        }

                        foreach (StatItem item in datas)
                        {
                            var level = item.level;
                            var sub = item.sub;
                            var _min = item.min;
                            var nb = item.nb;
                            // Détermination de la colonne
                            int col = 3 * level + sub - 1;

                            // Détermination du coeff d'expansion / moyenne
                            int coeff = (int)Math.Pow(6, level) * sub;

                            ResultLine res0 = results.Find(r => r.min == _min);
                            int index0 = results.IndexOf(res0);

                            for (int i = 0; i < coeff; i++)
                            {
                                results[index0 + i][col] = (double)nb / (double)coeff;
                            }

                        }


                        st.Append("min"); st.Append("\t");
                        for (int l = 0; l < 4; l++)
                        {
                            for (int s = 1; s <= 3; s++)
                            {
                                st.Append(l); st.Append(" ");
                                st.Append(s); st.Append("\t");
                            }

                        }
                        st.AppendLine();
                        st.AppendLine();


                        foreach (ResultLine line in results)
                        {
                            line.getLine(st); st.AppendLine();
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }

                    try
                    {

                        st.AppendLine();
                        st.AppendLine();
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0m;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        const int DETAIL = 1000;
                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            tranches.Add(new Tranche(i));
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    var rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal0;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0m;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.AppendLine();
                        st.Append("\t");
                        st.Append("\t");
                        st.Append("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Append(i + 2);
                            st.Append("\t");
                            st.Append(i + 2);
                            st.Append("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.AppendLine();
                            st.Append((double)tranche.index / DETAIL);
                            st.Append("\t");


                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Append(densite);
                                st.Append("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Append(densite);
                                }
                                else
                                    st.Append(0);
                                st.Append("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }
                }
            }
        }


    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math; 

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        //private bool loadLastFull;
        //private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        // r�cup�ration des infos externes
        public void LegacyConsolid(CListPiece list, DateTime date)
        {
            misc.log("Cdb::LegacyConsolid");

            DateTime now = DateTime.Now;
            ChronoData.refreshDate(date);

            foreach (CPiece ext in list)
            {
                m_list.legacyConsolid(ext);
            }

            m_list.bilanNatives();

           // setAlbumArtistFromFile();

        }

        public void LegacyConsolid(CPiece ext)
        {
            m_list.legacyConsolid(ext);
        }

        public void SynchroNative(DateTime date)
        {
            misc.log("Cdb::SynchroNative");
            ChronoData.refreshDate(date);
            foreach (CPiece piece in m_list)
            {
                piece.SynchroNative();
            }

        }

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        public void Sov(string fileIt)
        {
            if (SOV == null)
                return; 
            var list = new List<string> { fileIt, LOCAL_FILE.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

        public void SovIni()
        {
            if (SOV == null)
                return; 
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni); 

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

       
        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        private void write()
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                m_list.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



            if (lastFull != null)
            {
                try
                {
                    var diff = DiffFile.FullName;
                    if (mode == dbMode.full)
                        diff = diff.Replace(".xml", ".d.xml");

                    using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                    {
                        writer.WriteStartElement("db");
                        writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                        writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                        m_list.writeDiff(writer, lastFull);
                        writer.WriteEndDocument();
                        writer.Flush();
                    }

                    File.Copy(diff + ".tmp", DiffFile.FullName, true);
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

            WriteDB2();
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        public void WriteDB2()
        {

            misc.log("CDb:WriteDB2");
            lock (lockSave)
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff); 
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }


            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece); 
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }



        private  CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }

        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(CPlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
  <file path="\PieceDb.Db\DataConf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using pdb.util;

namespace pdb.db
{

    public class DataConf : TuningBase
    {
        public readonly FileInfo dbLocal;
        public readonly FileInfo dbRemote;
        public readonly FileInfo dbTrace;
        public readonly FileInfo dbSov;
        public readonly FileInfo dbLastFull;
        public readonly FileInfo dbDiff;
        public readonly dbMode mode;
        public int sovNb = 10;
        public TimeSpan sovMin = TimeSpan.FromHours(1);

        public string sZip = @"C:\Program Files\7-Zip\7z.exe";
        public readonly string defaultFolder;
        private string root;
        public List<string> othersIni = new List<string>();
        public List<string> othersDiff = new List<string>();

        private string getFilename(string str)
        {
            return root + str;
        }

        public DataConf(XmlElement node)
            : base()
        {
            if (node == null)
                return;

            root = DIR_CONF;

            var dataNode = XMLTool.NodeLookUp(node, "data");
            if (dataNode == null)
                return;

            var att = dataNode.Attributes["root"];
            if (att != null)
            {
                root = root + att.Value;
            }
            this.child = dataNode;
            XMLTool l_xmlConf = new XMLTool(dataNode);
            string str = l_xmlConf.getNodeValue("dbLocal");
            dbLocal = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbRemote");
            dbRemote = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbSov");
            if (string.IsNullOrEmpty(str))
                dbSov = null;
            else
                dbSov = new FileInfo(DIR_CONF + str);

            str = l_xmlConf.getNodeValue("dbTrace");
            dbTrace = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbLastFull");
            dbLastFull = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("dbDiff");
            dbDiff = new FileInfo(getFilename(str));

            str = l_xmlConf.getNodeValue("mode");
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);


            str = l_xmlConf.getNodeValue("zip");
            sZip = str;

            defaultFolder = l_xmlConf.getNodeValue("defaultFolder");

            buildi("sovNb", (v) => sovNb = v);
            double _deltaMin = -1;
            buildd("sovMin", (v) => _deltaMin = v);
            if (_deltaMin > 0)
                sovMin = TimeSpan.FromMinutes(_deltaMin);

            var xother = XMLTool.NodeLookUp(dataNode, "others");
            if (xother != null)
            {
                foreach (XmlNode xsub in xother.ChildNodes)
                {
                    if (xsub is XmlElement)
                    {
                        var name = xsub.Name;
                        var content = DIR_CONF + xsub.InnerText;
                        if (name == "ini")
                            othersIni.Add(content);
                        else if (name == "diff")
                            othersDiff.Add(content);
                    }
                }
            }

        }
        public string Zip { get { return sZip; } }
    }
}
]]></content>
  </file>
</db>
