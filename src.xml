<db path="C:\bernard\db2\">
  <file path="db4\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelTreelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private PlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        //private static List<IRedraw> gui = new List<IRedraw>();
        //internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }
#if EXPORT
        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion
#endif
        private bool _main = true;
        public void setSecondary() { _main = false; }


        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        //private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        //private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        //protected static void recordPl(PlayListViewModel pl)
        //{
        //    dictPl.Add(pl.pl.getPath(), pl);
        //}

        //protected static string getKey(PlayListViewModel pl, int id)
        //{
        //    return pl.pl.getPath() + "|" + id;
        //}

        private HashSet<int> hs = new HashSet<int>();

        protected void recordTrack(TrackListViewModel t)
        {
            hs.Add(t.PieceId);
        }

        public bool contains(int id)
        {
            return hs.Contains(id);
        }

        //public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        //{
        //    return dictT.ContainsKey(getKey(pl, t.PieceId));
        //}

        protected void removeTrack(TrackListViewModel t)
        {
            hs.Remove(t.PieceId); // dictT.Remove(getKey(pl, t.PieceId));
        }

        //public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        //{
        //    var key = getKey(pl, id);
        //    if (dictT.ContainsKey(key))
        //        return dictT[key];
        //    return null;
        //}

        //public TrackListViewModel FindTrack(int id)
        //{
        //    return findTrack(this, id);
        //}

        public static void resetExport(exportState state)
        {
            misc.log("resetExport {0}", state);
            try
            {
                foreach (var t in TrackListViewModel.Dict.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public static void setExport(Piece p, exportState state)
        {
            if (_selectedPl != null)
            {

                try
                {
                    var t = TrackListViewModel.getOrCreate(p); // findTrack(_selectedPl, id);
                    if (t != null)
                    {
                        t.ExportStatus = state;
                    }

                    //foreach (TrackListViewModel t in _selectedPl._tracks)
                    //{
                    //    if (t.PieceId == id)
                    //        t.refresh();
                    //}
                }
                //foreach (TrackListViewModel t in dictT.Values)
                //{
                //    if (t.PieceId == id)
                //        t.ExportStatus = state;
                //}

                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }


        }

        //protected bool contains( int id)
        //{
        //    //return hs.Contains(id); 
        //    //var key = getKey(pl, id);
        //    //if (dictT.ContainsKey(key))
        //    //    return true;
        //    //return false;
        //}


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        public void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlayList sublist in pl.PlayLists)
            {
                var _pl = new PlayListViewModel(sublist, this);
                _childs.Add(_pl);
                _playlists.Add(_pl);
                //  recordPl(_pl);
            }
            foreach (Piece track in pl.Items)
            {
                if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                    continue;
                TrackListViewModel _t = null;
                if (_main)
                    _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                else
                    _t = TrackListViewModel.getOrCreateA(track);
                _childs.Add(_t);
                _tracks.Add(_t);
                recordTrack(_t);
            }



            allTracks = new AllTracksViewModel(this, false, false);
        }


        public void Synch()
        {
            var hsnew = new HashSet<int>();
            foreach (Piece track in pl.Items)
            {
                hsnew.Add(track.PieceId);
                if (!hs.Contains(track.PieceId))
                {
                    log.log("Sync {0} ajout {1}", this, track);
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getOrCreateA(track);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                }
            }

            foreach (int oldId in hs)
            {
                if (!hsnew.Contains(oldId))
                {
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.get(oldId); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getA(oldId);
                    string desc = oldId.ToString();
                    if (_t != null)
                        desc = _t.ToString();
                    log.log("Sync {0} suppression {1}", this, desc);
                    if (_t != null)
                    {
                        _childs.Remove(_t);
                        _tracks.Remove(_t);
                    }
                }
            }

            hs = hsnew;
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new PlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            // recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue;
                var sub = get(dir, false);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab, 0);
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(PlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(PlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public PlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true;
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            var client = new SimpleClient("PlayListViewModel::OnCollectionChange", log);
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                client.log("_lock");
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list

                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {

                        App.Dispatch(() => { handler(this, e); client.log("handler"); }, client);
                        //try
                        //{
                        //    var dispatcherObject = handler.Target as DispatcherObject;
                        //    // If the subscriber is a DispatcherObject and different thread
                        //    if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        //    // Invoke handler in the target dispatcher's thread
                        //    {
                        //        var ope =
                        //        dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                        //                           handler, this, e);
                        //        ope.Completed += ope_Completed;
                        //    }
                        //    else // Execute handler as is
                        //        handler(this, e);
                        //}
                        //catch (Exception ex)
                        //{
                        //    App.log.log(ex.ToString());
                        //}
                    }
                }
            }
            client.End();

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new PlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            //recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        private TrackListViewModel Get(IFile file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file as Piece, false);
            return t;
        }

        private TrackListViewModel Get(Piece file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file, false);
            return t;
        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (hs.Contains(piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            //var tl = new TrackList(piece);
            pl.add(piece);
            //var p = piece.Track;
            //CPiece cPiece = null;
            //if (p is CPiece)
            //    cPiece = p as CPiece;

            //else if (p is TrackListViewModel)
            //{
            //    var pp = ((TrackListViewModel)p).Piece;
            //    cPiece = pp as CPiece;
            //}


            //if (cPiece != null)
            //    pl.addPiece(cPiece);
            var vm = TrackListViewModel.getOrCreate(piece); // new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        private void insert2(TrackListViewModel k, List<Piece> newElements)
        {
            int indexInsert = k.Index2 - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k.PieceGen);
        }
        //  private bool filterNext; 
        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            lock (Consolid.Lock)
            {
                lock (Albums.Lock)
                {
                    var tt = TrackListViewModel.HumanSelected;
                    if (tt != null)
                    {
                        tt.refresh();
                        //var g = tt.Grouping; 
                        // tt.Grouping = tt.PieceGen.RankAlbumReverse.ToString();
                    }

                    bool isMe = PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this;
                    bool isAlbum = this.isSubList("album");
                    bool isGen = this.isSubList("gen");


                    var confalbum = App.gen.SortAlbumMode;
                    int stackBefore = 4;
                    if (confalbum != null && confalbum.stackBefore > 0)
                        stackBefore = confalbum.stackBefore;

                    // bool checkStack = (PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this) && isGen && !isAlbum && confalbum.stackEnabled;

                    int _indexAlbumRead = -1;
                    int _indexTrackRead = -1;
                    Album _currentAlbum = null;
                    TrackListViewModel current = TrackListViewModel.CurrentPlaying;
                    Album currentAlbum = null;
                    if (current != null)
                        currentAlbum = current.album;
                    var conf = CConf.ConfGen;
                    List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
                    List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

                    var newElements = new HashList<IFile>(newElements_);


                    BgDict<int, bool?> newElt = new BgDict<int, bool?>();
                    foreach (IFile elt in newElements_)
                    {
                        newElt[elt.PieceId] = false;
                    }

                    int indexAlbumOrg = -1;
                    int indexTrackOrg = -1;

                    int indexAlbumOrg2 = -1;
                    int indexTrackOrg2 = -1;
                    var tracks = _tracks;
                    //if (isMe)
                    //{
                    tracks = new List<TrackListViewModel>(_tracks);
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                    // }

                    int count0 = _tracks.Count;
                    //  var limitList = CConf.ConfGen.LimitList;

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;
                        bool keep = false;
                        //if (isMe)
                        //{
                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {
                            keep = true;
                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {
                            keep = true;
                            indexAlbumOrg = _indexAlbumRead;
                            indexTrackOrg = _indexTrackRead;
                        }
                        //}

                        newElt[tl.PieceId] = keep;


                        //if (current != null && !keep && tl.Location == current.Location)
                        //{
                        //    App.log.log("bizarre");
                        //}
                        if (!found)
                        {
                            if (keep)
                                toKeep.Add(tl);
                            else
                                toDelete.Add(tl);
                        }
                    }

                    //if (checkStack)
                    //{
                    _indexAlbumRead = -1;
                    _indexTrackRead = -1;
                    tracks.Sort((x, y) => x.Index2.CompareTo(y.Index2));
                    // }

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;


                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {

                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {

                            indexAlbumOrg2 = _indexAlbumRead;
                            indexTrackOrg2 = _indexTrackRead;
                        }

                    }
                    //  }



                    //Addition
                    List<IFile> toAdd = new List<IFile>();
                    //if (limitList <= 0 || !_log)
                    //{
                    foreach (IFile elt in newElements)
                    {
                        if (writer.Aborted)
                            return;

                        bool found = hs.Contains(elt.PieceId); // contains(this, elt.PieceId);


                        if (!found)
                            toAdd.Add(elt);

                    }
                    //  log.log("mergeList::fin determination toAdd");

                    if (toAdd.Count > 0 && _log)
                        log.log("{0} {1} elt to add", this, toAdd.Count);

                    if (tracks.Count > 0 && toAdd.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt to add c'est trop!", this, toAdd.Count);
                        try { toAdd.RemoveRange(100, toAdd.Count - 100); }
                        catch { toAdd.Clear(); }

                        //return;
                        //var l = new List<IFile>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toAdd[i]);
                        //toAdd = l;
                    }

                    if (tracks.Count > 0 && toDelete.Count > 0 && _log)
                        log.log("{0} {1} elt to delete", this, toDelete.Count);

                    if (toDelete.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt toDelete c'est trop!", this, toDelete.Count);

                        try { toDelete.RemoveRange(100, toDelete.Count - 100); }
                        catch { toDelete.Clear(); }

                        // toDelete.Clear();
                        //var l = new List<TrackListViewModel>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toDelete[i]);
                        //toDelete = l;
                    }


                    int count = toAdd.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (writer.Aborted) return;

                        AddTrack(toAdd[i], false);
                    }

                    foreach (TrackListViewModel vm in toDelete)
                    {
                        if (writer.Aborted) return;
                        RemoveTrack(vm, false);
                    }
                    //  }


                    var newElements3 = newElements;

                    if (isGen)
                    {
                        Album.clearMove();
                        HashSet<int> moved = new HashSet<int>();
                        HashSet<int> empeached = new HashSet<int>();
                        HashSet<int> unavailable = new HashSet<int>();
                        newElements3 = new HashList<IFile>();
                        // chercher le premier album non quarantaine
                        decimal min = int.MaxValue;
                        Piece pMin = null;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.InStackPeremption)
                                continue;
                            var aux = t.PieceAlbum.ClassementValueLightSt;
                            if (aux < min)
                            {
                                min = aux;
                                pMin = t;
                            }
                            if (!t.InStackSize && t.PieceAlbum != null)
                            {
                                break;
                            }
                        }


                        // int ifirst = 0;
                        bool b = false;
                        Album courant = null;
                        int nbOk = 0;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.PieceAlbum == courant)
                                continue;
                            courant = t.PieceAlbum;

                            if (courant.Absent)
                            {
                                unavailable.Add(t.PieceAlbum.Next.MasterId);
                            }
                            else
                            {
                                if (t == pMin)
                                {
                                    // newElements3.Add(t);
                                    continue;
                                }

                                if (courant.InStackPeremption ||
                                    (courant.InStackSize && courant.ClassementValueLight < min
                                        && courant.ClassementValueLightSt > min)) //  checkStack && courant.ClassementValueLightSt >= min)
                                {
                                    if (!b)
                                    {
                                        courant.Empeached1 = true;
                                        b = true;
                                    }
                                    //if (courant.InStackPeremption)
                                    //{
                                    empeached.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Empeached = true;
                                    // }

                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Moved = true;

                                    newElements3.Add(t);



                                }
                                else
                                    nbOk++;
                                if (nbOk > stackBefore)
                                    break;
                            }


                        }

                        if (0 < newElements.Count) // && checkStack)
                        {

                            HashSet<Album> albs = new HashSet<Album>();
                            count = newElements.Count;
                            courant = null;

                            for (int i = 0; i < count; i++)
                            {

                                var t = newElements[i] as Piece;
                                if (t.PieceAlbum.Moved)
                                    continue;
                                if (t.PieceAlbum.Empeached)
                                    continue;
                                if (t != pMin && t.InStackSize && t.ClassementValueLight < min && t.ClassementValueLightSt > min)
                                {
                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    t.Moved = true;
                                    if (t.isEmpeached())
                                    {
                                        empeached.Add(t.PieceAlbum.Next.MasterId);
                                    }

                                }
                                else if (t.AlbumAbsent)
                                { }// moved.Add(t.Album); 
                                else
                                {
                                    var _alb = t.PieceAlbum;
                                    if (courant != _alb)
                                    {
                                        courant = _alb;

                                        if (!albs.Contains(courant))
                                        {
                                            if (albs.Count < stackBefore)
                                            {
                                                albs.Add(courant);
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    newElements3.Add(t);
                                }
                            }
                            var listAux = new List<Piece>();
                            foreach (var p in newElements3)
                            {
                                listAux.Add(p as Piece);
                            }

                            listAux.Sort(new PieceStackCmp());

                            var aux2 = new List<Piece>(listAux);
                            int nbMove = 0;
                            for (int i = 0; i < aux2.Count; i++)
                            {
                                var p = aux2[i];
                                if (p.InStackPeremption && i < stackBefore)
                                {
                                    var indexN = stackBefore + nbMove;
                                    listAux.Remove(p);
                                    if (indexN < listAux.Count)
                                        listAux.Insert(indexN, p);
                                    else
                                        listAux.Add(p);
                                    nbMove++;
                                }
                            }

                            newElements3 = new HashList<IFile>();
                            albs.Clear();
                            foreach (Piece p in listAux)
                            {
                                if (p.InStackPeremption || p.InStackSize)
                                    moved.Add(p.PieceAlbum.Next.MasterId);

                                newElements3.Add(p);

                                if (p.PieceAlbum != null)
                                    albs.Add(p.PieceAlbum);
                            }


                            for (int i = 0; i < count; i++)
                            {
                                var t = newElements[i] as Piece;
                                var alb_ = t.PieceAlbum;
                                if (alb_ == null)
                                    continue;

                                if (!albs.Contains(alb_))
                                    newElements3.Add(t);
                                //if (alb_ != alb && alb_ != alb2 && alb_ != alb3 && alb_ != alb4)
                                //    newElements3.Add(t);
                            }
                        }
                        else
                            newElements3 = newElements;

                        allTracks.setNbAlbum(unavailable.Count, empeached.Count, moved.Count);



                    }
                    else
                    {
                        allTracks.setNbAlbum(-1, -1, -1);
                    }




                    var newElements2 = new List<IFile>(newElements3);
                    List<Piece> stackSorted = null;
                    //if (checkStack)
                    //{
                    stackSorted = new List<Piece>();
                    foreach (IFile iFile in newElements2)
                    {
                        //var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        //if (t != null)
                        //{
                        stackSorted.Add(iFile as Piece);
                        // }
                    }

                    stackSorted.Sort(new PieceStackCmp());

                    //}
                    foreach (IFile iFile in newElements3)
                    {
                        var keep = newElt[iFile.PieceId];
                        var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        if (t != null)
                        {
                            if (true == keep)
                            {
                                int index0 = t.Index - 1;
                                int index1 = newElements2.IndexOf(iFile);
                                if (index1 > index0)
                                {
                                    newElements2.Remove(iFile);
                                    insert(t, newElements2);
                                }

                                //if (checkStack)
                                //{
                                int index20 = t.Index2 - 1;
                                int index21 = stackSorted.IndexOf(t.PieceGen);
                                if (index21 > index20)
                                {
                                    stackSorted.Remove(t.PieceGen);
                                    insert2(t, stackSorted);
                                }
                                // }
                            }

                        }
                    }

                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert(k, newElements2);
                    }

                    //if (checkStack)
                    //{
                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert2(k, stackSorted);
                    }
                    // }

                    if (indexAlbumOrg >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            var ifile = newElements2[i] as Piece;
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {

                                newElements2.Remove(currentFile);
                                newElements2.Insert(newIndex, currentFile);
                            }
                        }
                    }



                    if (indexAlbumOrg2 >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var ifile = stackSorted[i];
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg2)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = stackSorted.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {
                                stackSorted.Remove(currentFile);
                                stackSorted.Insert(newIndex, currentFile);
                            }
                        }

                    }




                    int index = 1;
                    var rankMax = 0;
                    for (int i = 0; i < newElements3.Count; i++)
                    {
                        var ifile = newElements2[i];

                        var t = Get(ifile); // TrackListViewModel.get(ifile.PieceId); // findTrack(this, ifile.PieceId);
                        if (t == null)
                        {
                            App.log.log("file ID {0} non trouvé dans {1} {2}", ifile.PieceId, this, ifile.Location);

                        }
                        else
                        {
                            if (isMe)
                            {
                                var rank = t.RankAlbum;
                                if (rank > rankMax)
                                    rankMax = rank;


                                //var keep = newElt[ifile.PieceId];
                                //if (true != keep)
                                t.Index = index;

                                // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                                if (i == 0)
                                {
                                    t.refresh();
                                    // var g = t.Grouping; 
                                }
                            }
                        }
                        index++;
                    }

                    if (isMe)
                        Albums.RankZero = rankMax + 1;

                    //if (checkStack)
                    //{
                    index = 1;
                    for (int i = 0; i < stackSorted.Count; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;

                        //var keep = newElt[ifile.PieceId];
                        //if (true != keep)
                        t.Index2 = index;
                        // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                        if (i == 0)
                        {
                            t.refresh();
                            // var g = t.Grouping; 
                        }

                        index++;
                    }
                    // }

                    if (current != null && current.Index > 1)
                    {
                        App.log.log("le courant a l'index {0} {1}", current.Index, current);

                        int index1 = -1;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            if (newElements[i].PieceId == current.PieceId) { index1 = i; break; }
                        }

                        int index2 = -1;
                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            if (newElements2[i].PieceId == current.PieceId) { index2 = i; break; }
                        }

                        int index3 = -1;
                        for (int i = 0; i < newElements3.Count; i++)
                        {
                            if (newElements3[i].PieceId == current.PieceId) { index3 = i; break; }
                        }
                        App.log.log("indexes {0} {1} {2}", index1, index2, index3);

                    }

                    #region c'est bien mais un peu luxueux et ça casse le dont touch

                    /*
                    var hsf = new HashSet<int>();
                    var lf = new List<TrackListViewModel>();


                    var max = 0m;
                    for (int i = 0; i < newElements2.Count && i < stackBefore; i++)
                    {
                        var ifile = newElements2[i];
                        var t = Get(ifile);
                        if (t == null)
                            continue;
                        if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                            continue;
                        if (hsf.Add(t.PieceId))
                        {
                            lf.Add(t);
                            max = t.ClassementValueLight;
                        }
                    }


                    for (int i = 0; i < stackSorted.Count && i < stackBefore; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;
                        if (!hsf.Contains(t.PieceId))
                        {
                            if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                                continue;
                            if (t.ClassementValueLightSt > max)
                                continue;
                            hsf.Add(t.PieceId);
                            lf.Add(t);
                        }
                    }

                    lf.Sort((x, y) =>
                    {
                        var xx = x.ClassementValueLightSt > max ? x.ClassementValueLight : x.ClassementValueLightSt;
                        var yy = y.ClassementValueLightSt > max ? y.ClassementValueLight : y.ClassementValueLightSt;
                        return xx.CompareTo(yy);
                    });

                    for (int i = 0; i < lf.Count; i++)
                    {
                        lf[i].Index = i + 1;
                    }
                    */
                    #endregion




                    //if (limitList > 0)
                    //{
                    //    toAdd.Clear();
                    //    toDelete.Clear();
                    //    bool onlyNext = App.gen.FilterNext;
                    //    var list = new List<TrackListViewModel>();
                    //    foreach (IFile p in newElements3)
                    //    {
                    //        var t = Get(p); // TrackListViewModel.get(p.PieceId);
                    //        if (onlyNext && !t.PieceGen.IsNext)
                    //            continue;
                    //        list.Add(t);
                    //    }
                    //    list.Sort((x, y) => x.Index.CompareTo(y.Index));
                    //    if (list.Count > limitList)
                    //    {
                    //        list = list.GetRange(0, limitList);
                    //    }

                    //    var hs = new HashSet<int>();
                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        hs.Add(t.PieceId);
                    //    }

                    //    var hsNew = new HashSet<int>();
                    //    foreach (TrackListViewModel t in list)
                    //    {
                    //        hsNew.Add(t.PieceId);
                    //        if (!hs.Contains(t.PieceId))
                    //        {
                    //            toAdd.Add(t);
                    //        }
                    //    }

                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        if (!hsNew.Contains(t.PieceId))
                    //        {
                    //            toDelete.Add(t);
                    //        }
                    //    }


                    //    foreach (TrackListViewModel vm in toAdd)
                    //    {
                    //        if (writer.Aborted) return;

                    //        AddTrack(vm, false);
                    //    }

                    //    foreach (TrackListViewModel vm in toDelete)
                    //    {
                    //        if (writer.Aborted) return;
                    //        RemoveTrack(vm, false);
                    //    }
                    //}
                }

                //if (toAdd.Count > 0 || toDelete.Count > 0)
                //{
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                //if (alltracksFather != null)
                //    alltracksFather.refresh();
                //if (alltracksFatherDisabled != null)
                //    alltracksFatherDisabled.refresh();

                //}
                //filterNext = PlayerViewModel.Instance.FilterNext; 
            }
        }

        //private class StackCmp : IComparer<TrackListViewModel>
        //{
        //    public int Compare(TrackListViewModel x, TrackListViewModel y)
        //    {
        //        int cmp = x.ClassementValueLightSt.CompareTo(y.ClassementValueLightSt);
        //        //if (x.StackValue > 0 && y.StackValue > 0)
        //        //    cmp = 
        //        //else
        //        //    cmp = x.Index.CompareTo(y.Index);
        //        if (cmp != 0)
        //            return cmp;
        //        return x.Index.CompareTo(y.Index);
        //    }
        //}

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }

#if EXPORT
        public string getEmpreinte()
        {
            var sb = new StringBuilder();
            sb.Append(exportTracks.Count);
            sb.Append(" éléments:");
            long hash = 0;
            foreach (TrackListViewModel t in exportTracks)
            {
                hash += t.PieceId.GetHashCode();
            }
            sb.Append(hash);

            return sb.ToString();

        }
#endif
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;

namespace pdb.podcast.Load
{
    class Albums : IEnumerable<FeedLimitItemLoader>
    {
        DirConf dir;
        public Albums(DirConf dir)
        {
            this.dir = dir;
        }

        private Dictionary<string, FeedLimitItemLoader> dict = new Dictionary<string, FeedLimitItemLoader>();
        public FeedLimitItemLoader Get(TrackInfoItunes track)
        {
            var key = track.TrackAlbum.AlbumKey;
            if (!dict.ContainsKey(key))
            {
                var fd = new FeedLimitItemLoader(track.TrackAlbum);
                dict.Add(key, fd);
                return fd;
            }

            return dict[key];
        }
        public void Clear()
        {
            foreach (FeedLimitItemLoader fd in dict.Values)
            {
                fd.reset();
            }
        }

        public void Fill(Albums main)
        {
            foreach (FeedLimitItemLoader fdMain in main.dict.Values)
            {
                FeedLimitItemLoader fd = null;
                var album = fdMain.album;
                var key = album.AlbumKey;
                if (!dict.ContainsKey(key))
                {
                    fd = new FeedLimitItemLoader(album);
                    dict.Add(key, fd);
                }
                else 
                    fd = dict[key];

                fd.fill(fdMain); 
            }
        }

        public IEnumerator<FeedLimitItemLoader> GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        public override string ToString()
        {
            return dir.ToString();
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using timeSpan = pdb.util.timeSpan;
using pdb.podcast.Albums;

namespace pdb.podcast.Load
{

    //public enum loadState
    //{
    //    loadCandidat,
    //    standAlone,
    //    selection,
    //    end
    //}
    //public enum depotType
    //{
    //    load,
    //    rapporte
    //}
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        // private loadState state;
        ///// <summary>
        ///// Répertoire
        ///// </summary>
        //private DirConf dir;
        ///// <summary>
        ///// Limite
        ///// </summary>
        // public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        public readonly TrackAlbum album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
       // private LimitsLoader parent;


        ///// <summary>
        ///// Nombre de piste max
        ///// </summary>
        //int nbMax;
        //int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        //timeSpan durationMax;
        //timeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        //private Logger logLimit;
        //private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtuel = new timeSpan();
        timeSpan durationStop = new timeSpan();

        //  BgDict<int, TrackInfoItunes> list = new BgDict<int, TrackInfoItunes>();
        BgDict<int, TrackInfoItunes> selected = new BgDict<int, TrackInfoItunes>();

        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;
        int nbp = 0;
        //   int nbVirtuel = 0;
        //  int nbStop = 0;

        //private bool? endByFd;
        //public bool EndByFd { get { if (endByFd == null) return false; return endByFd.Value; } }

        //private bool _okFd; public bool OkFd { get { return _okFd; } }
        //private bool _okNb; public bool OkNb { get { return _okNb; } }


        //private int _indexv = -1;
        //private int _index = -1;

        //public int Index { get { return _index;  } }
        //public int IndexV { get { return _indexv; } }
        //  public List<TrackInfoItunes> Candidats { get { return candidats;  } }

        #region refonte
        Contribution virt = new Contribution();
        Contribution current = new Contribution();

        // int count;
        //private TrackInfoItunes _nextCandidat;
        //private List<TrackInfoItunes> candidats = new List<TrackInfoItunes>();
        //  private Contribution dict = new Contribution(); 
        //public void AddCandidat(TrackInfoItunes track)
        //{
        //    candidats.Add(track);
        //    count++;
        //}
        // public int NbV { get { return virt.Nb; } }
        // public timeSpan FdV { get { return virt.Duree;  } }
        /// <summary>
        /// Donne les valeurs min pour ajouter un track à partir de valeurs de base
        /// </summary>
        /// <param name="nb"></param>
        /// <param name="fd"></param>
        //public void checkV(int nb, timeSpan fd)
        //{
        //    //nb > _nbv && fd > _fdv
        //    // 1-> je sors nb=1 fd=5 > retenu par exemple nb=0 fd = 5 ridicule mais c'est comme ça
        //    // step fait un check(0,5) qui ne renvoie rien
        //    // 2-> check (0,5 ) ? je fais pas indev++ car j'ai déja 5
        //    //0/0   1/5    2/11    3/16
        //    // |-----|------|-------|-->
        //    // debut

        //    while (true)
        //    {
        //        if (virt.Nb > nb)
        //            break;
        //        if (virt.Duree > fd)
        //            break; 
        //        _indexv++;
        //        if (_indexv >= count)
        //            break;
        //        _nextCandidat = candidats[_indexv];
        //        virt.add(_nextCandidat); 
        //    }

        //}

        //public void reservation(int nb, timeSpan fd)
        //{
        //    while (true)
        //    {

        //    }
        //}

        #endregion
        //public FeedLimitLoaderState getNext(FeedLimitLoaderState current)
        //{
        //    int i = index + 1;
        //    if (i >= candidats.Count)
        //        return null;
        //    var track = candidats[i]; 
        //    var _nb = nb + 1;
        //    var _fd = currentDuration + track.Duree;

        //    var ret = new FeedLimitLoaderState() { track = track }(); 
        //    if (_nb > current.nb)
        //        ret.
        //}

        public void phase2()
        {
            reset();
            //  state = loadState.selection; 
        }

        public void reset()
        {
            currentDuration = new timeSpan();
            currentDurationVirtuel = new timeSpan();
            durationStop = new timeSpan();
            nb = 0; nbp = 0;
            //nbVirtuel = 0;
            //nbStop = 0;
            //  state = loadState.standAlone;
            //endByFd = null;
            //  list.Clear();
            selected.Clear();
        }

        public void fill(FeedLimitItemLoader main)
        {
            foreach (TrackInfoItunes t in main.selected.Values)
            {
                record(t);
            }
        }


        //private bool loadEqSel;
        //public bool LoadEqSel { get { return loadEqSel; } }

        public FeedLimitItemLoader(TrackAlbum album)
        {
            //this.dir = limit.Dir;
            //this.limit = limit;

            //this.parent = parent;
            this.album = album;


            //  nbMax = limit.Nb;


            //  var feedDuration = limit.FeedDuration;
            //  int rating = limit.Rating;
            ////  durationMax = timeSpan.FromMinutes(feedDuration);


            //  loadDurationMax = durationMax;
            //  loadNbMax = nbMax;

            //  bool loadEqSeld = true;
            //  bool loadEqSeln = true;

            //  //if (limit.Dir.Cascading)
            //  //{
            //  if (limit.LoadNb > nbMax)
            //  {
            //      loadNbMax = limit.LoadNb;
            //      loadEqSeln = false;
            //  }
            //  if (limit.LoadFeedDuration > feedDuration)
            //  {
            //      loadDurationMax = timeSpan.FromMinutes(limit.LoadFeedDuration);
            //      loadEqSeld = false;
            //  }

            //  //}
            //  if (loadEqSeln)
            //      loadNbMax++;
            //  if (loadEqSeld)
            //      loadDurationMax = timeSpan.FromMinutes(loadDurationMax.TotalMinute + 200);

            //  //logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            //logLimit = limit.Logger;
        }

        //private void log(string txt)
        //{
        //    logLimit.log(txt);
        //    logItem.log(txt);
        //}

        //private void log(string txt, params object[] other)
        //{

        //    logLimit.log(txt, other);
        //    logItem.log(txt, other);
        //}




        public timeSpan getCurrentDuration(bool real)
        {
            if (real)
                return currentDuration;
            return currentDurationVirtuel;
        }

        public timeSpan getDurationStop(bool real)
        {
            if (durationStop.Value == 0)
                return getCurrentDuration(real);
            return durationStop;
        }

        //public int getNb(bool real)
        //{

        //    if (real)
        //        return nb;
        //    return nbVirtuel;
        //}
        //public int getNbStop(bool real)
        //{
        //    if (nbStop == 0)
        //        return getNb(real);
        //    return nbStop;
        //}

        public int Nb { get { return nb; } }
        public int Nbp { get { return nbp; } }
        public timeSpan fd { get { return currentDuration; } }


        public void record(TrackInfoItunes track)
        {
            if (selected.ContainsKey(track.DbId))
                return;
            selected.Add(track.DbId, track);
            if (track.isConcernedBySelection)
                nbp++;
            else
                nb++;
            currentDuration += track.Duree;
        }



        public bool isSelected(TrackInfoItunes track)
        {
            return selected.ContainsKey(track.DbId);
        }


        //public bool control(bool load, LimitItem limit, TrackInfoItunes track)
        //{
        //    if (isSelected(track))
        //        return true;

        //    var _nb = nb + 1;
        //    var _dura = currentDuration + track.Duree; 

        //      var conf = album.ConfAlbum; 

        //    int _nbMax =  limit.getNb(load, conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
        //    var __durationMax = limit.getFd(load, conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
        //    var _durationMax = timeSpan.FromMinutes(__durationMax);

        //    if (_nb > _nbMax)
        //        return false;
        //    if (_dura > _durationMax)
        //        return false;
        //    return true; 

        //}

        //public bool control(LimitsLoader parent, LimitItem limit,TrackInfoItunes track, bool select, bool load, bool real, bool increment)
        //{
        //    //if (state == loadState.end)
        //    //    return false;
        //    if (selected.ContainsKey(track.DbId))
        //        return true; 

        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return false;



        //    //     string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
        //   // string phase = select ? "ctl" : "load";

        //    //if (!Logger.CreateNullLoggers)
        //    //{
        //    //    string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration, track.ToString());

        //    //    log("-->  {0} ok {1} ", phase, str);
        //    //}

        //    var ok = checkStatus(limit,  load, track, limit, real, increment);

        //    if (!ok)
        //        return false;

        //    if (select && real && LimitItemLoader.ModeSelection)
        //    {
        //       // var selected = selectMode.simple;
        //        //if (dir.Histo)
        //        //{
        //        //    selected = selectMode.serial;
        //        //    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
        //        //        selected = selectMode.histo;
        //        //    if (dir.Serial)
        //        //        selected = selectMode.serial;
        //        //}
        //        //else
        //        //{
        //        //    //if (!candidat.Serial && !candidat.Histo)
        //        //    selected = selectMode.simple;
        //        //}

        //        track.select(selectMode.simple, limit);
        //        limit.Dir.Feeds.recordTrack(track, limit);
        //    }

        //    //report aux niveaux inférieurs
        //    //if (real)
        //    //    parent.recordLimitItemCandidat(track, limit);
        //    return true;
        //}




        //private bool checkStatus_(LimitItem limit,bool load, TrackInfoItunes track, LimitItem itemSource, bool real, bool increment)
        //{
        //    endByFd = null;
        //    _okFd = true;
        //    _okNb = true;
        //    bool ret = true;
        //    //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
        //    nbVirtuel = nb;
        //    currentDurationVirtuel = currentDuration;
        //    var nbBase = real ? nb : nbVirtuel;

        //    var _nb = nbBase + 1;
        //  //  var durationBase =   real ? currentDuration : currentDurationVirtuel;
        // //   var dur = durationBase + track.Duree;

        //    var conf = album.ConfAlbum; 

        //    int _nbMax =  limit.getNb(load, conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
        //    var __durationMax = limit.getFd(load, conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
        //    var _durationMax = timeSpan.FromMinutes(__durationMax); 

        //    bool justStopped = false; 

        //    if (_nb > _nbMax)
        //    {
        //        _okNb = false;
        //        if (real)
        //        {
        //            if (LimitItemLoader.ModeSelection)
        //                limit.NbFeedLimit = true;
        //            //if (!Logger.CreateNullLoggers)
        //            //{
        //            //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
        //            //    log("{0} stop nb {1} ", phase, str);
        //            //}
        //            if (state != loadState.end || justStopped)
        //            {
        //                justStopped = true; 
        //                state = loadState.end;
        //                nbStop = _nb;
        //            }
        //        }

        //        endByFd = false;
        //        ret = false;
        //    }



        //    // vérification des valeurs cumulées
        //    if (currentDuration > _durationMax)
        //    {
        //        _okFd = false;
        //        if (real)
        //        {

        //            //if (!limit.DurationFeedLimit)
        //            //{
        //            //    //if (!Logger.CreateNullLoggers)
        //            //    //{
        //            //    //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
        //            //    //    log("{0} stop d. {1} ", phase, str);
        //            //    //}
        //            //}
        //            if (LimitItemLoader.ModeSelection)
        //                limit.DurationFeedLimit = true;
        //            if (state != loadState.end || justStopped)
        //            {
        //                justStopped = true; 
        //                state = loadState.end;
        //                durationStop = currentDuration;
        //            }

        //        }

        //        //if (select || durationMax == loadDurationMax)
        //        //{
        //        //    if (ret)
        //        //    {
        //        //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
        //        //        limit.signal(tb);
        //        //    }
        //        //    //limit.checkBorderFd(track, dur, false);
        //        //}

        //        if (endByFd == null)
        //            endByFd = true;
        //        ret = false;
        //    }
        //    else
        //    {
        //        // endByFd = null;
        //        //if (select || durationMax == loadDurationMax)
        //        //{
        //        //    if (ret)
        //        //    {
        //        //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
        //        //        limit.signal(tb);
        //        //    }
        //        //}
        //    }






        //    if (increment)
        //    {
        //        if (real)
        //        {
        //            nb += 1;
        //            currentDuration += track.Duree;
        //        }

        //        //currentDurationVirtuel += track.Duree;
        //        nbVirtuel += 1;
        //    }
        //    return ret;

        //}


        //private bool checkStatus(LimitItem limit, bool load, TrackInfoItunes track, LimitItem itemSource, bool real, bool increment)
        //{
        //    endByFd = null;
        //    _okFd = true;
        //    _okNb = true;
        //    bool ret = true;
        //    //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
        //    nbVirtuel = nb;
        //    currentDurationVirtuel = currentDuration;
        //    var nbBase = real ? nb : nbVirtuel;

        //    var _nb = nbBase + 1;
        //    //  var durationBase =   real ? currentDuration : currentDurationVirtuel;
        //    //   var dur = durationBase + track.Duree;

        //    var conf = album.ConfAlbum;

        //    int _nbMax = limit.getNb(load, conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
        //    var __durationMax = limit.getFd(load, conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
        //    var _durationMax = timeSpan.FromMinutes(__durationMax);

        //    bool justStopped = false;

        //    if (_nb > _nbMax)
        //    {
        //        _okNb = false;
        //        if (real)
        //        {
        //            if (LimitItemLoader.ModeSelection)
        //                limit.NbFeedLimit = true;
        //            //if (!Logger.CreateNullLoggers)
        //            //{
        //            //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
        //            //    log("{0} stop nb {1} ", phase, str);
        //            //}
        //            if (state != loadState.end || justStopped)
        //            {
        //                justStopped = true;
        //                state = loadState.end;
        //                nbStop = _nb;
        //            }
        //        }

        //        endByFd = false;
        //        ret = false;
        //    }



        //    // vérification des valeurs cumulées
        //    if (currentDuration > _durationMax)
        //    {
        //        _okFd = false;
        //        if (real)
        //        {

        //            //if (!limit.DurationFeedLimit)
        //            //{
        //            //    //if (!Logger.CreateNullLoggers)
        //            //    //{
        //            //    //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
        //            //    //    log("{0} stop d. {1} ", phase, str);
        //            //    //}
        //            //}
        //            if (LimitItemLoader.ModeSelection)
        //                limit.DurationFeedLimit = true;
        //            if (state != loadState.end || justStopped)
        //            {
        //                justStopped = true;
        //                state = loadState.end;
        //                durationStop = currentDuration;
        //            }

        //        }

        //        //if (select || durationMax == loadDurationMax)
        //        //{
        //        //    if (ret)
        //        //    {
        //        //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
        //        //        limit.signal(tb);
        //        //    }
        //        //    //limit.checkBorderFd(track, dur, false);
        //        //}

        //        if (endByFd == null)
        //            endByFd = true;
        //        ret = false;
        //    }
        //    else
        //    {
        //        // endByFd = null;
        //        //if (select || durationMax == loadDurationMax)
        //        //{
        //        //    if (ret)
        //        //    {
        //        //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
        //        //        limit.signal(tb);
        //        //    }
        //        //}
        //    }






        //    if (increment)
        //    {
        //        if (real)
        //        {
        //            nb += 1;
        //            currentDuration += track.Duree;
        //        }

        //        //currentDurationVirtuel += track.Duree;
        //        nbVirtuel += 1;
        //    }
        //    return ret;

        //}

        public override string ToString()
        {
            return string.Format("{0}", album);
        }

    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\FeedsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;

namespace pdb.podcast.Load
{
    public enum action
    {
        none,
        loadCandidat,
        resort,
        //standAlone,
        phase2,
        selectionPre,
        selectionPost,
        writeLists,
        // freewheel,
        writeTracksPre,
        writeTracksPost
    }
    /// <summary>
    /// Chargeur de répertoire
    /// </summary>
    public class FeedsLoader
    {
        /// <summary>
        /// Registre des albums
        /// </summary>
        private Feeds feeds;
        /// <summary>
        /// Répertoire considéré
        /// </summary>
        private DirConf dir;


        private LimitsLoader limitsLoader;
        //  private Logger log;



        public FeedsLoader(DirConf dir)
        {
            this.feeds = dir.Feeds;
            this.dir = dir;
            limitsLoader = new LimitsLoader(dir);
            //   log = Logger.getLogger(dir.getPath() + "\\dir", false); 
        }

        public void init(DirConf dir)
        {
            this.feeds = dir.Feeds;
            this.dir = dir;
            limitsLoader.init(dir);
        }



        private Albums albums;
        private Albums albumsReserve;

        internal Albums Albums
        {
            get
            {
                if (albums != null)
                    return albums;
                var parent = dir.Parent;
                if (parent == null)
                    throw new ArgumentException();
                if (parent.Parent == null)
                {
                    albums = new Albums(dir);
                    return albums;
                }
                albums = parent.Loader.Albums;
                return albums;

            }
            //set
            //{
            //    albums = value; 
            //}
        }

        internal Albums AlbumsReserve
        {
            get
            {
                if (albumsReserve != null)
                    return albumsReserve;
                var parent = dir.Parent;
                if (parent == null)
                    throw new ArgumentException();
                if (parent.Parent == null)
                {
                    albumsReserve = new Albums(dir);
                    return albumsReserve;
                }
                albumsReserve = parent.Loader.AlbumsReserve;
                return albumsReserve;
            }
        }

        public LimitsLoader LimitsLoader { get { return limitsLoader; } }


        public void Action(action action)
        {
            switch (action)
            {
                case action.loadCandidat: //log.log("{0} Récupération des candidats", dir);
                limitsLoader.loadCandidats();
                break;
                case action.resort: limitsLoader.resetLoad(); break;
                // case Load.action.standAlone: standAlone(); break;
                case action.phase2: limitsLoader.phase2(); break;
                case action.selectionPre: limitsLoader.SelectionPre(); break;
                case action.selectionPost: limitsLoader.SelectionPost(); break;
                case action.writeLists: limitsLoader.WriteLists(); break;
                //case action.freewheel: limitsLoader.Freewheel(); break;
                case action.writeTracksPre: limitsLoader.WriteTracksPre(); break;
                case action.writeTracksPost: limitsLoader.WriteTracksPost(); break;
                default:
                break;
            }
        }



        ///// <summary>
        ///// Constitution de la liste
        ///// </summary>
        //private void LoadCandidats()
        //{
        //    // 1. récupérer les candidat (logique locale Feed (nb, feedDuration...); 
        //    //log.log("****************************************************************************************");
        //    //log.log("Récupération des candidats"); 
        //    //log.log("****************************************************************************************");

        //    log.log( "{0} Récupération des candidats", dir);
        //    limitsLoader.loadCandidats(); 
        //    //string feedName = null;
        //    //bool histo = dir.Histo;
        //    //bool? histoAll = dir.HistoAll;
        //    //if (histo)
        //    //    feedName = dir.Name;

        //    //var logList = new List<TrackInfoItunes>();

        //    //foreach (var feed in feeds)
        //    //{
        //    //    if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))
        //    //    {
        //    //        var feedLoader = getLoader(feed.Name); // new FeedLoader(dir, feed, this, false);
        //    //        feedLoader.loadCandidats();
        //    //    }
        //    //}
        //}



        //private void standAlone()
        //{
        //    log.log("{0} standAlone", dir); 
        //    bool dirHisto = dir.Histo;



        //    for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
        //    {
        //        var limit = dir.Limites[i];
        //        foreach (LimitItem item in limit.Items)
        //        {
        //            int levelMin = limit.Level;
        //            int ratingMin = levelMin * 20;
        //            int duration = item.Duration;
        //            var DurationMax = TimeSpan.FromMinutes(duration);
        //            TimeSpan currentDuration = new TimeSpan();
        //            //bool durationLimitAtteinte = false;

        //            if (item.Nb == 0 || item.FeedDuration == 0 || item.Duration == 0)
        //                continue;


        //            var _depot = new SequentialDictString<TrackInfoItunes>();
        //            depot(_depot, item, depotType.load);

        //            var list = _depot.List;
        //            if (dirHisto)
        //                list.Sort(new PodCastComparer());
        //            else
        //                list.Sort(new PodCastComparerInv());

        //            foreach (TrackInfoItunes candidat in list)
        //            {
        //                if (candidat.Rating < ratingMin)
        //                    continue;
        //                if (dir.Info.HasValue)
        //                {
        //                    bool bInfo = dir.Info.Value;
        //                    if (candidat.Info != bInfo)
        //                        continue;
        //                }

        //                if (dir.Rare.HasValue)
        //                {
        //                    bool bRare = dir.Rare.Value;
        //                    if (candidat.Rare != bRare)
        //                        continue;
        //                }

        //                if (!control(candidat, item,false))
        //                    continue;

        //                // enregistrement pour stockage et stats
        //              //  dir.recordTrackStandAlone(candidat, item);
        //                currentDuration += candidat.Duration;




        //                candidat.select(selectMode.standAlone, item);

        //                //  feeds.recordTrack(candidat, item);

        //                if (currentDuration > DurationMax)
        //                {
        //                    //if (!durationLimitAtteinte)
        //                    //{
        //                    //Logger.getLogger(dir.getPath() + "\\dir", false).log("duration {0}", (currentDuration + candidat.Duration).TotalMinutes.ToString("0"));
        //                    //item.DurationLimitAtteinte = true;
        //                    //}
        //                    //durationLimitAtteinte = true;
        //                    break;
        //                }

        //            }


        //        }
        //    }
        //}



        //private FeedLoader getLoader(string album)
        //{
        //    var loader = loaders.Find(l => l.feed.Name == album);
        //    if (loader == null)
        //    {
        //        loader = new FeedLoader(dir, feeds[album], this);
        //        loaders.Add(loader);
        //    }
        //    return loader;
        //}

        //private void depot(IDictionary<string, TrackInfoItunes> depot, LimitItem item, depotType type)
        //{
        //    foreach (var loader in loaders)
        //    {
        //        loader.depot(depot, item, type);
        //    }
        //}



        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //   // getLoader(track.Album).recordTrackFromChild(track, itemSource);
        //    limitsLoader.recordTrackFromChild(track, itemSource, transmitTotal); 
        //}




        //private bool control(TrackInfoItunes track, LimitItem item, bool select)
        //{
        //    //var loader = getLoader(track.Album);
        //    //return loader.control(track, item,select);
        //}

        ///// <summary>
        ///// Enregistrement d'un candidat 1ere phase
        ///// </summary>
        ///// <param name="track"></param>
        //public void recordCandidat(TrackInfoItunes track)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    if (!dict.ContainsKey(location))
        //    {
        //        dict.Add(location, track);
        //    }
        //}

    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        //  private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        //private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        static ContexteBuilder context = ContexteBuilder.Instance;


        private List<TrackInfoItunes> candidats = new List<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;


        private static bool _checkExists;
        public static bool CheckExists { set { _checkExists = value; } }


        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            init(parent, limit);
        }

        public void init(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        //public timeSpan _durationv;
        //public timeSpan _datev;
        //private timeSpan _fd;
        //public timeSpan Fd { get { return _fd; } }

        public int _nb;

        //public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        //{
        //    BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

        //    int nbMin = int.MaxValue;
        //    timeSpan fdMin = timeSpan.MaxValue;
        //    timeSpan dMin = timeSpan.MaxValue;
        //    timeSpan dateMin = timeSpan.MaxValue;
        //    foreach (FeedLimitItemLoader loader in loaders.Values)
        //    {
        //        loader.checkV(nb, fd);
        //        var _nb = loader.NbV;
        //        var _fd = loader.FdV;
        //        if (_nb > nb && _nb < nbMin)
        //            nbMin = _nb;
        //        if (_fd > fd && fd < fdMin)
        //            fdMin = _fd;
        //        for (int i = 0; i <= loader.IndexV; i++)
        //        {
        //            var track = loader.Candidats[i];
        //            if (dict.ContainsKey(track.Location))
        //                continue;
        //            var _d = currentDuration + track.Duree;
        //            if (_d > d && d < dMin)
        //                dMin = _d;
        //            var _date = track.Ts;
        //            if (_date > date && _date < dateMin)
        //                dateMin = _date;
        //            break;
        //        }



        //    }

        //    this._durationv = dMin;
        //    this._datev = dateMin;
        //    this._nb = nbMin;
        //    this._fd = fdMin;
        //}



        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 && limit.Nbp == 0)
                return;
            if (limit.Dir.Name == "RFI - Une semaine d'actualité")
            {
            }
            //if (!limit.OverwriteConf && limit.Nb2 == 0)
            //    return;
            candidats.Clear();

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                //var location = candidat.Location;
                //if (string.IsNullOrEmpty(location))
                //    continue;

                //if (standAlone.ContainsKey(location))
                //    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree >= trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                candidats.Add(candidat);
                //  standAlone.Add(location, candidat);
                Exporter.Record(candidat);


            }

        }




        private FeedLimitItemLoader getLoader(TrackInfoItunes candidat)
        {
            return limit.Dir.Loader.Albums.Get(candidat);
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            //loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            //legacy = new SequentialDictString<TrackInfoItunes>();
            //legacyRelax = new SequentialDictString<TrackInfoItunes>();
            //selected = new SequentialDictString<TrackInfoItunes>();
            //exclu = new SequentialDictString<TrackInfoItunes>();

            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();
            use.Clear();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            //trackDurationMax = new timeSpan();
            //trackDurationMin = new timeSpan();

            //var aux = new List<TrackInfoItunes>(candidats.Count);
            //foreach (TrackInfoItunes track in candidats)
            //{
            //    var copy = TrackInfoItunes.createCopy(track);
            //    aux.Add(copy);
            //}

            //candidats = aux; 
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in limit.Dir.Loader.Albums)
                loader.phase2();
            foreach (FeedLimitItemLoader loader in limit.Dir.Loader.AlbumsReserve)
                loader.phase2();
        }

        //public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        //{
        //    if (itemSource == limit)
        //        return;
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    bool transmitTotal = limit.Dir.TransmitTotalGuest;
        //    //if (transmitTotal && legacy.ContainsKey(location))
        //    //    return;
        //    //if (!transmitTotal && legacyRelax.ContainsKey(location))
        //    //    return;


        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {

        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    if (transmitTotal && legacy.ContainsKey(location))
        //        return;
        //    if (!transmitTotal && legacyRelax.ContainsKey(location))
        //        return;
        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {
        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);

        //    }
        //}



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 && limit.Nbp == 0)
                return;

            //  var histo = limit.Dir.Histo;

            //var relax = legacyRelax.List;
            //if (relax.Count > 0)
            //{
            //    if (histo)
            //        relax.Sort(new PodCastComparerPub2());
            //    else
            //        relax.Sort(new PodCastComparerInv());
            //    selection(relax, false, false);
            //}

            //var list = legacy.List;
            //if (list.Count > 0)
            //{
            //    if (histo)
            //        list.Sort(new PodCastComparerPub2());
            //    else
            //        list.Sort(new PodCastComparerInv());
            //    selection(list, false, true);
            //}

            if (candidats.Count > 0)
            {
                selection(candidats);
            }



            //var list2 = standAlone.List;
            //if (list2.Count > 0)
            //{
            //    //if (histo)
            //    //    list2.Sort(new PodCastComparerPub2());
            //    //else
            //    //    list2.Sort(new PodCastComparerInv());

            //    selection(list2); //, true, true);
            //}

        }


        private class FdResponse
        {
            public int nb;
            // public int nbp;
            public timeSpan duree;
            public bool okFd;
            public bool okNb;
            // public bool okNbp;
            public bool Result { get { return okFd && okNb; } }
            //  public bool OnlyFd { get { return okFd && !okNb; } }


        }

        FdResponse check(FeedLimitItemLoader loader, TrackInfoItunes candidat, bool isConcernedBySelection, LimitItem limit)
        {
            var response = new FdResponse();

            var _nb = isConcernedBySelection ? loader.Nbp : loader.Nb;


            if (!loader.isSelected(candidat))
            {
                _nb++;
            }

            response.nb = _nb;
            response.duree = loader.fd;

            var conf = loader.album.ConfAlbum;

            int _nbMax = isConcernedBySelection ? limit.Nbp : limit.Nb; //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));

            var nb2 = isConcernedBySelection ? limit.NbpMax : limit.NbMax;

            if (isConcernedBySelection && conf.NbpMax < int.MaxValue)
            {
                if (!limit.overWriteNbpMax)
                    nb2 = conf.NbpMax;
            }

            if (nb2 < _nbMax)
                _nbMax = nb2;

            //  var __durationMax = limit.getFd(conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
            var _durationMax = limit.Fd;  //timeSpan.FromMinutes(__durationMax);

            response.okNb = _nb <= _nbMax;
            response.okFd = response.duree <= _durationMax;

            if (isConcernedBySelection && context.Enabled)
            {
                if (!response.Result)
                {
                    if (response.okFd)
                    {
                        if (_nb <= nb2)
                        {
                            if (context.accept(candidat, _nb))
                            {
                                response.okNb = true;
                                // response.okFd = true;
                            }
                        }
                    }
                    else
                    {
                    }
                    //if (_nb <= context.Nb)
                    //{
                    //    if (context.accept(candidat))
                    //        response.okNb = true;
                    //}
                    //else
                    //    context.checkFin(candidat);
                }
            }




            return response;

        }

        private void selection(List<TrackInfoItunes> list)
        {
            if (limit.Dir.Name == "RFI - Une semaine d'actualité")
            {
            }
            bool checkExist = _checkExists && !limit.Dir.Histo && (limit.Dir.selectParams == null && limit.Dir.selectParams.Count == 0);
            var dtAutoMAwx = Conf.Date0.AddDays(limit.Dir.getMaxDateAuto());
            var duration = limit.getDuration();

            var durationMax = timeSpan.FromMinutes(duration);

            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {

                TrackInfoItunes candidat = list[index];

                //if (candidat.Album == "LA GRANDE TABLE 1ère partie")
                //{
                //}
                //if (candidat.Album == "SI TU NE VAS PAS A RIO")
                //{
                //}
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (checkExist && !FileRegister.ExistNow(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.getDate(); // candidat.TrackAlbum.ConfAlbum.checkPub ? candidat.Pub : candidat.Pub2;

                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                if (okDate)
                {
                }
                var loader = getLoader(candidat);



                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                // okTotalDuration = currentDuration <= durationMax;

                //  bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                FdResponse response = null;
                //if (!increment) // données venant de sous-dossier (histo, voisins....)
                //{
                //    response = check(loader, candidat, limit);
                //    _control = response == null || response.Result;
                //    //  _control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);
                //    //if (_control && !selectedByFd.ContainsKey(location))
                //    //    selectedByFd.Add(location, candidat);
                //    //if (!manageByFd.ContainsKey(location))
                //    //    manageByFd.Add(location, candidat);
                //}



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;


                var newDuration = currentDuration + candidat.Duree;
                var oldDuration = currentDuration;
                bool okTotalDuration = newDuration <= durationMax;
                //if (manageByFd.ContainsKey(location))
                //{
                //    _control = false;
                //    if (selectedByFd.ContainsKey(location))
                //        _control = true;
                //}
                //else
                //{
                bool isConcernedBySelection = candidat.isConcernedBySelection;
                response = check(loader, candidat, isConcernedBySelection, limit);
                bool _control = response == null || response.Result;
                //_control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);

                //}

                if (_control)
                {
                    //currentDurationVirtual += candidat.Duree;
                    if (okDate)
                        currentDuration = newDuration;
                }


                // newDuration = currentDuration;
                //if (_control && !selectedByFd.ContainsKey(location))
                //    selectedByFd.Add(location, candidat);
                //if (!manageByFd.ContainsKey(location))
                //    manageByFd.Add(location, candidat);
                //  okTotalDuration = newDuration <= durationMax;






                bool go = okDate && _control && okTotalDuration;
                if (go)
                {


                    if (_selection)
                    {
                        if (checkExist)
                        {
                            if (!FileRegister.ExistNow(location))
                            {
                                currentDuration = oldDuration;
                                continue;
                            }
                        }
                        candidat.select(selectMode.simple, limit);
                        limit.Dir.Feeds.recordTrack(candidat, limit);
                    }
                    loader.record(candidat);


                    //report aux niveaux inférieurs
                    // if (real)
                    // parent.recordLimitItemCandidat(candidat, limit);
                    // return true;

                }

                if (!_selection)
                {

                    if (limit.canSignal() && response != null)
                    {



                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                                //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                                //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                                //, okTotalDuration, newDuration, candidat, limit);
                                response.okFd, response.duree
                        , response.okNb, response.nb
                        , okTotalDuration, newDuration, candidat, isConcernedBySelection, limit);


                        limit.signal(dataAuto);
                    }

                }

                if (_selection)
                {


                    //newDuration = currentDuration;
                    //okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                        if (true || Conf.AutoSelect)
                            continue;
                        else
                            break;

                    }

                    if (!okDate && limit.Dir.Histo)
                        break;

                    if (!_control || !okDate)
                        continue;





                    if (!newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }



                    // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                    limit.Dir.recordTrack(candidat, limit);



                }
                else
                {
                    if (!okDate && d > dtAutoMAwx)
                        break;
                }

            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Tuning;
using pdb.util;
using System.Collections.Generic;
using System.Xml;
using System;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        //  private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        // public loadState state;
        //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void init(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].init(this, limit[i]);
            }
        }

        //public void getLoaders(List<LimitItemLoader> list)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].getLoaders(list);
        //    }
        //}

        private bool candidatLoaded;
        private bool reload;
        public void resetLoad()
        {
            reload = true;
        }

        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                if (!reload)
                    return;
            }
            try
            {
                List<TrackSelector> t = null;
                var _params = dir.selectParams;
                if (_params != null && _params.Count > 0)
                {
                    t = new List<TrackSelector>();
                    foreach (SelectParamBase p in _params)
                    {
                        t.Add(new TrackSelector(p));
                    }
                }
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool uniqueAlbum = dir.UniqueAlbum;
                if (uniqueAlbum)
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();

                var dateMin = dir.DateMin;
                var dateMax = dir.DateMax;

                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    if (dir.OrderNote || dir.Petit)
                    {
                        if (!track.isPodcast)
                            continue;
                        if (track.Pub < dateMin)
                            continue;
                        if (track.Pub > dateMax)
                            continue;
                        if (!track.isConcernedBySelection)
                            continue;
                    }

                    if (t != null)
                    {
                        if (t.Count == 0)
                        {
                        }
                        else
                        {
                            bool ok = true;
                            bool modeOr = t[0].Param.modeOr;

                            if (modeOr)
                            {
                                ok = false;
                                foreach (TrackSelector tt in t)
                                {
                                    if (tt.selectSimple(track))
                                    {
                                        ok = true;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                foreach (TrackSelector tt in t)
                                {
                                    //modeOr = tt.Param.modeOr;
                                    if (!tt.selectSimple(track))
                                    {
                                        ok = false;
                                        break;
                                    }
                                }
                            }
                            if (!ok)
                                continue;
                        }

                    }

                    loaded.Add(track);
                }

                if (dir.OrderNote)
                {
                    var noteBuilder = dir.NoteBuilder;
                    noteBuilder.build(loaded);
                    noteBuilder.Sort(loaded, histo);
                }
                else
                {
                    if (histo)
                    {
                        loaded.Sort(new PodcastComparerPubPub2());
                        //if (Conf.Albums.checkPub)
                        //    loaded.Sort(new PodCastComparer());
                        //else
                        //    loaded.Sort(new PodCastComparerPub2());
                    }
                    else
                        loaded.Sort(new PodCastComparerInv());
                }


                //   for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                //state = loadState.selection;
                candidatLoaded = true;
                reload = false;
            }
        }

        //private bool recordGuests;
        public void phase2()
        {
            // state = loadState.selection;
            //if (dir.Cascading)
            //    recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        //public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        //{

        //    if (!recordGuests)
        //        return;


        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordGuest(track, item);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
        //    }
        //}


        public void Freewheel()
        {
            if (dir.Parent == null)
            {
                var lfolders = dir.Folders;
                buildListPrior("_auto", null, lfolders);
            }
        }

        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                //var list = dir.getListe();

                //var limits = dir.Limites;
                //var usegenPrior = Conf.GenUsePrior;
                //var exclugenPrior = Conf.GenExcluPrior;

                //for (int i = 0; i < Limits.NB; i++)
                //{
                //    var limit = limites[i];
                //    foreach (LimitItemLoader item in limit.Items)
                //    {
                //        // var index = limit.index(item);
                //        //if (Conf.WriteItems)
                //        //{
                //        //    items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                //        //    buildList(item.Item.ID, items, "_sel");
                //        //}

                //        //if (Conf.WritePreSel)
                //        //{
                //        //    items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                //        //    buildList(item.Item.ID, items, "_sel0");
                //        //}
                //        //if (Conf.WriteUse)
                //        //{
                //        //    items = item.use;
                //        //    buildList(item.Item.ID, usegenPrior, items, "_use");
                //        //}
                //        //if (Conf.WriteExclu)
                //        //{
                //        //    var limite = item.Item;
                //        //    items = item.use.FindAll(t => t.Exclu == limite);
                //        //    buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                //        //}

                //    }
                //}

                //if (dir.Parent == null)
                //{
                var list = dir.getListe();
                var lfolders = dir.Folders;
                if (!string.IsNullOrEmpty(dir.PlayList))
                {
                    buildListPrior(dir.PlayList, list, lfolders);
                }
                else if (dir.Parent == null)
                {

                    var contextB = ContexteBuilder.Instance;

                    if (contextB.Enabled)
                    {

                        var selected = dir.getListe();
                        selected.Sort(new PodCastComparer());

                        contextB.checkZeroPremJournee(selected);

                    }


                    buildListPrior("_auto", list, lfolders);

                    var limitContexte = ContexteBuilder.Instance.LimitWriteList;
                    var listeEnretard = list.FindAll(t => t.Pub2 <= limitContexte && !t.isConcernedBySelection);
                    buildListPrior("_retardG", listeEnretard, lfolders);

                    var listePre = list.FindAll(t => t.Pub2 <= limitContexte && t.isConcernedBySelection);
                    buildListPrior("_autoPre", listePre, lfolders);

                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t);
                        }

                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        //private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        //{
        //    Program.buildList(name, list, folders);
        //}
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders, false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("dt", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                if (track.Note < int.MaxValue)
                    writer.SetAttribute("n", track.Note.ToString("0.##"));
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                {
                    writer.SetAttribute("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.SetAttribute("e", (track.Pub2 - track.Pub).TotalDays.ToString("0.#"));
                }
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion

            #region long
            writer.StartElement("longs");

            var longs = items.FindAll(t => !t.isConcernedBySelection);
            writeTrackList(longs, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (!dir.UniqueAlbum)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    try
                    {
                        writer.StartElement("i");
                        writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                        var sb = new StringBuilder();
                        lim.writeStatHeader(sb);
                        lim.Stat.Total.buildValues(sb);
                        writer.SetAttribute("stats", sb.ToString());

                        writeTracks(dir, lim.Stat, null, false);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }

                    finally
                    {
                        writer.EndElement();
                    }
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {
            if (dir.ResetBefore)
            {
                dir.Loader.AlbumsReserve.Fill(dir.Loader.Albums);
                dir.Loader.Albums.Clear();
            }

            //log.log("{0} Selection", dir);

            //for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                limit.Selection();

            }
            if (dir.ResetAfter)
            {
                dir.Loader.AlbumsReserve.Fill(dir.Loader.Albums);
                dir.Loader.Albums.Clear();
            }
            else if (dir.Fill)
                dir.Loader.Albums.Fill(dir.Loader.AlbumsReserve);

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="db4\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private XmlElement xDir;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private List<Note> notes = new List<Note>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        //private DateTime date0;
        //private DateTime date00;
        private double deltaOpen = 70;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;
        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        private bool freewheel = false;
        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        private bool noRevival = false;

        private string scan;

        private Contexte contexte = new Contexte();
        private DateRef dateRef = new DateRef();
        private bool @continue = false;

        private bool postReport;

        private List<string> folders = new List<string>();
        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }

        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static List<Note> Notes { get { return Instance.notes; } }

        internal static Contexte Contexte { get { return Instance.contexte; } }
        internal static DateRef DateRef { get { return Instance.dateRef; } }

        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        public static bool Freewheel { get { return Instance.freewheel; } }

        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        public static bool NoRevival { get { return Instance.noRevival; } }

        public static string Scan { get { return Instance.scan; } }
        //  public static string Zique { get { return Instance.zique; } }
        public static bool Continue { get { return Instance.@continue; } }
        public static bool PostReport { get { return Instance.postReport; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        public static List<string> Folders { get { return Instance.folders; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            //str = l_xmlConf.getNodeValue("date0");
            //if (!string.IsNullOrEmpty(str))
            //    date0 = Convert.ToDateTime(str);

            //str = l_xmlConf.getNodeValue("date00");
            //if (!string.IsNullOrEmpty(str))
            //    date00 = Convert.ToDateTime(str);

            var xDateRef = l_xmlConf.NodeLookUp("dateRef");
            dateRef = new DateRef(xDateRef);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear();
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init();

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam(xSelect, x));
                }
            }

            notes.Clear();
            var xNotes = l_xmlConf.NodeLookUp("notes");
            if (xNotes != null)
            {
                foreach (XmlNode xsub in xNotes)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        notes.Add(new Note(x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            freewheel = l_xmlConf.getBoolValue("freewheel", false);
            noRevival = l_xmlConf.getBoolValue("noRevival", false);
            @continue = l_xmlConf.getBoolValue("continue", false);
            postReport = l_xmlConf.getBoolValue("postReport", false);


            scan = l_xmlConf.getNodeValue("scan");

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);


            var xContext = l_xmlConf.NodeLookUp("context");
            contexte = new Contexte(xContext);

            folders = new List<string>();
            var xFolders = l_xmlConf.NodeLookUp("folders");
            if (xFolders != null)
            {
                foreach (var xsub in xFolders.ChildNodes)
                {
                    if (xsub is XmlElement)
                    {
                        var xxsub = xsub as XmlElement;
                        if (xxsub.Name == "f")
                        {
                            var f = XMLTool.getAttValue(xxsub, "f");
                            if (!string.IsNullOrEmpty(f))
                            {
                                if (!f.EndsWith("\\"))
                                    f = f + "\\";
                                folders.Add(f);
                            }
                        }
                    }
                }
            }

            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.buildR(xDir, child);

                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["uniqueAlbum"] != null)
                        {
                            sub.UniqueAlbum = child.Attributes["uniqueAlbum"].Value == "true";
                        }
                        if (child.Attributes["order"] != null)
                        {
                            sub.OrderNote = child.Attributes["order"].Value == "note";
                        }
                        if (child.Attributes["petit"] != null)
                        {
                            sub.Petit = child.Attributes["petit"].Value == "true";
                        }
                        if (child.Attributes["histo"] != null)
                        {
                            sub.Histo = child.Attributes["histo"].Value == "true";
                        }
                        if (child.Attributes["resetBefore"] != null)
                        {
                            sub.ResetBefore = child.Attributes["resetBefore"].Value == "true";
                        }
                        if (child.Attributes["resetAfter"] != null)
                        {
                            sub.ResetAfter = child.Attributes["resetAfter"].Value == "true";
                            sub.Fill = child.Attributes["resetAfter"].Value == "fill";
                        }


                        if (child.Attributes["playlist"] != null)
                        {
                            sub.PlayList = child.Attributes["playlist"].Value;
                        }
                        //if (child.Attributes["serial"] != null)
                        //{
                        //    sub.Serial = child.Attributes["serial"].Value == "true";
                        //}

                        //if (child.Attributes["cascading"] != null)
                        //    sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        sub.selectParams.Clear();
                        foreach (XmlNode xsub in child.ChildNodes)
                        {
                            if (xsub is XmlElement)
                            {
                                if (xsub.Name == "select")
                                {
                                    foreach (XmlNode xp in xsub.ChildNodes)
                                    {
                                        if (xsub is XmlElement)
                                        {
                                            var _param = new SelectParamBase(xsub as XmlElement, xp as XmlElement);
                                            sub.selectParams.Add(_param);
                                        }
                                    }
                                }
                            }
                        }

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init();

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToDouble(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        //private static bool date00Consumed;
        //public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                return Instance.dateRef.date0;
            }
        }

        public static DateTime DateContexte
        {
            get
            {
                return Instance.dateRef.contexte;
            }
        }


        public static DateTime getDate(string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return DateTime.MaxValue;
            double d = -1;
            var date0 = Date0;
            var dateContexte = DateContexte;
            var dateC0 = dateContexte;
            if (date0 < dateContexte)
                dateC0 = date0;

            if (str.EndsWith("c0"))
            {

                var _str = str.Remove(str.Length - 2);
                if (double.TryParse(_str, out d))
                {
                    return dateC0.AddDays(d);
                }
            }
            else if (str.EndsWith("c"))
            {

                var _str = str.Remove(str.Length - 1);
                if (double.TryParse(_str, out d))
                {
                    return dateContexte.AddDays(d);
                }
            }

            else if (double.TryParse(str, out d))
            {
                if (d >= 0)
                {
                    return date0.AddDays(d);
                }
                else
                    return DateTime.Now.Date.AddDays(d);
            }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);


                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int currentNbp = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            int currentNbMax = int.MaxValue;
            int currentNbpMax = int.MaxValue;
            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
            // bool currentOverwrite = false;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    // currentOverwrite = currentItem.OverwriteConf;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    currentNbp = currentItem.Nbp;
                    lcurrentNb = currentItem.LoadNb;

                    currentNbMax = currentItem.NbMax;
                    currentNbpMax = currentItem.NbpMax;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNb(currentNb, false);
                    _limitItem.setNbp(currentNbp, false);
                    _limitItem.LoadNb = lcurrentNb;

                    _limitItem.NbMax = currentNbMax;
                    _limitItem.setNbpMax(currentNbpMax, false);
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                    //   _limitItem.OverwriteConf = currentOverwrite;



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNb(dir.Nb, true);
                        if (_limitItem.Nbp == int.MaxValue)
                            _limitItem.setNbp(dir.Nbp, true);
                        if (_limitItem.NbMax == int.MaxValue)
                            _limitItem.NbMax = dir.NbMax;
                        if (_limitItem.NbpMax == int.MaxValue)
                            _limitItem.setNbpMax(dir.NbpMax, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
using System;
using pdb.podcast.Notes;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>//, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        // private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
        new private DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }

        private CauseRegister _causeRegister;
        internal CauseRegister CauseRegister
        {
            get
            {
                if (_causeRegister != null)
                    return _causeRegister;
                if (parent == null)
                    return null;
                return parent.CauseRegister;
            }
        }

        private Feeds feeds;
        internal Feeds Feeds
        {
            get
            {
                if (feeds != null)
                    return feeds;
                if (parent == null)
                    return null;
                return parent.Feeds;
            }
        }

        private NoteBuilder noteBuilder;
        internal NoteBuilder NoteBuilder
        {
            get
            {
                if (noteBuilder != null)
                    return noteBuilder;
                if (parent == null)
                {

                    foreach (Note _note in Conf.Notes)
                    {
                        if (_note.dir == name)
                        {
                            this.noteBuilder = new NoteBuilder(_note);
                            break;
                        }
                    }

                    if (noteBuilder != null)
                        return noteBuilder;
                    return null;
                }


                return parent.NoteBuilder;
            }
        }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            if (childs.Contains(dir))
                return;
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }



        //public void buildLoaders(List<LimitItemLoader> list, AutoBuilder auto)
        //{
        //    if (auto != Auto)
        //        return;
        //    var loader = Loader;
        //    var fl = loader.LimitsLoader;
        //    fl.getLoaders(list);
        //    foreach (DirConf sub in childs)
        //    {
        //        sub.buildLoaders(list, auto);
        //    }
        //}

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            if (offset > DateTime.MinValue)
            {
                track.Offset = offset;
                offset = offset.AddDays(1);
            }
            conteneur.recordTrack(track, limit);
            //if (parent != null)
            //    parent.recordTrackFromChild(track, limit, this);
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodcastComparerPubPub2());
            else
                list.Sort(new PodCastComparerInv());
            //log.log("");
            //log.log(getPath() + " getListe " + list.Count + " elt.");
            //foreach (TrackInfoItunes track in list)
            //{
            //    log.log(track.ToString());
            //}
            return list;
        }

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        //{
        //    if (dirSource.transmitToParent)
        //        Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
        //    if (parent != null)
        //        parent.recordTrackFromChild(track, itemSource, this);
        //}

        ///// <summary>
        ///// Abandonné
        ///// </summary>
        //public void TransmissionListToParent(TrackInfoItunes track)
        //{
        //}


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}






        public List<SelectParamBase> selectParams = new List<SelectParamBase>();

        public Limits Limites { get { return limites; } set { limites = value; } }


        private static Dict<string, DirConf> dict = new Dict<string, DirConf>();
        public static DirConf getDir(Limits limites, string name, DirConf parent)
        {
            // return new DirConf(limites, name, parent); 
            string path = getPath(parent, name);


            var d = dict[path];
            if (d == null)
            {
                d = new DirConf(limites, name, parent);
                dict[path] = d;
                return d;
            }
            else
            {
                //  var nd = new DirConf(limites, name, parent);
                dict[path] = d;
                d.recup = true;
                d.init(limites, name, parent);
                // nd.loader = d.loader; 
            }

            return d;

        }


        private DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            init(limites, name, parent);
        }
        private bool recup = false;

        public void Init()
        {
            if (recup && loader != null)
            {
                loader.init(this);
            }
        }
        private void init(Limits limites, string name, DirConf parent)
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            //  this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
            {
                conteneur = new TrackConteneur(this, null);
                if (feeds == null)
                    feeds = new Feeds();
                if (this.NoteBuilder == null)
                {
                    foreach (Note _note in Conf.Notes)
                    {
                        if (_note.dir == name)
                        {
                            this.noteBuilder = new NoteBuilder(_note);
                            break;
                        }
                    }
                }
                if (Conf.Html.writeCause <= 0)
                {
                    _causeRegister = new NullRegister();
                }
                else
                    _causeRegister = new CauseRegister();
            }
            else
                conteneur = new TrackConteneur(this, parent.conteneur);
            //transmitToParent = Conf.Transmit;
            //transmitTotal = Conf.TransmitTotal;
            //transmitTotalGuest = Conf.TransmitTotalGuest;
            //   cascading = Conf.Cascading;
            if (loader != null)
            {
                if (parent != null)
                {
                    loader.Albums.Clear();
                    loader.AlbumsReserve.Clear();
                }


            }

            this.borderObs.Clear();

        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }
        private bool? histo;
        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (histo.HasValue)
                    return histo.Value;
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
            set
            {
                histo = value;
            }
        }

        private string playlist;
        public string PlayList
        {
            get
            {
                return playlist;
            }
            set
            {
                playlist = value;
            }
        }

        public bool ResetBefore;
        public bool ResetAfter;
        /// <summary>
        /// Récupère les tracks mis de coté 
        /// </summary>
        public bool Fill;

        private bool orderNote;
        public bool OrderNote { get { return orderNote; } set { orderNote = value; } }

        private bool petit;
        public bool Petit { get { return petit; } set { petit = value; } }

        //private bool serial;
        //public bool Serial { get { return serial; } set { serial = value; } }

        /// <summary>
        /// Simple sélection nominative(par album)
        /// </summary>
        private bool uniqueAlbum;
        public bool UniqueAlbum
        {
            get
            {
                return uniqueAlbum;
            }
            set
            {
                uniqueAlbum = value;
            }
        }

        //private bool? cascading;
        //public bool Cascading
        //{
        //    get
        //    {
        //        if (cascading.HasValue)
        //            return cascading != false;
        //        if (false == histoAll)
        //            return false;
        //        if (parent == null)
        //            return true;
        //        return parent.Cascading;
        //    }
        //    set
        //    {
        //        cascading = value;
        //    }
        //}

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                selectionPre = value;
            }
        }

        //private bool transmitToParent = true;
        //public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        //private bool transmitTotal = true;
        //public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        //private bool transmitTotalGuest = true;
        //public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            return getPath(parent, name);
        }

        public static string getPath(DirConf parent, string name)
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            return Feeds.LoadedTracks;
        }


        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }


        private AutoBuilder auto;
        public AutoBuilder Auto
        {
            get
            {
                if (auto != null)
                    return auto;
                if (parent != null)
                    return parent.Auto;
                return null;
            }
            set
            {
                auto = value;
            }
        }
        #region IBorder
        private List<AutoBuilder> borderObs = new List<AutoBuilder>();
        public void addBorderObs(AutoBuilder auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            //if (uniqueAlbum)
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(tb);
        }


        public bool canSignal()
        {
            return true;
            //if (false == HistoAll || serial) //OUAILLE?
            //    return false;
            //return true; 
        }

        public void signal(CauseDatas cd)
        {
            //if (false == HistoAll || serial) //OUAILLE?
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(cd);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(cd);
        }

        public double getMaxDateAuto()
        {
            foreach (AutoBuilder border in borderObs)
            {
                return border.getMaxDateAuto();
            }
            if (parent != null)
                return parent.getMaxDateAuto();
            return 0;
        }
    }
}
]]></content>
  </file>
</db>
