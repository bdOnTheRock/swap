<db path="C:\Bernard\db1\PieceDb3Ref">
 <file path="\pdb.player\Vue\PlayerControler.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.PlayerControler"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
              xmlns:local="clr-namespace:pdb.player"
              xmlns:util="clr-namespace:pdb.player.Vue.Util"
             mc:Ignorable="d" 
             d:DesignHeight="167" d:DesignWidth="777">
    <UserControl.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <Style x:Key="EmptyButtonStyle" TargetType="{x:Type Button}">
            <Setter Property="Background" Value="#00000000"/>
            <Setter Property="BorderBrush" Value="#00000000"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
            <Setter Property="HorizontalContentAlignment" Value="Center"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter 
                        HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                        Margin="{TemplateBinding Margin}" 
                        RecognizesAccessKey="True" 
                        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
                        VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                           
                            />
                        
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid Margin="0" >
        <Grid.Background>
            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                <GradientStop Color="#fff" Offset="0" />
                <GradientStop Color="#dfdfdf" Offset="1" />
               
            </LinearGradientBrush>

        </Grid.Background>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Name="defNav" Width="Auto" />
            <ColumnDefinition Name="defInfo" Width="*" />
            <ColumnDefinition Name="defFilter" Width="Auto" />
        </Grid.ColumnDefinitions>
        <Grid Margin="10" Grid.Column="0" >
            <StackPanel Orientation="Horizontal" VerticalAlignment="Bottom">

                <Button Name="b_rewind" Height="40" Width="40" Command="{Binding BackWard}" Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Rewind-icon.png"  Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_play" Height="40" Width="40"  Command="{Binding Play,UpdateSourceTrigger=PropertyChanged}"  Style="{DynamicResource EmptyButtonStyle}">
                    <!--<Image Name="I_Play" Source="images\Toolbar-MP3-Play-icon.png"   Height="30" Width="30"></Image>-->
                    <Image Name="I_Play" Source="{Binding SrcPlayPause, UpdateSourceTrigger=PropertyChanged}"   Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_forward" Height="40" Width="40" Command="{Binding Forward}"  Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Forward-icon.png"    Height="30" Width="30" ></Image>
                </Button>
                <Grid Margin="10">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition />
                        <ColumnDefinition />
                        <ColumnDefinition />
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="&lt;)" Grid.Column="0"  VerticalAlignment="Center" Margin="0,0,5,0"/>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="SliderVolume" Width="150" VerticalAlignment="Center" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Volume, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <TextBlock Text="&lt;)))" Grid.Column="2"  VerticalAlignment="Center"  Margin="5,0,00,0"/>
                </Grid>
            </StackPanel>
        </Grid>
       
        <Grid Grid.Column="1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Name="defName" MaxHeight="50" Height="Auto" />
                    <RowDefinition Name="defPosition" Height="Auto" />
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,15,0,0">
                    <Label Name="l_TrackName"  HorizontalAlignment="Center" Content="{Binding Path=CurrentName,  UpdateSourceTrigger=PropertyChanged}"  FontWeight="Bold" Padding="0" Margin="0"></Label>
                    <Label Grid.Row="1" Name="l_trackAuthorAlbum" HorizontalAlignment="Center" Content="{Binding Path=CurrentAuthorAlbum,  UpdateSourceTrigger=PropertyChanged}"  Padding="0" Margin="0"/>
                </StackPanel>
                <Grid Grid.Row="2"  HorizontalAlignment="Stretch" Margin="5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="Auto" />
                    </Grid.ColumnDefinitions>
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <CheckBox Name="cbEnabled" DockPanel.Dock="Left" ToolTip="Jouer seulement les morceaux cochés" IsChecked="{Binding OnlyEnabled,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Name="cbSortAlbum" DockPanel.Dock="Left" ToolTip="Tri par album" IsChecked="{Binding SortByAlbum,UpdateSourceTrigger=PropertyChanged}" />
                        <ComboBox Name="cbxSort" Height="20" SelectedIndex="{Binding SortAlbumMode, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource sortAlbum} }"  >
                                  <ComboBox.ToolTip>
                                    <TextBlock  xml:space="preserve">
strict          = tri sur moyenne quand aucun des albums n'a défini sa médianne
mix             = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
mixLight        = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
mixLight2       = tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
medQuasi        = calcul médianne quasi strict, qq miettes pour éviter le zero
medLight        = calcul Médianne moins strict
medLightSafe2   = calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
medLightSafe2   = calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
light           = tri uniquement sur la moyenne
                                    </TextBlock>
                                  </ComboBox.ToolTip>
                            <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mix" >mix</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light" Name="mixLight" >mixLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mixLight2" >mixLight2</ComboBoxItem>
                            <ComboBoxItem ToolTip="Calcul médianne quasi strict, qq miettes pour éviter le zero" Name="medQuasi" >medQuasi</ComboBoxItem>                            
                            <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="medLight" >medLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse" Name="medLightSafe" >medLightSafe</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse" Name="medLightSafe2" >medLightSafe2</ComboBoxItem>                           
                            <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="light" >light</ComboBoxItem>
                        </ComboBox>
                        <CheckBox Name="cbAlbumVirtual" DockPanel.Dock="Left" ToolTip="albums virtuels" IsChecked="{Binding WithVirtualAlbum,UpdateSourceTrigger=PropertyChanged}" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}, Mode=OneTime}"/>
                        <Label Name="Duration" DockPanel.Dock="Left" VerticalAlignment="Bottom" Content="{Binding Path=ElapsedTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />

                    </StackPanel>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="PBar"  VerticalAlignment="Bottom" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Position, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal">
                        <Label Name="RemainingTime"   VerticalAlignment="Bottom" Content="{Binding Path=RemainingTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />
                        <Label Content="/" />
                        <Label Name="Length"  VerticalAlignment="Bottom" Content="{Binding Path=Length, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"/>
                    </StackPanel>
                </Grid>
            </Grid>

        </Grid>
        <DockPanel Grid.Column="2" HorizontalAlignment="Stretch" VerticalAlignment="Top" Margin="0,15,0,0">
            <GroupBox Header="Filtre" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <StackPanel Orientation="Horizontal" >
                    <TextBox x:Name="txtFilter" MinWidth="150"  KeyUp="txtFilter_KeyUp" />
                </StackPanel>
            </GroupBox>
        </DockPanel>


    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;

namespace pdb.util
{
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;


        public static decimal getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static decimal getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return getMedianne_(list, coeffMedianne);
        }


        public static decimal getMedianneLight(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;
           

            List<decimal> _list = new List<decimal>(list);

            if (nbVirt > 0)
            {
              
                int i0 = -1; 
                
                for (int i = 0; i < count; i++)
                {
                    if (_list[i] == 0m)
                    {
                        i0 = i;
                        break; 
                    }
                }

                if (i0 > 0)
                {
                    int _count = Math.Min(count, i0 + nbVirt); 
                    decimal[] virt = new decimal[_count]; 
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                   // decimal prec = -1m;  
                    decimal value =int.MaxValue; 
                    for (int i = 1; i < _count; i++)
                    {
                     //   prec = value;
                        value = _list[i];
                        var calc = virt[i];
                        if (value < calc)
                        {
                            value = calc;  //Math.Min(prec, calc);
                            _list[i] = value; 
                        }
                    }
                }
            }
          
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
              
                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue; 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux= aux * coeff;
                if (aux > ret)
                    ret = aux;
                if (_list[count - i - 1] > 0m)
                    break ;

            }
          

            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
                return list[count - 1];

            var medianne = coeffMedianne * (count - 1);

            int i0 = (int)medianne;
            int i1 = i0 + 1;
            var val0 = list[i0];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(i0)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
                return val1;

            var pente = (val1 - val0);
            var dx = medianne - i0;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }

        private List<Piece> list = new List<Piece>();
        public Album(string name)
        {
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementValueComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(bool quasi, int medianneVirt) //IList<double> reference, IList<Piece> pieces)
        {
            //if (name == "The College Dropout")
            //{
            //}
            decimal offset = conf.AlbumMoyOffset;
            int count = list.Count;
            list.Sort(new PieceSortComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < count; i++)
            {
                listSortedValues.Add(list[i].Rank.SortValue);
                if (!classed && list[i].isClassListNumeric)
                    classed = true;
            }

            m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne);

            listSortedValues = new List<decimal>();
            list.Sort(new PieceDurationValueComparer());
            for (int i = 0; i < count; i++)
                listSortedValues.Add(list[i].Duration.TotalMilliseconds());
            durationValue = CalcMedianne.getMedianne(listSortedValues, medianne);



            listSortedValues = new List<decimal>();
            list.Sort(new PieceClassementValueComparer());
            decimal moy = 0m;
            for (int i = 0; i < count; i++)
            {
                var rapportClassement = list[i].RapportClassement;
                moy += rapportClassement;
                if (offset > 0m && rapportClassement > 0.0m)
                    moy += offset;

                listSortedValues.Add(rapportClassement);
            }
            if (count > 0)
                moy /= count;
            classMoy = moy;


            classementValue = CalcMedianne.getMedianne(listSortedValues, medianne);
           
            classementValueLight = CalcMedianne.getMedianneLight(listSortedValues, medianne, quasi, medianneVirt);




            //int iequiv = CalcMedianne.getEquiv(reference, m_rank.SortValue, 0, reference.Count - 1);
            //equiv = pieces[iequiv];
            equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
            equivLight = Piece.getClassementEquiv(classementValueLight);

            moyenne = Piece.getClassementEquiv(classMoy);



        }

        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest);
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public enum albumSortMode
    {
        /// <summary>
        /// tri sur moyenne quand aucun des albums n'a défini sa médianne
        /// </summary>
        strict,
        /// <summary>
        /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
        /// </summary>
        mix,
        /// <summary>
        /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
        /// </summary>
        mixLight,
        /// <summary>
        /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
        /// </summary>
        mixLight2,
        /// <summary>
        /// Calcul médianne quasi strict, qq miettes pour éviter le zero
        /// </summary>
        medQuasi,
        /// <summary>
        /// Calcul Médianne moins strict
        /// </summary>
        medLight,
        /// <summary>
        /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
        /// </summary>
        medLightSafe,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe2,
        /// <summary>
        /// tri uniquement sur la moyenne
        /// </summary>
        light

    }
    class AlbumClassComparer : IComparer<Album>
    {
        private albumSortMode mode;
        public AlbumClassComparer(albumSortMode mode)
        {
            this.mode = mode;
        }
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            //if (x.Name == "Alien Lanes" || y.Name == "Alien Lanes")
            //{
            //    int toto = 0; 
            //}
            //si classement == 0 mais que l'autre est tellement nul que m�me ma moyenne est sup�rieure � sa moyenne
            int cmp = 0;

            if (mode == albumSortMode.light)
            {
                cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                if (cmp != 0)
                    return cmp;
            }
            else if (mode == albumSortMode.mix)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.mixLight)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.mixLight2)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
                else
                {
                    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.medLight || mode == albumSortMode.medQuasi|| mode  == albumSortMode.medLightSafe || mode == albumSortMode.medLightSafe2)
            {
                cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                if (cmp != 0)
                    return cmp;
            }

          

            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInVirtualAlbumComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Location.CompareTo(y.Location); 
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp= x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.Location.CompareTo(y.Location); 
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }

   
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    class Albums
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {
            int medianneVirt = 0;
            bool quasi = false;
            if (consolid.SortAlbumMode == albumSortMode.medQuasi)
                quasi = true;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe)
                medianneVirt = 1;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe2)
                medianneVirt = 2; 
            var listRef = new List<double>();
            //foreach (Piece piece in reference)
            //    listRef.Add(piece.RapportClassement); // piece.Rank.SortValue); 
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(quasi, medianneVirt); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }



    }
}
]]></content>
  </file>
</db>
