<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.sln">
    <content><![CDATA[
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb", "pdb.csproj", "{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.it", "pieceDb.iT\pdb.it.csproj", "{CF5DB63F-4790-4351-9050-B30DED32F052}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.obj", "PieceDb.obj\pdb.obj.csproj", "{9B849072-2B8E-4CE4-8AD7-D173724A9644}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.db", "PieceDb.Db\pdb.db.csproj", "{43D27B47-E615-451D-AD25-67C5B8447C4A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.gen", "PieceDb.Consolid\pdb.gen.csproj", "{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.gen.it", "PieceDb.iT.listGen\pdb.gen.it.csproj", "{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testMoveTree", "testMoveTree\testMoveTree.csproj", "{FF82B72D-A119-4B53-9D35-2269FF6E5384}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "podcast", "podcast\podcast.csproj", "{CF22411A-0D1B-4301-9087-DFBCF85AB16A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.util", "pdb.util\pdb.util.csproj", "{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "hello", "WPF\hello\hello.csproj", "{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.podcast", "pdb.podcast\pdb.podcast.csproj", "{6503C759-0373-4B68-A28B-1CB5FF0E6208}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "grant", "grant\grant.csproj", "{5E84FD2F-0954-4D9B-AF17-36F857490C6A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testSDK", "testSDK\testSDK.csproj", "{30459276-DDC7-4BF5-AF55-CDD7211FD791}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "purgeZique", "purgeZique\purgeZique.csproj", "{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.daemon", "pdb.daemon\pdb.daemon.csproj", "{D69D572F-67C8-47E8-93B0-CC33FA4BC704}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "podcastCopy", "podcastCopy\podcastCopy.csproj", "{F916911A-B4FF-4B0A-BA80-B8349E3E0130}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testFormar", "testFormar\testFormar.csproj", "{32A79657-7A1F-4F72-99D8-4406838182F2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.ordo", "pdb.ordo\pdb.ordo.csproj", "{30823D1D-851C-456B-AC4C-B0BEEC173361}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "engine", "engine", "{B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "vlc", "vlc", "{C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine", "engine\pdb.player.engine\pdb.player.engine.csproj", "{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.build", "engine\pdb.player.engine.build\pdb.player.engine.build.csproj", "{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.vlc.pluginI", "engine\vlc\pdb.player.engine.vlc.pluginI\pdb.player.engine.vlc.pluginI.csproj", "{610EF011-6738-49D6-8426-4B162726D57E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player.engine.vlc.plugin", "engine\vlc\pdb.player.engine.vlc.plugin\pdb.player.engine.vlc.plugin.csproj", "{3CD9378E-BE8C-4E38-B362-51363357988C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testStats", "testStats\testStats.csproj", "{07095C40-49A3-4001-8671-4285D9633596}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "2001", "2001\2001.csproj", "{37020161-0E95-46F0-9FD1-DE43C491FA08}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.player", "pdb.player\pdb.player.csproj", "{4166FA60-B33F-4496-9352-EDD8F3214021}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "testmatchalbum", "..\testmatchalbum\testmatchalbum.csproj", "{B901D21E-A546-4628-9136-B8D5E3FF4A1A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "pdb.iit", "pdb.iit\pdb.iit.csproj", "{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x64.ActiveCfg = Debug|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x64.Build.0 = Debug|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x86.ActiveCfg = Debug|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Debug|x86.Build.0 = Debug|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Any CPU.Build.0 = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x64.ActiveCfg = Release|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x64.Build.0 = Release|x64
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x86.ActiveCfg = Release|x86
		{45D9BDC7-909F-47D5-952A-7C78B69D4BE6}.Release|x86.Build.0 = Release|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x64.ActiveCfg = Debug|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x64.Build.0 = Debug|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x86.ActiveCfg = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Debug|x86.Build.0 = Debug|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Any CPU.Build.0 = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x64.ActiveCfg = Release|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x64.Build.0 = Release|x64
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x86.ActiveCfg = Release|x86
		{CF5DB63F-4790-4351-9050-B30DED32F052}.Release|x86.Build.0 = Release|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x64.ActiveCfg = Debug|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x64.Build.0 = Debug|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x86.ActiveCfg = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Debug|x86.Build.0 = Debug|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Any CPU.Build.0 = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x64.ActiveCfg = Release|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x64.Build.0 = Release|x64
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x86.ActiveCfg = Release|x86
		{9B849072-2B8E-4CE4-8AD7-D173724A9644}.Release|x86.Build.0 = Release|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x64.ActiveCfg = Debug|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x64.Build.0 = Debug|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x86.ActiveCfg = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Debug|x86.Build.0 = Debug|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Any CPU.Build.0 = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x64.ActiveCfg = Release|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x64.Build.0 = Release|x64
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x86.ActiveCfg = Release|x86
		{43D27B47-E615-451D-AD25-67C5B8447C4A}.Release|x86.Build.0 = Release|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x64.ActiveCfg = Debug|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x64.Build.0 = Debug|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x86.ActiveCfg = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Debug|x86.Build.0 = Debug|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Any CPU.Build.0 = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x64.ActiveCfg = Release|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x64.Build.0 = Release|x64
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x86.ActiveCfg = Release|x86
		{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}.Release|x86.Build.0 = Release|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x64.ActiveCfg = Debug|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x64.Build.0 = Debug|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x86.ActiveCfg = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Debug|x86.Build.0 = Debug|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Any CPU.Build.0 = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x64.ActiveCfg = Release|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x64.Build.0 = Release|x64
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x86.ActiveCfg = Release|x86
		{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}.Release|x86.Build.0 = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|Any CPU.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x64.ActiveCfg = Debug|x64
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x86.ActiveCfg = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Debug|x86.Build.0 = Debug|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Any CPU.ActiveCfg = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|Mixed Platforms.Build.0 = Release|x86
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|x64.ActiveCfg = Release|x64
		{FF82B72D-A119-4B53-9D35-2269FF6E5384}.Release|x86.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x64.ActiveCfg = Debug|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x86.ActiveCfg = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Debug|x86.Build.0 = Debug|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Any CPU.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|Mixed Platforms.Build.0 = Release|x86
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|x64.ActiveCfg = Release|x64
		{CF22411A-0D1B-4301-9087-DFBCF85AB16A}.Release|x86.ActiveCfg = Release|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x64.ActiveCfg = Debug|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x64.Build.0 = Debug|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x86.ActiveCfg = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Debug|x86.Build.0 = Debug|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Any CPU.Build.0 = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x64.ActiveCfg = Release|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x64.Build.0 = Release|x64
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x86.ActiveCfg = Release|x86
		{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}.Release|x86.Build.0 = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|Any CPU.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x64.ActiveCfg = Debug|x64
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x86.ActiveCfg = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Debug|x86.Build.0 = Debug|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Any CPU.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|Mixed Platforms.Build.0 = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x64.ActiveCfg = Release|x64
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x86.ActiveCfg = Release|x86
		{5D58E88B-67FC-4CCC-B8CA-3F93EAC0032E}.Release|x86.Build.0 = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x64.ActiveCfg = Debug|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x64.Build.0 = Debug|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x86.ActiveCfg = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Debug|x86.Build.0 = Debug|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Any CPU.ActiveCfg = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|Mixed Platforms.Build.0 = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x64.ActiveCfg = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x64.Build.0 = Release|x64
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x86.ActiveCfg = Release|x86
		{6503C759-0373-4B68-A28B-1CB5FF0E6208}.Release|x86.Build.0 = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x64.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x86.ActiveCfg = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Debug|x86.Build.0 = Debug|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Any CPU.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|Mixed Platforms.Build.0 = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x64.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x86.ActiveCfg = Release|x86
		{5E84FD2F-0954-4D9B-AF17-36F857490C6A}.Release|x86.Build.0 = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|Any CPU.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x64.ActiveCfg = Debug|x64
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x86.ActiveCfg = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Debug|x86.Build.0 = Debug|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Any CPU.ActiveCfg = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|Mixed Platforms.Build.0 = Release|x86
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|x64.ActiveCfg = Release|x64
		{30459276-DDC7-4BF5-AF55-CDD7211FD791}.Release|x86.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|Any CPU.ActiveCfg = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x64.ActiveCfg = Debug|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x86.ActiveCfg = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Debug|x86.Build.0 = Debug|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Any CPU.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|Mixed Platforms.Build.0 = Release|x86
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|x64.ActiveCfg = Release|x64
		{7DFF4E0E-5A4D-4588-B015-D16F19DACFC0}.Release|x86.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x64.ActiveCfg = Debug|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x86.ActiveCfg = Debug|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Debug|x86.Build.0 = Debug|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|Mixed Platforms.Build.0 = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x64.ActiveCfg = Release|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x64.Build.0 = Release|x64
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x86.ActiveCfg = Release|x86
		{D69D572F-67C8-47E8-93B0-CC33FA4BC704}.Release|x86.Build.0 = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Any CPU.ActiveCfg = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x64.ActiveCfg = Debug|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x86.ActiveCfg = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Debug|x86.Build.0 = Debug|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Any CPU.ActiveCfg = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|Mixed Platforms.Build.0 = Release|x86
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|x64.ActiveCfg = Release|x64
		{F916911A-B4FF-4B0A-BA80-B8349E3E0130}.Release|x86.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|Any CPU.ActiveCfg = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x64.ActiveCfg = Debug|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x86.ActiveCfg = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Debug|x86.Build.0 = Debug|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Any CPU.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|Mixed Platforms.Build.0 = Release|x86
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|x64.ActiveCfg = Release|x64
		{32A79657-7A1F-4F72-99D8-4406838182F2}.Release|x86.ActiveCfg = Release|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x64.ActiveCfg = Debug|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x64.Build.0 = Debug|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x86.ActiveCfg = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Debug|x86.Build.0 = Debug|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Any CPU.Build.0 = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x64.ActiveCfg = Release|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x64.Build.0 = Release|x64
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x86.ActiveCfg = Release|x86
		{30823D1D-851C-456B-AC4C-B0BEEC173361}.Release|x86.Build.0 = Release|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Any CPU.Build.0 = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|x64.ActiveCfg = Release|Any CPU
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}.Release|x86.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Any CPU.Build.0 = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|x64.ActiveCfg = Release|Any CPU
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}.Release|x86.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Any CPU.Build.0 = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|x64.ActiveCfg = Release|Any CPU
		{610EF011-6738-49D6-8426-4B162726D57E}.Release|x86.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x86.ActiveCfg = Debug|x86
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Debug|x86.Build.0 = Debug|x86
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Any CPU.Build.0 = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|x64.ActiveCfg = Release|Any CPU
		{3CD9378E-BE8C-4E38-B362-51363357988C}.Release|x86.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|x64.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Debug|x86.ActiveCfg = Debug|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Any CPU.Build.0 = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|x64.ActiveCfg = Release|Any CPU
		{07095C40-49A3-4001-8671-4285D9633596}.Release|x86.ActiveCfg = Release|Any CPU
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Any CPU.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x64.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x86.ActiveCfg = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Debug|x86.Build.0 = Debug|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Any CPU.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|Mixed Platforms.Build.0 = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x64.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x86.ActiveCfg = Release|x86
		{37020161-0E95-46F0-9FD1-DE43C491FA08}.Release|x86.Build.0 = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x64.ActiveCfg = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x86.ActiveCfg = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Debug|x86.Build.0 = Debug|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Any CPU.Build.0 = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x64.ActiveCfg = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x86.ActiveCfg = Release|x86
		{4166FA60-B33F-4496-9352-EDD8F3214021}.Release|x86.Build.0 = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Any CPU.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|Mixed Platforms.Build.0 = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x64.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x86.ActiveCfg = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Debug|x86.Build.0 = Debug|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Any CPU.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Mixed Platforms.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|Mixed Platforms.Build.0 = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x64.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x86.ActiveCfg = Release|x86
		{B901D21E-A546-4628-9136-B8D5E3FF4A1A}.Release|x86.Build.0 = Release|x86
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|Any CPU.Build.0 = Release|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|x64.ActiveCfg = Release|Any CPU
		{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}.Release|x86.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{C7DF1F85-A6D6-4771-8870-2CC0F2A0041E} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54} = {B35DF70C-1EC8-445D-939E-02FFE4A5B8B1}
		{610EF011-6738-49D6-8426-4B162726D57E} = {C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}
		{3CD9378E-BE8C-4E38-B362-51363357988C} = {C7DF1F85-A6D6-4771-8870-2CC0F2A0041E}
	EndGlobalSection
EndGlobal
]]></content>
  </file>
  <file path="\pdb.iit\ILoader.cs">
    <content><![CDATA[
using System.Collections.Generic;
using pdb.obj;
using System.Xml;
namespace pdb.iit
{
    /// <summary>
    /// Abstraction de loader It
    /// </summary>
    public interface ILoader
    {
        void saveIds();
        void init();
        void loadTracks(bool firstStep, bool forceLoad, List<ITrackInfoItunes> list);
        void loadTracks(List<ITrackInfoItunes> list);
        string DefaultFolder { get; }
        bool ModeXml { set; }
        void import(ITrackInfoItunes track);
        void merge(ITrackInfoItunes track);
        PlayListComposite TreePlayList { get; }
        int NbTrackCreated { get; }
        void reviveIfNecessary(ITrackInfoItunes track);
        IPlayListFilter PlayListFilter { set; }
        PlayListComposite getOrCreateFolder(string folder);
        PlayListComposite getOrCreateFolder(PlayListComposite folder, string name, bool buildIf);
        IPlayList getPlayList(PlayListComposite folder, string name, bool buildIf);
        void mergeList(CPlayList playlist, ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task);
        void setConf(XmlElement xml);
        bool Aborted { set; }
    }
}
]]></content>
  </file>
  <file path="\pdb.iit\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.obj;

namespace pdb.iit
{
    public interface IPlayListFilter
    {
        bool consider(PlayListComposite current);
    }
}
]]></content>
  </file>
  <file path="\pdb.iit\IPlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.obj;

namespace pdb.iit
{
    public interface IPlayList
    {
        void setPrior(int prior); 
        void mergeList(ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task); 
    }
}
]]></content>
  </file>
  <file path="\pdb.iit\pdb.iit.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.iit</RootNamespace>
    <AssemblyName>pdb.iit</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ILoader.cs" />
    <Compile Include="Interfaces.cs" />
    <Compile Include="IPlayList.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.iit\Properties\AssemblyInfo.cs">
    <content><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("pdb.iit")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("pdb.iit")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2017")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("03de8616-6103-465f-b9ba-4d29908188da")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
]]></content>
  </file>
  <file path="\pdb.podcast\pdb.podcast.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{6503C759-0373-4B68-A28B-1CB5FF0E6208}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.podcast</RootNamespace>
    <AssemblyName>pdb.podcast</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;vendee_</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;MOVE_</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.podcast.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <OutputPath>bin\Release\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.podcast.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.iTunesLib">
      <HintPath>..\pieceDb.iT\bin\Interop.iTunesLib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Albums\AlbumMgr.cs" />
    <Compile Include="Albums\TrackAlbum.cs" />
    <Compile Include="Auto\AutoBuilder.cs" />
    <Compile Include="Auto\AutoBuilderItem.cs" />
    <Compile Include="DB\Db.cs" />
    <Compile Include="Hibernator.cs" />
    <Compile Include="Load\Contribution.cs" />
    <Compile Include="MockLoader.cs" />
    <Compile Include="Selection\CauseData.cs" />
    <Compile Include="Auto\Interfaces.cs" />
    <Compile Include="Auto\TrackBorderItem.cs" />
    <Compile Include="Build\FilePub.cs" />
    <Compile Include="Build\IPub.cs" />
    <Compile Include="Build\PubLoader.cs" />
    <Compile Include="Delta\Memory.cs" />
    <Compile Include="Exporter.cs" />
    <Compile Include="Load\LimitItemLoader.cs" />
    <Compile Include="Load\LimitLoader.cs" />
    <Compile Include="Load\LimitsLoader.cs" />
    <Compile Include="Menage.cs" />
    <Compile Include="Feed.cs" />
    <Compile Include="Feeds.cs" />
    <Compile Include="Load\FeedsLoader.cs" />
    <Compile Include="Load\FeedLimitItemLoader.cs" />
    <Compile Include="Report\DirStat.cs" />
    <Compile Include="Report\FeedLimitItemStat.cs" />
    <Compile Include="Report\FeedsLimitItemStat.cs" />
    <Compile Include="Report\FeedStat.cs" />
    <Compile Include="Report\GroupStat.cs" />
    <Compile Include="Report\IStat.cs" />
    <Compile Include="Report\LimitItemStat.cs" />
    <Compile Include="Report\LimitStat.cs" />
    <Compile Include="Report\Stat.cs" />
    <Compile Include="Loader.cs" />
    <Compile Include="PlayListFilter.cs" />
    <Compile Include="PodcastComparer.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Report\DoubleStat.cs" />
    <Compile Include="Report\StatFloat.cs" />
    <Compile Include="Report\TrackConteneur.cs" />
    <Compile Include="Report\TripleStat.cs" />
    <Compile Include="Selection\CauseItem.cs" />
    <Compile Include="Selection\CauseRegister.cs" />
    <Compile Include="Selection\Causes.cs" />
    <Compile Include="Selection\Conv.cs" />
    <Compile Include="Sort\Album.cs" />
    <Compile Include="Sort\Sorter.cs" />
    <Compile Include="Sort\TrackSort.cs" />
    <Compile Include="TrackInfoItunes.cs" />
    <Compile Include="Tuning\Album.cs" />
    <Compile Include="Tuning\Auto.cs" />
    <Compile Include="Tuning\Conf.cs" />
    <Compile Include="Tuning\ConfDate.cs" />
    <Compile Include="Tuning\Db.cs" />
    <Compile Include="Tuning\DirConf.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\Hibernate.cs" />
    <Compile Include="Tuning\Html.cs" />
    <Compile Include="Tuning\Journal.cs" />
    <Compile Include="Tuning\Limit.cs" />
    <Compile Include="Tuning\LimitItem.cs" />
    <Compile Include="Tuning\LimitItemBase.cs" />
    <Compile Include="Tuning\Limits.cs" />
    <Compile Include="Tuning\Move.cs" />
    <Compile Include="Tuning\RootIt.cs" />
    <Compile Include="Tuning\SelectParam.cs" />
    <Compile Include="Tuning\Sort.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.iit\pdb.iit.csproj">
      <Project>{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}</Project>
      <Name>pdb.iit</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\pieceDb.iT\pdb.it.csproj">
      <Project>{CF5DB63F-4790-4351-9050-B30DED32F052}</Project>
      <Name>pdb.it</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Content Include="conf.xml">
      <SubType>Designer</SubType>
    </Content>
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
 <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Load;
using timeSpan = pdb.util.timeSpan;


namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    public class AutoBuilder : IComparable<AutoBuilder>//, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private int nbDown;
        private bool ? useForfait;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private DirConf source; public DirConf Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;
        // private bool 


        private List<LimitItemLoader> loaders = new List<LimitItemLoader>();
        public void buildLoaders()
        {
            loaders = new List<LimitItemLoader>();
            source.buildLoaders(loaders, this);

        }

        public void go()
        {
            var total = new timeSpan();
            var fd = new timeSpan();
            var d = new timeSpan();
            var date = new timeSpan();
            var nb = 0;

            var dict = new pdb.util.BgDictString0<TrackInfoItunes>();

            while (true)
            {
                var _total = timeSpan.MaxValue;
                var _fd = timeSpan.MaxValue;
                var _d = timeSpan.MaxValue;
                var _date = timeSpan.MaxValue;
                var _nb = int.MaxValue;

                foreach (LimitItemLoader loader in loaders)
                {
                    loader.checkV(this, nb, fd, d, date);
                    if (_total > loader._durationv)
                        _total = loader._durationv;
                    if (_fd > loader._fd)
                        _fd = loader._fd;
                    if (_date > loader._datev)
                        _date = loader._datev;
                    if (_nb > loader._nb)
                        _nb = loader._nb;
                }
            }
        }
        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(DirConf source)
        {
            this.source = source;
            source.addBorderObs(this);
            source.Auto = this;
        }

        // private static bool loaded; 
        public static void getLoaders()
        {
            //if (loaded)
            //    return;
            //loaded = true;
            foreach (AutoBuilder auto in list)
                auto.buildLoaders();
        }

        //public static void test()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.go();
        //}

        private static AutoBuilder main;
        public static void build(XmlNode xAuto, DirConf source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        mem.dict.Add(key, desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                List<string> toRemove = new List<string>();
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        toRemove.Add(key);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }

                foreach (string key in toRemove)
                    mem.dict.Remove(key);
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    //{
                    //    //if (!exist)
                    //    //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                    //    tw.Write(DateTime.Now); tw.Write(SEP);
                    //    tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(atomicMode); tw.Write(SEP);
                    //    tw.Write(state); tw.Write(SEP);
                    //    for (int i = 0; i < imax; i++)
                    //    {
                    //        if (i > 0)
                    //        {
                    //            tw.WriteLine();
                    //            for (int j = 0; j < 11; j++)
                    //                tw.Write(SEP);
                    //        }
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].item);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].item);
                    //        tw.Write(SEP);
                    //    }
                    //    tw.WriteLine();
                    //}
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            choose = null;
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            // bool trou = false;
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect);
                item.setTension(up, strict, checkSelect);
                if (item.Stop(_stopLevel))
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    // trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                //var _gap = Math.Abs(aux);
                //if (_gap < gap)
                //    gap = _gap;

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            //if (trou && conf.gap && gap < double.MaxValue)
            //{
            //    foreach (AutoBuilderItem item in items)
            //    {
            //        if (item.Stop)
            //            continue;
            //        item.gap(up, conf.selectFix, gap);
            //    }
            //}
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);

                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                if (delta * lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (choose != null && _stopLevel > 0)
                    {
                        log("retour arrière");
                        _stopLevel--;
                        choose.stop(_stopLevel);
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                    else
                    {
                        if (delta > 0)
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            return true;
                        }
                        else
                        {
                            _stopLevel--;
                            choose.stop(_stopLevel);
                            canGo = false;
                            mustUpdate = true;
                            return false;
                        }
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }



                choose = null;
                if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
                    calcChoose(up, true, true);
                if (choose != null)
                    log("REEL - SELECT");
                else
                {
                    if (_stopLevel >= 2 && conf.checkSelect)
                        calcChoose(up, false, true);
                    if (choose != null)
                        log("VIRTUEL SELECT");
                    else
                    {
                        if (_stopLevel >= 1 && conf.checkStrict)
                            calcChoose(up, true, false);
                        if (choose != null)
                            log("REEL");
                        else
                        {
                            if (_stopLevel >= 0)
                            {
                                calcChoose(up, false, false);
                                if (choose != null)
                                    log("VIRTUEL");
                            }
                        }
                    }
                }


                if (choose == null)
                {
                    log("choose null");
                    _stopLevel--;
                    if (_stopLevel < 0)
                    {
                        state = builderstate.stable;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (conf.checkEvol)
                    {
                        // var nextTrack = choose.rejected(real).candidat;
                        var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                        if (delta < size)
                        {
                            _stopLevel--;
                            // choose.stop();
                            if (conf.stopAll)
                            {
                                foreach (AutoBuilderItem item in items)
                                    item.stop(_stopLevel);
                                //state = builderstate.stable;
                                //return true;
                            }
                            else
                            {
                                choose.stop(_stopLevel);
                            }
                        }
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    bool exist = File.Exists(file);
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
            {
                item.Candidat = null;
                item.limit = null; 
                item.setTension();
            }
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }

            setDelta();


        }

        public static void SetDelta()
        {
            foreach (AutoBuilder item in list)
            {
                item.setDelta();
            }
        }

        private void setDelta()
        {
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
        }

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }



                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        if (conf.forfaitNegatif > 0 && true ==  useForfait)
                        {                         
                            useForfait = false;
                        }
                        else
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            useForfait = null;
                            return true;
                        }
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null && _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop(_stopLevel);
                            }
                        }
                        return false;
                    }

                }

                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;

                if (up)
                    nbDown = 0;
                else
                    nbDown++;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    useForfait = null;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            useForfait = null;
                            return true;
                        }
                    }
                }

                if (_cause == null)
                {
                    log("_cause NULL");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }

                var cdv = _cause.causes;
                chooses.Clear();


                foreach (CauseDataValue cd in cdv.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Update)
                        continue;

                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;
                    item.save(cd.val);
                    chooses.Add(item);
                   // item.Cause = cd;
                    item.Candidat = cdv.candidat;
                    item.limit = cdv.limit; 

                }

                if (!up && conf.forfaitNegatif > 0)
                {
                
                    if (nbDown > conf.forfaitNegatifOffset)
                    {
                        useForfait = true;
                        foreach (var item in items)
                        {
                            var tension = item.Tension;
                            tension -= conf.forfaitNegatif * (nbDown-conf.forfaitNegatifOffset);
                            if (tension < 0)
                                tension = 0;
                            item.modif(tension);
                            chooses.Add(item);
                        }
                    }
                }

                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    bool exist = File.Exists(file);
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9}) ", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.Append(nbDown); 
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
            {

                sb.Append(item);
            }
            sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);
       //     if (nb > 1) // OUAILLE ?
                checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            if (Conf.AutoSelect)
            {
                bool selected = cause.Selected;
                if (up && selected)
                    return;
                if (!up && !selected)
                    return;
            }

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                double tot = 0;
                bool _checked = false;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val <= item.torg)
                        continue;

                    _checked = true;

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    tot += (tension * tension);
                    if (_cause != null && tot >= _cause.tension)
                        return;

                    cd.Update = true;

                }
                if (tot > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                    && (_cause == null || tot < _cause.tension))
                    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val >= item.torg)
                        continue;

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;
using Math = System.Math; 

namespace pdb.podcast.Auto
{
    class AutoBuilderItem //: IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        public TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        public double dd;
        public double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt = -1; public double Dt { get { return dt; } set { dt = value; } }
        private double tension; public double Tension { get { return tension; } }
        private int _stop = AutoBuilder.STOP_MAX;
        public bool Stop(int level) { return _stop < level; }

        public void stop(int level)
        {
            newv = lastOrg;
            org = lastOrg;
            if (_stop > level)
                _stop = level;
            save();
        }
        public void reset()
        {
            _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real, bool checkSelect)
        {

            dt = getDt(up, real, checkSelect);
        }

        public void setTension()
        {
            tension = _getTension(org);
        }

        private double getDt(bool up, bool real, bool checkSelect)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real, checkSelect);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real, bool selected)
        {
            return _getTension(up, real, selected) / conf.coeff;
        }

        public double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                default: return -1;

            }

        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                default: return new TimeSpan();

            }
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict, bool checkSelect)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                int ifin = 2;
                bool bselect = !up;
                if (checkSelect)
                {
                    ifin = 1;
                }

                CauseItem cause = null;

                for (int i = 0; i < ifin; i++)
                {
                    var _cause = list[0].getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (_cause == null)
                        continue;
                    if (cause == null)
                        cause = _cause;
                    else
                    {
                        if (up)
                        {
                            if (_cause.val < cause.val)
                                cause = _cause;
                        }
                        else
                        {
                            if (_cause.val > cause.val)
                                cause = _cause;
                        }
                    }
                }
                if (cause == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        public void save(timeSpan val)
        {
            this.newv = Math.Round(getValue(val), 8);
            save();
        }

        //public void save(double _newv)
        //{
        //    this.newv = Math.Round(_newv, 8);
        //    save();
        //}

        public void modif(double tension)
        {
            var val = this.newv == 0 ? org : this.newv;
           val = (tension / Tension) * val; 
            if (type == borderType.nb)
                val = Math.Round(val, 0);
            this.newv = Math.Round(val, 8);
            save();
        }



      
        private List<Causes> _causes = new List<Causes>();

        public TrackInfoItunes Candidat { get; set; }
       // public CauseDataValue Cause { get; set; }
        public LimitItemBase limit { get; set; }

      
        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();



        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        public void after(bool up, bool strict, bool checkSelection)
        {
            _causes = new List<Causes>();
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            //  int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                //   minStrict = 0; 
            }
            int orgValue = torg.Value;
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (checkSelection)
                {
                    if (up && candidat.Selected)
                        continue;
                    if (!up && !candidat.Selected)
                        continue;
                }
                int ifin = 2;
                bool bselect = !up;
                if (checkSelection)
                {
                    ifin = 1;
                }

                for (int i = 0; i < ifin; i++)
                {


                    var cause = causes.getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (cause == null)
                        continue;
                    if (up && cause.Ok)
                        continue;
                    if (!up && !cause.Ok)
                        continue;
                    //if (value < 0)
                    //    value = -value;
                    int value = cause.val.Value;

                    if (up)
                    {

                        if (value == min)
                        {
                            _causes.Add(causes);

                        }
                        else if (value < min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }

                    }
                    else
                    {
                        if (value >= orgValue)
                            continue;

                        if (value == min)
                        {
                            _causes.Add(causes);
                        }
                        else if (value > min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }


                    }
                }

            }
        }


        private double _getTension(double org)
        {
            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public double getTension(timeSpan org)
        {
           var _org = getValue(org);
            var t = _getTension(_org);
           // dt = t - _getTension(pertinentOrg); 

            return t; 
        }





        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            if (newv != 0 && newv != org)
            {
                sb.Append("==>");
                sb.Append(newv);
                sb.Append(" ");
            }

            sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            if (dt != -1)
            {
                sb.Append("dt="); sb.Append(dt); sb.Append(" ");
            }


            if (newv != 0 && newv != org)
            {
                sb.Append("<== ");
            }
            var causes = _causes; // getcauses(lastUp, lastStrict);

            if (Candidat != null)
            {
                sb.Append(Candidat); sb.Append(" ");
            }
            if (limit != null)
            {
                sb.Append(limit); 
            }

           

            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;

namespace pdb.podcast.Load
{
    public enum action
    {
        none,
        loadCandidat,
        //standAlone,
        phase2,
        selectionPre,
        selectionPost,
        writeLists,
        writeTracksPre,
        writeTracksPost
    }
    /// <summary>
    /// Chargeur de répertoire
    /// </summary>
    public class FeedsLoader
    {
        /// <summary>
        /// Registre des albums
        /// </summary>
        private Feeds feeds;
        /// <summary>
        /// Répertoire considéré
        /// </summary>
        private DirConf dir;

      
        private LimitsLoader limitsLoader; 
      //  private Logger log;

      

        public FeedsLoader(DirConf dir)
        {
            this.feeds = dir.Feeds;
            this.dir = dir;
            limitsLoader = new LimitsLoader(dir); 
         //   log = Logger.getLogger(dir.getPath() + "\\dir", false); 
        }

        public LimitsLoader LimitsLoader { get { return limitsLoader;  } }


        public void Action(action action)
        {
            switch (action)
            {
                case action.loadCandidat: //log.log("{0} Récupération des candidats", dir);
                    limitsLoader.loadCandidats(); 
                     break;
               // case Load.action.standAlone: standAlone(); break;
                case action.phase2: limitsLoader.phase2(); break;
                case action.selectionPre: limitsLoader.SelectionPre(); break;
                case action.selectionPost: limitsLoader.SelectionPost(); break;
                case action.writeLists: limitsLoader.WriteLists(); break;
                case action.writeTracksPre: limitsLoader.WriteTracksPre(); break;
                case action.writeTracksPost: limitsLoader.WriteTracksPost(); break; 
                default:
                    break;
            }
        }

    

        ///// <summary>
        ///// Constitution de la liste
        ///// </summary>
        //private void LoadCandidats()
        //{
        //    // 1. récupérer les candidat (logique locale Feed (nb, feedDuration...); 
        //    //log.log("****************************************************************************************");
        //    //log.log("Récupération des candidats"); 
        //    //log.log("****************************************************************************************");
            
        //    log.log( "{0} Récupération des candidats", dir);
        //    limitsLoader.loadCandidats(); 
        //    //string feedName = null;
        //    //bool histo = dir.Histo;
        //    //bool? histoAll = dir.HistoAll;
        //    //if (histo)
        //    //    feedName = dir.Name;

        //    //var logList = new List<TrackInfoItunes>();

        //    //foreach (var feed in feeds)
        //    //{
        //    //    if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))
        //    //    {
        //    //        var feedLoader = getLoader(feed.Name); // new FeedLoader(dir, feed, this, false);
        //    //        feedLoader.loadCandidats();
        //    //    }
        //    //}
        //}

       

        //private void standAlone()
        //{
        //    log.log("{0} standAlone", dir); 
        //    bool dirHisto = dir.Histo;



        //    for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
        //    {
        //        var limit = dir.Limites[i];
        //        foreach (LimitItem item in limit.Items)
        //        {
        //            int levelMin = limit.Level;
        //            int ratingMin = levelMin * 20;
        //            int duration = item.Duration;
        //            var DurationMax = TimeSpan.FromMinutes(duration);
        //            TimeSpan currentDuration = new TimeSpan();
        //            //bool durationLimitAtteinte = false;

        //            if (item.Nb == 0 || item.FeedDuration == 0 || item.Duration == 0)
        //                continue;


        //            var _depot = new SequentialDictString<TrackInfoItunes>();
        //            depot(_depot, item, depotType.load);

        //            var list = _depot.List;
        //            if (dirHisto)
        //                list.Sort(new PodCastComparer());
        //            else
        //                list.Sort(new PodCastComparerInv());

        //            foreach (TrackInfoItunes candidat in list)
        //            {
        //                if (candidat.Rating < ratingMin)
        //                    continue;
        //                if (dir.Info.HasValue)
        //                {
        //                    bool bInfo = dir.Info.Value;
        //                    if (candidat.Info != bInfo)
        //                        continue;
        //                }

        //                if (dir.Rare.HasValue)
        //                {
        //                    bool bRare = dir.Rare.Value;
        //                    if (candidat.Rare != bRare)
        //                        continue;
        //                }

        //                if (!control(candidat, item,false))
        //                    continue;

        //                // enregistrement pour stockage et stats
        //              //  dir.recordTrackStandAlone(candidat, item);
        //                currentDuration += candidat.Duration;




        //                candidat.select(selectMode.standAlone, item);

        //                //  feeds.recordTrack(candidat, item);

        //                if (currentDuration > DurationMax)
        //                {
        //                    //if (!durationLimitAtteinte)
        //                    //{
        //                    //Logger.getLogger(dir.getPath() + "\\dir", false).log("duration {0}", (currentDuration + candidat.Duration).TotalMinutes.ToString("0"));
        //                    //item.DurationLimitAtteinte = true;
        //                    //}
        //                    //durationLimitAtteinte = true;
        //                    break;
        //                }

        //            }


        //        }
        //    }
        //}



        //private FeedLoader getLoader(string album)
        //{
        //    var loader = loaders.Find(l => l.feed.Name == album);
        //    if (loader == null)
        //    {
        //        loader = new FeedLoader(dir, feeds[album], this);
        //        loaders.Add(loader);
        //    }
        //    return loader;
        //}

        //private void depot(IDictionary<string, TrackInfoItunes> depot, LimitItem item, depotType type)
        //{
        //    foreach (var loader in loaders)
        //    {
        //        loader.depot(depot, item, type);
        //    }
        //}



        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
           // getLoader(track.Album).recordTrackFromChild(track, itemSource);
            limitsLoader.recordTrackFromChild(track, itemSource, transmitTotal); 
        }

    


        //private bool control(TrackInfoItunes track, LimitItem item, bool select)
        //{
        //    //var loader = getLoader(track.Album);
        //    //return loader.control(track, item,select);
        //}

        ///// <summary>
        ///// Enregistrement d'un candidat 1ere phase
        ///// </summary>
        ///// <param name="track"></param>
        //public void recordCandidat(TrackInfoItunes track)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    if (!dict.ContainsKey(location))
        //    {
        //        dict.Add(location, track);
        //    }
        //}

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        public timeSpan _durationv;
        public timeSpan _datev;
        public timeSpan _fd;

        public int _nb;

        public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        {
            BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

            int nbMin = int.MaxValue;
            timeSpan fdMin = timeSpan.MaxValue;
            timeSpan dMin = timeSpan.MaxValue;
            timeSpan dateMin = timeSpan.MaxValue;
            foreach (FeedLimitItemLoader loader in loaders.Values)
            {
                loader.checkV(nb, fd);
                var _nb = loader.NbV;
                var _fd = loader.FdV;
                if (_nb > nb && _nb < nbMin)
                    nbMin = _nb;
                if (_fd > fd && fd < fdMin)
                    fdMin = _fd;
                for (int i = 0; i <= loader.IndexV; i++)
                {
                    var track = loader.Candidats[i];
                    if (dict.ContainsKey(track.Location))
                        continue;
                    var _d = currentDuration + track.Duree;
                    if (_d > d && d < dMin)
                        dMin = _d;
                    var _date = track.Ts;
                    if (_date > date && _date < dateMin)
                        dateMin = _date;
                    break;
                }



            }

            this._durationv = dMin;
            this._datev = dateMin;
            this._nb = nbMin;
            this._fd = fdMin;
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                var loader = getLoader(candidat.Album);
                loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            legacy = new SequentialDictString<TrackInfoItunes>();
            legacyRelax = new SequentialDictString<TrackInfoItunes>();
            selected = new SequentialDictString<TrackInfoItunes>();
            exclu = new SequentialDictString<TrackInfoItunes>();

            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();
            use = new List<TrackInfoItunes>();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            trackDurationMax = new timeSpan();
            trackDurationMin = new timeSpan();
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;
            if (relax.Count > 0)
            {
                if (histo)
                    relax.Sort(new PodCastComparer());
                else
                    relax.Sort(new PodCastComparerInv());
                selection(relax, false, false);
            }

            var list = legacy.List;
            if (list.Count > 0)
            {
                if (histo)
                    list.Sort(new PodCastComparer());
                else
                    list.Sort(new PodCastComparerInv());
                selection(list, false, true);
            }





            var list2 = standAlone.List;
            if (list2.Count > 0)
            {
                if (histo)
                    list2.Sort(new PodCastComparer());
                else
                    list2.Sort(new PodCastComparerInv());

                selection(list2, true, true);
            }

        }




        private void selection(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat.Album);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax;

                bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    var newDuration = currentDuration + candidat.Duree;
                    okTotalDuration = newDuration <= durationMax;
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

                    }

                    if (_control)
                    {
                        //currentDurationVirtual += candidat.Duree;
                        if (okDate)
                            currentDuration += candidat.Duree;
                    }


                    // newDuration = currentDuration;
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    //  okTotalDuration = newDuration <= durationMax;



                    //okTotalDuration = newDuration <= durationMax;
                    //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

                    //if (okDate && _control)
                    //    currentDuration += candidat.Duree;
                    //currentDurationVirtual = currentDuration; // += candidat.Duree;

                    //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    //  bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {


                        var _fd = loader.getCurrentDuration(false);

                        if (_fd > newDuration)
                        {
                            newDuration = _fd;
                            okTotalDuration = newDuration <= durationMax;
                        }
                        if (_control)
                        {
                        }
                        else
                        {
                            //var fd = loader.getCurrentDuration(true);
                            //var nb = loader.getNb(true);

                            //newDuration = new timeSpan();
                            //foreach (FeedLimitItemLoader l in loaders.Values)
                            //    l.phaseTest();
                            //for (int j = 0; j <= index; j++)
                            //{
                            //    TrackInfoItunes t = list[j];
                            //    var subloader = getLoader(t.Album);
                            //    var subok = subloader.test(nb, fd, t);
                            //    if (j >= subloader.IndexBase)
                            //    {
                            //        if (subok || selectedByFd.ContainsKey(location))
                            //            newDuration += t.Duree;
                            //    }

                            //}
                            //// newDuration += getDuration(nb, fd);

                            //if (newDuration < currentDuration)
                            //{
                            //}
                            //else if (newDuration > currentDurationVirtual)
                            //{
                            //}
                            //okTotalDuration = newDuration <= durationMax;
                        }


                        //question fd
                        //if (!loader.LoadEqSel)
                        //{

                        var causeReg0 = limit.Dir.CauseRegister;
                        if (!causeReg0.IsNull)
                        {
                            var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                          loader.OkFd, loader.getDurationStop(okDate)
                          , loader.OkNb, loader.getNbStop(okDate)
                          , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                            causeReg0.signal(dataRoot);
                        }

                        if (limit.canSignal())
                        {

                            var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                                //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                                //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                                //, okTotalDuration, newDuration, candidat, limit);
                                    loader.OkFd, _fd// loader.getCurrentDuration (false)
                            , loader.OkNb, loader.getNb(false)
                            , okTotalDuration, newDuration, candidat, limit);

                            limit.signal(dataAuto);
                        }
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    newDuration = currentDuration;
                    okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }


        private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat.Album);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax;

                bool okprovi = okDate && okTotalDuration;
                bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    var newDuration = currentDuration + candidat.Duree;
                    okTotalDuration = newDuration <= durationMax;
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

                    }

                    if (_control)
                    {
                        //currentDurationVirtual += candidat.Duree;
                        if (okDate)
                            currentDuration += candidat.Duree;
                    }


                    // newDuration = currentDuration;
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    //  okTotalDuration = newDuration <= durationMax;



                    //okTotalDuration = newDuration <= durationMax;
                    //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

                    //if (okDate && _control)
                    //    currentDuration += candidat.Duree;
                    //currentDurationVirtual = currentDuration; // += candidat.Duree;

                    //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    //  bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {


                        var _fd = loader.getCurrentDuration(false);

                        if (_fd > newDuration)
                        {
                            newDuration = _fd;
                            okTotalDuration = newDuration <= durationMax;
                        }
                        if (_control)
                        {
                        }
                        else
                        {
                            //var fd = loader.getCurrentDuration(true);
                            //var nb = loader.getNb(true);

                            //newDuration = new timeSpan();
                            //foreach (FeedLimitItemLoader l in loaders.Values)
                            //    l.phaseTest();
                            //for (int j = 0; j <= index; j++)
                            //{
                            //    TrackInfoItunes t = list[j];
                            //    var subloader = getLoader(t.Album);
                            //    var subok = subloader.test(nb, fd, t);
                            //    if (j >= subloader.IndexBase)
                            //    {
                            //        if (subok || selectedByFd.ContainsKey(location))
                            //            newDuration += t.Duree;
                            //    }

                            //}
                            //// newDuration += getDuration(nb, fd);

                            //if (newDuration < currentDuration)
                            //{
                            //}
                            //else if (newDuration > currentDurationVirtual)
                            //{
                            //}
                            //okTotalDuration = newDuration <= durationMax;
                        }


                        //question fd
                        //if (!loader.LoadEqSel)
                        //{
                        var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                      loader.OkFd, loader.getDurationStop(okDate)
                      , loader.OkNb, loader.getNbStop(okDate)
                      , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                        limit.Dir.CauseRegister.signal(dataRoot);

                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                            //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                            //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                            //, okTotalDuration, newDuration, candidat, limit);
                                loader.OkFd, _fd// loader.getCurrentDuration (false)
                        , loader.OkNb, loader.getNb(false)
                        , okTotalDuration, newDuration, candidat, limit);

                        limit.signal(dataAuto);
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    newDuration = currentDuration;
                    okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;

using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.util;
using pdb.podcast.Report;
using System.Xml;
using pdb.podcast.Selection;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        public loadState state;
      //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            this.limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
          //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void getLoaders(List<LimitItemLoader> list)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].getLoaders(list);
            }
        }

        private bool candidatLoaded;
        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                return; 
            }
            try
            {
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null && track.Album != feedName)
                        continue;

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparer());
                else
                    loaded.Sort(new PodCastComparerInv());


                for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                state = loadState.selection;
                candidatLoaded = true;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        {

            if (!recordGuests)
                return;


            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordGuest(track, item);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
            }
        }


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        if (Conf.WriteItems)
                        {
                            items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                            buildList(item.Item.ID, items, "_sel");
                        }

                        if (Conf.WritePreSel)
                        {
                            items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                            buildList(item.Item.ID, items, "_sel0");
                        }
                        if (Conf.WriteUse)
                        {
                            items = item.use;
                            buildList(item.Item.ID, usegenPrior, items, "_use");
                        }
                        if (Conf.WriteExclu)
                        {
                            var limite = item.Item;
                            items = item.use.FindAll(t => t.Exclu == limite);
                            buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        }

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("date", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                    writer.SetAttribute("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparerPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    writer.StartElement("i");
                    writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());

                    writeTracks(dir, lim.Stat, null, false);

                    writer.EndElement();
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            //log.log("{0} Selection", dir);

            for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Selection\CauseRegister.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;

namespace pdb.podcast.Selection
{
   
   public class CauseRegister
    {
        private BgDictString0<Causes> dict = new BgDictString0<Causes>();
        public void Clear() { dict.Clear(); }
        public virtual bool IsNull { get { return false; } }
        public Causes Get(TrackInfoItunes candidat)
        {
            Causes causes = null;
            string loc = candidat.Location;
            if (!dict.ContainsKey(loc))
            {
                causes = new Causes(candidat);
                dict.Add(loc, causes);
                return causes;
            }
            return dict[loc];
        }
        public virtual void signal(CauseDatas cd)
        {
            var causes = Get(cd.candidat);
            causes.check(cd); 
        }

        public List<Causes> getList(bool onlyRejected)
        {
            var list = new List<Causes>(dict.Values);
            list.Sort(new CauseComparer());
            if (!onlyRejected)
                return list;
            else
            {
                var aux = new List<Causes>();
               
                foreach (Causes causes in list)
                {
                    if (!causes.candidat.Selected)
                        aux.Add(causes);
                }
                return aux;
            }
            
        }

        private class CauseComparer : IComparer<Causes>
        {
            public int Compare(Causes x, Causes y)
            {
                return x.candidat.Pub.CompareTo(y.candidat.Pub);
            }
        }
    }

    class NullRegister : CauseRegister
    {
        public override bool IsNull
        {
            get
            {
                return true; 
            }
        }

        public override void signal(CauseDatas cd)
        {
            throw new NotSupportedException(); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\Causes.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;

namespace pdb.podcast.Selection
{
    public class Causes
    {
        public Causes(TrackInfoItunes candidat)
        {
            this.candidat = candidat;
        }
        public readonly TrackInfoItunes candidat;
        public const int NB_TYPE = 4;
        private const int NB_MODE =8; 
        private CauseItem[,] causes = new CauseItem[NB_MODE, NB_TYPE];
        //private CauseItem[] causesStrict = new CauseItem[NB];

        //private CauseItem[] causesRejet = new CauseItem[NB];
        //private CauseItem[] causesRejetStrict = new CauseItem[NB];
       // private bool selected;

        //public void check(bool okDate, timeSpan vdate,
        //                  bool okFd, timeSpan vfd,
        //                  bool okNb, int nb,
        //                  bool okD, timeSpan vd,
        //                  LimitItemBase limit)
        //{

        //    check(okDate, borderType.maxdate, vdate, limit);

        //    check(okFd, borderType.fd, vfd, limit);

        //    check(okNb, borderType.nb, timeSpan.FromMinutes(nb), limit);

        //    check(okD, borderType.d, vd, limit);

        //}

        public virtual void check(CauseDatas cd)
        {
            //if (cd.candidat.Name == "Littérature chinoise en ligne 14.11.12")
            //{
            //}
            int nb = 0;
            int nbSuccess = 0;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                nb++;
                if (cdv.Ok)
                    nbSuccess++;
                if (!cdv.Virtuel)
                    check(cdv, cd.limit, false);  //(cdv.ok, cdv.type, cdv.val, cd.limit, false);
            }
            if (nb < 2)
                return;
            if (nbSuccess < nb - 1)
                return;
            bool thisSuccess =  nbSuccess == nb;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                if (cdv.Virtuel)
                    continue;
                if (thisSuccess)
                    check(cdv, cd.limit, true); //(cdv.ok, cdv.type, cdv.val, cd.limit, true);
                else
                {
                    if (cdv.Ok)
                        continue;
                    check(cdv, cd.limit,true); //   cdv.ok, cdv.type, cdv.val, cd.limit, true);
                }
            }

            //if (!selected && thisSuccess)
            //{
            //    int mode = getMode(true, true);
            //    selected = true;
            //    for (int i = 0; i < NB; i++)
            //        causes[mode,i] = null;
            //}

            //if (selected)
            //{
            //    if (thisSuccess)
            //    {
            //        foreach (CauseDataValue cdv in cd.datas)
            //        {
            //            if (cdv == null)
            //                continue;
            //            if (cdv.virtuel)
            //                continue;
            //            check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //        }
            //    }
            //}
            //else
            //{
            //    foreach (CauseDataValue cdv in cd.datas)
            //    {
            //        if (cdv == null)
            //            continue;
            //        if (cdv.ok)
            //            continue;
            //        if (cdv.virtuel)
            //            continue;
            //        check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //    }
            //}
        }

        //private int getMode(bool strict, bool ok, bool selected)
        //{
        //    return 4 * Convert.ToInt32(strict) + (int)Conv.getMode(ok, selected);
        //}

        private int getMode(byte mode,  bool strict)
        {
            return 4 * Convert.ToInt32(strict) + (int)mode;
        }

        private void check(CauseDataValue cd, LimitItemBase limit, bool strict)
        {
            int index = (int)cd.type;
            int mode = getMode((byte)cd.mode, strict);

            if (mode < 0 || index < 0 || mode >= NB_MODE || index >= NB_TYPE)
            {
                misc.log("oups mode={0} index={1} {2} {3}", mode, index, limit, cd );
                return; 
            }
            CauseItem cause = causes[mode, index];


            if (cause == null)
            {
                causes[mode, index] = new CauseItem(cd, limit);
            }
            else
            {
                bool record = false;
                var ok = cd.Ok;
                var val = cd.val; 
                if (ok && val.Value > cause.val.Value)
                    record = true;
                else if (!ok && val.Value < cause.val.Value)
                    record = true;
                if (record)
                    causes[mode, index] = new CauseItem(cd, limit);
            }
        }


        //private void check(bool ok, borderType type, timeSpan val, LimitItemBase limit, bool strict, bool selected)
        //{
        //    int index = (int)type;
        //    int mode = getMode(strict, ok, selected);

        //    // virtuel nok -> 0
        //    // virtuel ok -> 1
        //    // strict nok -> 2
        //    //strict ok -->3

        //    CauseItem cause = causes[mode, index];


        //    if (cause == null)
        //    {
        //        causes[mode, index] = new CauseItem(type, ok, val, limit,selected);
        //    }
        //    else
        //    {
        //        bool record = false;
        //        if (ok && val.Value > cause.val.Value)
        //            record = true;
        //        else if (!ok && val.Value < cause.val.Value)
        //            record = true;
        //        if (record)
        //            causes[mode, index] = new CauseItem(type, ok, val, limit,selected);
        //    }

        //}

        public List<CauseItem> getCauses(bool strict, bool ok, bool selected)
        {
            var m = Conv.getMode(ok, selected); 
            int mode = getMode(m, strict);
            var list = new List<CauseItem>();
            // var causes = strict ? this.causesStrict : this.causes;
            for (int i = 0; i < NB_TYPE; i++)
            {
                var cause = causes[mode, i];
                if (cause != null) // && cause.val.Value >0)
                    list.Add(cause);
            }

            return list;
        }

        public CauseItem getCause(borderType type, bool strict, bool ok, bool selected)
        {
            //var causes = strict ? this.causesStrict : this.causes;
            var mode = Conv.getMode(ok, selected); 
            return causes[getMode(mode,strict), (int)type];
        }

        public override string ToString()
        {
            var sb = new pdb.util.StringBuilder();
            sb.Append(candidat);
            sb.AppendLine();
            foreach (CauseItem item in causes)
            {
                if (item != null)
                    sb.AppendLine(item.ToString());
            }
            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = ""; 
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        private bool transmit = true;
        private bool transmitTotal = true;
        private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private Journal journal;
        private RootIt rootIt = new RootIt(); 
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true; 

        // private Auto auto = null;
        private bool logGen = true;
        private DateTime date0;
        private DateTime date00;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir; 

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private Albums albums = new Albums();


        private bool checkPub = true;

        private bool useMock; 


        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        public static bool Transmit { get { return Instance.transmit; } }
        public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }
        public static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }
      
        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static Albums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
      
      

        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle"); 

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            transmit = l_xmlConf.getBoolValue("transmit");
            transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            str = l_xmlConf.getNodeValue("date0");
            if (!string.IsNullOrEmpty(str))
                date0 = Convert.ToDateTime(str);

            str = l_xmlConf.getNodeValue("date00");
            if (!string.IsNullOrEmpty(str))
                date00 = Convert.ToDateTime(str);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            XmlElement xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir); 
            buildDirChilds(xDir, root);

           // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.getNode("select");
            foreach (XMLTool xsub in xSelect)
                selectParams.Add(new SelectParam(xsub));

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false); 

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new Albums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb); 


            Logger.CreateNullLoggers = createNullLoggerOrg;

          
            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node); 
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.build(node, child);
                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);

                       

                        if (child.Attributes["all"] != null)
                        {
                            sub.HistoAll = child.Attributes["all"].Value == "true";
                        }
                        if (child.Attributes["serial"] != null)
                        {
                            sub.Serial = child.Attributes["serial"].Value == "true";
                        }

                        if (child.Attributes["cascading"] != null)
                            sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        if (child.Attributes["transmit"] != null)
                            sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        if (child.Attributes["transmitTotal"] != null)
                            sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        if (child.Attributes["transmitTotalGuest"] != null)
                            sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToInt32(strTd);

            AutoBuilder.setClient(item, child); 

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        private static bool date00Consumed;
        public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                if (Instance.date00 == DateTime.MinValue || date00Consumed)
                    return Instance.date0;
                return Instance.date00; 
            }
        }

        public static DateTime NewDate0
        {
            get
            {
                return Instance.date0;
            }
        }

        public static DateTime getDate(string str)
        {
            //int delta = -1;
            double d = -1;
            if (Date0 > DateTime.MinValue)
                //{
                //    if (int.TryParse(str, out delta))
                //    {
                //        int dt = delta;
                //        if (delta % 365 == 0)
                //        {
                //            dt = delta / 365;
                //            return Date0.AddYears(dt);
                //        }

                //        if (delta % 30 == 0)
                //        {
                //            dt = delta / 30;
                //            return Date0.AddMonths(dt);
                //        }
                //        return Date0.AddDays(delta);
                //    }
                //    else
                if (double.TryParse(str, out d))
                {
                    return Date0.AddDays(d);
                }
            //       }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            buildLimitItem(child, xItem, item);
                            item.TdMin = tdMin;

                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    lcurrentNb = currentItem.LoadNb;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNbMax(currentNb, false);
                    _limitItem.LoadNb = lcurrentNb;
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false); 
                    _limitItem.Contribution = currentContrib;

                    

                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNbMax(dir.Nb,true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration,true);
                        if (_limitItem.LoadFeedDuration == int.MaxValue)
                            _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax,true);
                    }

                    _limitItem.setParent(dir); 

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
using System;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>//, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
        private DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }

        private CauseRegister _causeRegister;
        internal CauseRegister CauseRegister
        {
            get
            {
                if (_causeRegister != null)
                    return _causeRegister;
                if (parent == null)
                    return null;
                return parent.CauseRegister;
            }
        }

        private Feeds feeds;
        internal Feeds Feeds
        {
            get
            {
                if (feeds != null)
                    return feeds;
                if (parent == null)
                    return null;
                return parent.Feeds;
            }
        }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            if (childs.Contains(dir))
                return;
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }

        public void buildLoaders(List<LimitItemLoader> list, AutoBuilder auto)
        {
            if (auto != Auto)
                return;
            var loader = Loader;
            var fl = loader.LimitsLoader;
            fl.getLoaders(list);
            foreach (DirConf sub in childs)
            {
                sub.buildLoaders(list, auto);
            }
        }

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            if (offset > DateTime.MinValue)
            {
                track.Offset = offset;
                offset = offset.AddDays(1);
            }
            conteneur.recordTrack(track, limit);
            if (parent != null)
                parent.recordTrackFromChild(track, limit, this);
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());
            log.log("");
            log.log(getPath() + " getListe " + list.Count + " elt.");
            foreach (TrackInfoItunes track in list)
            {
                log.log(track.ToString());
            }
            return list;
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        {
            if (dirSource.transmitToParent)
                Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
            if (parent != null)
                parent.recordTrackFromChild(track, itemSource, this);
        }

        /// <summary>
        /// Abandonné
        /// </summary>
        public void TransmissionListToParent(TrackInfoItunes track)
        {
        }


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}








        public Limits Limites { get { return limites; } set { limites = value; } }


        private static Dict<string, DirConf> dict = new Dict<string, DirConf>();
        public static DirConf getDir(Limits limites, string name, DirConf parent)
        {
           return new DirConf(limites, name, parent); 
            string path = getPath(parent, name);


            var d = dict[path];
            if (d == null)
            {
                d = new DirConf(limites, name, parent);
                dict[path] = d;
            }
            else
            {
                d.init(limites, name, parent);
            }

            return d;

        }


        private DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            init(limites, name, parent);
        }

        private void init(Limits limites, string name, DirConf parent)
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
            {
                conteneur = new TrackConteneur(this, null, log);
                feeds = new Feeds();
                if (Conf.Html.writeCause <= 0)
                {
                    _causeRegister = new NullRegister();
                }
                else
                    _causeRegister = new CauseRegister();
            }
            else
                conteneur = new TrackConteneur(this, parent.conteneur, log);
            transmitToParent = Conf.Transmit;
            transmitTotal = Conf.TransmitTotal;
            transmitTotalGuest = Conf.TransmitTotalGuest;
            cascading = Conf.Cascading;
        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }

        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
        }

        private bool serial;
        public bool Serial { get { return serial; } set { serial = value; } }

        /// <summary>
        /// Généralisation de l'historique à tous les noeuds enfant ou simple sélection nominative(par album)
        /// </summary>
        private bool? histoAll;
        public bool? HistoAll
        {
            get
            {
                if (histoAll.HasValue)
                    return histoAll;
                if (parent == null)
                    return null;
                return parent.HistoAll;
            }
            set
            {
                histoAll = value;
            }
        }

        private bool? cascading;
        public bool Cascading
        {
            get
            {
                if (cascading.HasValue)
                    return cascading != false;
                if (false == histoAll)
                    return false;
                if (parent == null)
                    return true;
                return parent.Cascading;
            }
            set
            {
                cascading = value;
            }
        }

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                cascading = value;
            }
        }

        private bool transmitToParent = true;
        public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        private bool transmitTotal = true;
        public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        private bool transmitTotalGuest = true;
        public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            return getPath(parent, name);
        }

        public static string getPath(DirConf parent, string name)
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodCastComparer());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            return Feeds.LoadedTracks;
        }


        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }


        private AutoBuilder auto;
        public AutoBuilder Auto
        {
            get
            {
                if (auto != null)
                    return auto;
                if (parent != null)
                    return parent.Auto;
                return null;
            }
            set
            {
                auto = value;
            }
        }
        #region IBorder
        private List<AutoBuilder> borderObs = new List<AutoBuilder>();
        public void addBorderObs(AutoBuilder auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            if (false == HistoAll)
                return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(tb);
        }


        public bool canSignal()
        {
            return true; 
            if (false == HistoAll || serial) //OUAILLE?
                return false;
            return true; 
        }

        public void signal(CauseDatas cd)
        {
            //if (false == HistoAll || serial) //OUAILLE?
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(cd);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(cd);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItem.cs">
    <content><![CDATA[using System;
using pdb.util;
using pdb.podcast.Report;
using pdb.podcast.Auto;
using System.Collections.Generic;
using pdb.podcast.Selection;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Item de limite concernant la durée 
    /// </summary>
    public class LimitItem : LimitItemBase//, IBuilderSource, IBorder
    {


        /// <summary>
        /// Détailler le rapport - à bouger
        /// </summary>
        public static bool includeDetail;


        public int Level { get { return limit.Level; } }
        public int Rating { get { return limit.Level * 20; } }



        private Limit limit;
        private TripleStat stats = new TripleStat();


        public override string ToString()
        {
            if (nb == 0 || feedDuration == 0)
                return Dir.ToString() + string.Format("\\{0}", limit.Level);
            return Dir.ToString() + string.Format("\\{0}:{1} {2} {3} {4} {5} {6} {7} {8} {9}", limit.Level, getS("d", duration), getS("c", contribution), getS("fd", feedDuration), getS("nb", nb), getS("td", td), getS("tdMin", tdMin), getS("date", dateMin), getS("dateMax", dateMax), getS("dateMax2",dateMax2));
        }

        private static string getS(string desc, int v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, double v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, DateTime v)
        {
            if (v > DateTime.MinValue && v < DateTime.MaxValue)
                return string.Format("{0}={1}", desc, v);
            return "";
        }



        public void recordTrackMoy(TrackInfoItunes track, int countItems)
        {
            stats.recordTrack(track, countItems);
        }


        private bool durationLimitAtteinte;
        private bool contributionLimitAtteinte;
        private bool durationFeedLimit;
        private bool nbFeedLimit;
        public bool DurationLimitAtteinte { get { return durationLimitAtteinte; } set { durationLimitAtteinte = value; } }
        public bool ContributionLimitAtteinte { get { return contributionLimitAtteinte; } set { contributionLimitAtteinte = value; } }
        //private bool loadDurationLimitAtteinte;
        //public bool LoadDurationLimitAtteinte { get { return loadDurationLimitAtteinte; } set { loadDurationLimitAtteinte = value; } }

        public bool DurationFeedLimit { set { durationFeedLimit = value; } get { return durationFeedLimit; } }
        public bool NbFeedLimit { set { nbFeedLimit = value; } get { return nbFeedLimit; } }

        #region border
        //public bool checkPub(TrackInfoItunes candidat)
        //{
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //        return false;
        //    if (d > dateMax)
        //        return false;
        //    return true;
        //}
        #endregion
        //#region border
        ///// <summary>
        ///// track In le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinOut;

        ///// <summary>
        ///// track In le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationOut;

        //TimeSpan borderDurationValueIn;
        //TimeSpan borderDurationValueOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée de feed
        ///// </summary>
        //TrackInfoItunes borderFdIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée Feed
        ///// </summary>
        //TrackInfoItunes borderFdOut;

        //TimeSpan borderFdValueIn;
        //TimeSpan borderFdValueOut; 

        //public void clearBorder()
        //{
        //    borderDateMinIn = null;
        //    borderDateMinOut = null;
        //    borderDateMaxIn = null; 
        //    borderDateMaxOut = null;
        //    borderDurationIn = null;
        //    borderDurationOut = null;
        //    borderDurationValueIn = new TimeSpan();
        //    borderDurationValueOut = new TimeSpan();

        //    borderFdIn = null;
        //    borderFdOut = null;
        //    borderFdValueIn = new TimeSpan();
        //    borderFdValueOut = new TimeSpan(); 
        //}



        //// --------vIn----limit ------vout
        //public void checkBorderFd(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.feedDuration )
        //    {
        //        if (borderFdIn == null || duration > borderFdValueIn )
        //        {
        //            borderFdIn = candidat;
        //            borderFdValueIn = duration;
        //        }
        //    }
        //    else if (!selected && duration.TotalMinutes > this.feedDuration)
        //    {
        //        if (borderFdOut == null || duration < borderFdValueOut)
        //        {
        //            borderFdOut = candidat;
        //            borderFdValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //    }

        //public void checkBorderDuration(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.duration)
        //    {
        //        borderDurationIn = candidat;
        //        borderDurationValueIn = duration;
        //    }
        //    else if (!selected && duration.TotalMinutes > this.duration)
        //    {
        //        if (borderDurationOut == null)
        //        {
        //            borderDurationOut = candidat;
        //            borderDurationValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //}

        //public void checkBorderDates(TrackInfoItunes candidat, bool selected)
        //{
        //    // ---minOut --limit ---minIn ----
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //    {
        //        if (borderDateMinOut == null ||d > borderDateMinOut.Pub )
        //            borderDateMinOut = candidat;
        //    }
        //    else if (d>=dateMin && selected)
        //    {
        //        if (borderDateMinIn == null || d < borderDateMinIn.Pub)
        //            borderDateMinIn = candidat;

        //    }
        //    // ---maxIn --limit ---maxOut ----
        //    if (d > dateMax)
        //    {
        //        if (borderDateMaxOut == null || d < borderDateMaxOut.Pub)
        //            borderDateMaxOut = candidat;
        //    }
        //    else if (d <= dateMax &&selected)
        //    {
        //        if (borderDateMaxIn == null || d >borderDateMaxIn.Pub )
        //            borderDateMaxIn = candidat;
        //    }
        //}



        //#endregion

        public void writeStat(ITextWriter sbRapport)
        {
            writeStatHeader(sbRapport);
            stats.buildValues(sbRapport);

        }

        private LimitItemStat stat;
        internal LimitItemStat Stat
        {
            set
            {
                if (stat == null)
                    stat = value;
            }
            get { return stat; }
        }

        public void writeStatHeader(ITextWriter sbRapport)
        {
            //    if (loadDurationLimitAtteinte)
            //        sbRapport.Append("d");
            //    else
            //        sbRapport.Append(" ");

            if (durationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");



            if (durationFeedLimit)
                sbRapport.Append("f");
            else
                sbRapport.Append(" ");

            if (nbFeedLimit)
                sbRapport.Append("n");
            else
                sbRapport.Append(" ");

            if (contributionLimitAtteinte)
                sbRapport.Append("c");
            else
                sbRapport.Append(" ");
            sbRapport.Append(" ");

        }

        public void getToTaux(ITextWriter sb)
        {

        }

        public void rapport(DescBuilder sb)
        {
            sb.Append("\t");
            //sb.Append(Dir.getPath());
            //sb.Append(" ");
            sb.Append(ToString());
            sb.Append(" ");
        }

        public DirConf Dir { get { return limit.Dir; } }
        public string id = null;
        public string ID
        {
            get
            {
                if (id == null)
                {
                    int index = limit.index(this);
                    if (index >= 0)
                        id = Dir.getPath() + "\\" + Level + "\\_" + (index + 1);
                    else
                        id = Dir.getPath() + "\\_" + Level;

                }
                return id;
            }
        }
       // private Logger logger;

        public LimitItem(Limit limit)
        {
            this.limit = limit;
        }
        //public Logger Logger
        //{
        //    get
        //    {
        //        if (logger == null)
        //        {
        //            logger = Logger.getLogger(ID, false);
        //        }
        //        return logger;
        //    }
        //}

        public object Clone()
        {
            var limitiItem = new LimitItem(limit) { nb = this.nb, Td = this.td, TdMin = this.tdMin, DateMin = this.dateMin, Contribution = this.contribution, Stat = this.stat, dateMax2 = this.dateMax2};
            limitiItem.duration = this.duration;
            limitiItem.feedDuration = this.feedDuration;
            limitiItem.dateMax = this.dateMax;
            return limitiItem;

        }

        public Limit Limit { set { limit = value; } get { return limit; } }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>(stat.Total.Use.List);
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize();
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }


        //public void addBorderObs(IBorderTransmit auto)
        //{
        //    throw new NotImplementedException();
        //}

        public void signal(TrackBorderItem tb)
        {
            // en attendant d'implémenter les autos pour limitItem
            if (tb == null)
                return;
            switch (tb.type)
            {
                case borderType.d: if (!hduration) return;
                    break;
                case borderType.fd: if (!hfeedDuration) return;
                    break;
                case borderType.maxdate: if (!hdateMax) return;
                    break;
                case borderType.nb: if (!hNb) return;
                    break; 
                default:
                    return;
            }
            limit.signal(tb);

        }

        public bool canSignal()
        {
            return limit.Dir.canSignal(); 
        }
        public void signal(CauseDatas cd)
        {
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null)
                    continue;
                var type = data.type;

                switch (type)
                {
                    case borderType.d: if (!hduration) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.fd: if (!hfeedDuration) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.maxdate: if (!hdateMax) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.nb:
                        if (!hNb)
                            cd.datas[i].Virtuel = true; break;
                    default:
                        cd.datas[i].Virtuel = true; break;
                }

                if (cd.datas[i] != null && !cd.datas[i].Virtuel)
                    nb++;

            }

            //if (nb <= 1) // OUAILLE ? 
            //    return;
         

            this.limit.signal(cd);
        }


        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.iT.listGen\pdb.gen.it.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{76351375-3BAA-4E37-A88E-AD7E7AE6F84B}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen.it</RootNamespace>
    <AssemblyName>pdb.gen.it</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.gen.it.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.it.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.iTunesLib, Version=1.13.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>True</EmbedInteropTypes>
      <HintPath>bin\Interop.iTunesLib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="iTListWriter.cs" />
    <Compile Include="persistance\ITrackDb.cs" />
    <Compile Include="persistance\TrackDb.cs" />
    <Compile Include="persistance\TrackDbMem.cs" />
    <Compile Include="persistance\TrackPersistantId.cs" />
    <Compile Include="persistance\TracksDb.cs" />
    <Compile Include="PlayListFilter.cs" />
    <Compile Include="TextPlayListWriter.cs" />
    <Compile Include="XmlPlayListWriter.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.iit\pdb.iit.csproj">
      <Project>{2D0CCC8D-DACB-4D21-B077-D312D2338D7B}</Project>
      <Name>pdb.iit</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\pieceDb.iT\pdb.it.csproj">
      <Project>{CF5DB63F-4790-4351-9050-B30DED32F052}</Project>
      <Name>pdb.it</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
</db>
