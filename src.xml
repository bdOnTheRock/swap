<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;
           
            gen.invalidateAlbums();
             if (changing)
                return;
            go(); 
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    if (CConf.ResetOneCl)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            decimal pluspetitNonNull = int.MaxValue;
                            Piece min = null;
                            int nbnotes = 0;
                            foreach (Piece t in l)
                            {
                                //si on a au moins un noté on quitte

                                //var p = t.Track as CPiece;


                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                decimal clValue = Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                                if (clValue > zer0d)
                                {
                                    nbnotes++;
                                    if (t.LastClassementRecent || !t.Enabled)
                                    {
                                        min = null;
                                        break;
                                    }
                                    if (clValue < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = clValue;
                                        min = t;
                                    }
                                }

                            }

                            if (min != null)
                            {
                                var coeff = (decimal)nbnotes / l.Count;
                                coeff *= coeff;
                                min.setKeep(coeff);
                            }
                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }


        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;




            if (CConf.ResetOneCl)
            {
                gen.ConsolidInit(Db.List.getList());
                resetOneCl();
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(Db.List.getList(), true);
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (PlayerViewModel.Instance.CreateRot)
                {
                    resetOneCl();
                    if (refreshAlbum != null && _currentTrack != null)
                    {
                        gen.Albums.makeSort(_currentTrack.PieceGen);
                        _currentTrack.refresh();
                        refreshAlbum("", EventArgs.Empty);
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(), _updateStats); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);



                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none);

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;
                    }
                }
            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;
using pdb.gen.medianne;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion

        private CPiece piece;
        private Piece track;

        // private TrackList track;
        //  private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        //  public TrackList Track { get { return track; } }
        //   public CPiece Piece { get { return piece.Piece; } }
        // public Piece PieceGen { get { return track.Piece; } }

        public CPiece Piece { get { return piece; } }
        public Piece PieceGen { get { return track; } }
        public Piece Master { get { return track.Master; } }
        public bool Played { get { return piece.Played; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }



        private TrackListViewModel(Piece piece)
            : base(piece)
        {
            this.track = piece;
            this.piece = track.Track as CPiece;
        }
        # region registre
        #region main
        /// <summary>
        /// Registre des tracks présentés dans la grille principale
        /// </summary>
        private static BgDict<int, TrackListViewModel> dict = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// Récupère ou crée un track dans la grille principale
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreate(Piece p)
        {
            var t = dict[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dict.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel get(int id)
        {
            return dict[id];
        }
        public static IDictionary<int, TrackListViewModel> Dict { get { return dict; } }
        #endregion
        #region album
        /// <summary>
        /// Registre des tracks présentés dans la grille album
        /// </summary>
        private static BgDict<int, TrackListViewModel> dictA = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// Récupère ou crée un track dans la grille album
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreateA(Piece p)
        {
            var t = dictA[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dictA.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel getA(int id)
        {
            return dictA[id];
        }
        public static IDictionary<int, TrackListViewModel> DictA { get { return dictA; } }
        #endregion
        # endregion
        //public TrackListViewModel(TrackList track, PlayListViewModel playlist)
        //    : base(track, playlist)
        //{
        //    //this.track = track;
        //    //this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
        //    //piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
        //    //int id = track.PieceId;
        //    //if (!dictT.ContainsKey(id))
        //    //{
        //    //    var list = new List<TrackListViewModel>();
        //    //    dictT.Add(id, list);
        //    //}

        //    //dictT[id].Add(this);

        //}

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        Classement ITrackNative.Classement { get { return PieceGen.Classement; } }
        public String Classement
        {
            get
            {
                return PieceGen.Classement.ToString();
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.StrClassement = value;
                    track.invalidateCache(true);
                    App.gen.ClassementChange();

                    //piece.Classement = value;
                    // PieceGen.invalidateCache();
                    var albums = App.gen.Albums;
                    albums.signalClassChange(track);
                    if (DetailClassementViewModel.Instance.Auto)
                        albums.setUrgence();
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    OnPropertyChanged("Classement");

                    App.go(this);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                if (value != Year)
                {
                    piece.Year = value;
                    App.invalidateAlbums();
                }
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return track.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return track.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string File
        {
            get { return piece.Files.PathReduc; }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                if (value != Artist)
                {
                    piece.Artist = value;
                    App.invalidateAlbums();
                }
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    switch (track.VirtualMode)
                    {
                        case virtualMode.none:
                        break;
                        case virtualMode.artist:
                        return string.Format("[{0}]", track.Album);
                        case virtualMode.path:
                        break;
                        case virtualMode.year:
                        if (track.Album.Length == 3)
                            return string.Format("[[{0}0']]", track.Album);
                        else
                            return string.Format("[[{0}]]", track.Album);
                        case virtualMode.extended:
                        return string.Format("¤{0}", track.Album);
                        case virtualMode.added:
                        return string.Format("<{0}>", track.Album);
                        case virtualMode.word:
                        return string.Format("'{0}'", track.Album);
                        case virtualMode.list:
                        return string.Format("/{0}", track.Album);
                        default:
                        break;
                    }
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                {
                    if (value != Album)
                    {
                        piece.Album = value;
                        App.invalidateAlbums();
                    }
                }
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
            PieceGen.invalidateCache(true);

        }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        //public string ArtWork
        //{
        //    get
        //    {
        //        return piece.ArtWork;
        //    }
        //    set
        //    {
        //        piece.ArtWork = value;
        //    }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel - 1; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2 - 1; } }

        public decimal Rendement
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Rendement - 1;
            }
        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool? Exists { get { return Piece.Exists; } }
        public bool ExistsNow { get { return Piece.ExistsNow; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            piece.Parent = parent.Piece.Master;
            track.setParent(parent.track);

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);
        }

        public void fusion(TrackListViewModel toDelete)
        {

            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

            App.Db.List.fusion(piece, toDelete.Piece);
            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }
        public DateTime? MasterAlbumUpdateClassement { get { return PieceGen.MasterAlbumUpdateClassement; } }



        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }

        public bool Virtual { get { return PieceGen.Virtual; } }

        public int DeltaRank { get { return PieceGen.DeltaRank; } }


        public void setClassement(string classement)
        {
            Classement = classement;
        }


        public string strClassement
        {
            get { return Classement; }
        }

        public string MaxClassement
        {
            get { return piece.MaxClassement.ToString(); }
        }

        public string DeepClassement
        {
            get { return piece.DeepClassement.ToString(); }
        }
        pdb.obj.Classement ITrackNative.DeepClassement
        {
            get { return piece.DeepClassement; }
        }
        pdb.obj.Classement ITrackNative.MaxClassement
        {
            get
            {
                return piece.MaxClassement;
            }
        }



        public bool Keep { get { return PieceGen.Keep; } }

        public bool NoCompact { get { return !PieceGen.UseCompact; } }

        public int MainTrackNumber { get { return PieceGen.MasterTrackNumber; } }

        public int NbRecentsInAlbum { get { return PieceGen.NbRecentsInAlbum; } }
        public int NbDoneInAlbum { get { return PieceGen.NbDoneInAlbum; } }
        public string PlusPetitEnabled { get { return PieceGen.PlusPetitEnabled; } }

        public decimal KeepCoeff { get { return PieceGen.KeepCoeff; } }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn  ElementStyle="{StaticResource cb}" Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="MaxClassement" Binding="{Binding MaxClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="DeepClassement" Binding="{Binding DeepClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->

                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2"  Visibility="{Binding HasArtWork, Converter={StaticResource boolVis}}">
            <Image Source="{Binding ArtWork}" ></Image>
            <!--<ListView ItemsSource="{Binding Images}">
                <ListView.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <Image Source="{Binding}"  />
                        </StackPanel>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch" VerticalAlignment="Stretch"></StackPanel>
                    </ItemsPanelTemplate>
                </ListView.ItemsPanel>

            </ListView>-->

            <Image Source="{Binding ArtWork}" ></Image>

        </Grid>
        <GridSplitter Grid.Row="3" HorizontalAlignment="Stretch" ResizeDirection="Rows"  ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="4" VerticalAlignment="Bottom">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                VerticalAlignment="Bottom"
                                SelectedItem="{Binding SelectedTrackInAlbumsView}">
                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="RankRev" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                    <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>

                    <DataGridTextColumn Header="Done"  Binding="{Binding NbDoneInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="Current" Binding="{Binding PlusPetitEnabled,Mode=OneWay,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>

                    

                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />
                    </Style>
                </DataGrid.ItemContainerStyle>

                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>


    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="Exists" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="MaxClassement" Binding="{Binding MaxClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="DeepClassement" Binding="{Binding DeepClassement, Mode=OneWay,Converter={StaticResource cl} }"/>

                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum,Mode=OneWay}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="DeltaRank" Binding="{Binding DeltaRank, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>

                
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="DelaiMasterAlbum"  Binding="{Binding MasterAlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Mode=OneWay,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalEl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>



               
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Done"  Binding="{Binding NbDoneInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Current" Binding="{Binding PlusPetitEnabled, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>



            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" HorizontalAlignment="Left" Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Info.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.Info"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
         xmlns:l="clr-namespace:pdb.player.Vue"
        Title="Info" Height="600" Width="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
      
        <Grid Name="infos" Grid.Row="0" Margin="3" >
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>


            <CheckBox Grid.Column="0"  Name="cbName" IsChecked="{Binding ApplyName, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Column="1">Nom</TextBlock>
            <TextBox Grid.Column="2" Name="tbName" Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="1"  IsChecked="{Binding ApplyAlbum, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="1" Grid.Column="1">Album</TextBlock>
            <TextBox Grid.Row="1" Grid.Column="2" Name="tbAlbum" Text="{Binding Album, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="2" IsChecked="{Binding ApplyArtist, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="2" Grid.Column="1">Artiste</TextBlock>
            <TextBox Grid.Row="2" Grid.Column="2" Name="tbArtist" Text="{Binding Artist, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="3" IsChecked="{Binding ApplyYear, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="3" Grid.Column="1">Année</TextBlock>
            <TextBox Grid.Row="3" Grid.Column="2"  Text="{Binding Year, Mode=TwoWay, Converter={StaticResource Int}, UpdateSourceTrigger=LostFocus}" />






        </Grid>
        <l:EnhancedDataGrid Grid.Row="1" x:Name="dgInfo" x:Uid="info" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="Exists" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="MaxClassement" Binding="{Binding MaxClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="DeepClassement" Binding="{Binding DeepClassement, Mode=OneWay,Converter={StaticResource cl} }"/>

                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum,Mode=OneWay}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="DeltaRank" Binding="{Binding DeltaRank, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Mode=OneWay,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalEl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>




                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <StackPanel   Grid.Row="2" Orientation="Horizontal" VerticalAlignment="Bottom" HorizontalAlignment="Left">
            <CheckBox Content="Reel" IsChecked="{Binding Real, UpdateSourceTrigger=PropertyChanged}" Margin="10" />
            <CheckBox Content="Album" IsChecked="{Binding WithAlbum, UpdateSourceTrigger=PropertyChanged}"  Margin="10"/>
            <CheckBox Content="Avec Parent" IsChecked="{Binding WithParent, UpdateSourceTrigger=PropertyChanged}"  Margin="10"/>


        </StackPanel>

        <StackPanel  Margin="10" Grid.Row="2" Orientation="Horizontal" VerticalAlignment="Bottom" HorizontalAlignment="Right">
          
            <Button Name="btOk" Content="Ok" Click="btOk_Click" Width="60" Margin="0,0,10,0"/>
            <Button Name="btCancel" Content="Cancel" Click="btCancel_Click" />
        </StackPanel>

    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Memento.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Windows;
using pdb.gen.Tuning;
using System.Xml;
using pdb.util;

namespace pdb.player.Vue
{
    [Serializable]
    class Memento
    {
        [NonSerialized]
        const string FILE_CONF = "confAlbum.xml";
        [NonSerialized]
        const string PATH = TuningBase.DIR_CONF + "memento.dat";
        [NonSerialized]
        const string PATH_CONF = TuningBase.DIR_CONF + FILE_CONF;
        [NonSerialized]
        const string SOV_CONF = TuningBase.DIR_CONF + "sov\\";
        [NonSerialized]
        private static volatile Memento _instance;
        [NonSerialized]
        private FileRotator fileRotator;
        public WindowPos winPos = null;
        public CmpPos cmpPos = null;
        public string selectedPlaylist = "";
        public Dictionary<string, object> dict = new Dictionary<string, object>();
        [NonSerialized]
        public ConfAlbumSort confAlbum;


        private Memento()
        {
            fileRotator = new FileRotator();
        }
        public static Memento Instance
        {
            get
            {
                if (_instance == null)
                {

                    var formater = new BinaryFormatter();
                    try
                    {
                        if (File.Exists(PATH))
                        {
                            using (Stream st = new FileStream(PATH, FileMode.Open))
                            {
                                _instance = (Memento)(formater.Deserialize(st));
                            }
                        }
                        else
                            _instance = new Memento();
                        var doc = new XmlDocument();
                        doc.Load(PATH_CONF);
                        var conf = new ConfAlbumSort(doc.DocumentElement);

                        _instance.confAlbum = conf;
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        if (Application.Current is App)
                            throw;
                    }


                }

                if (_instance == null)
                    _instance = new Memento();

                _instance.fileRotator = new FileRotator();
                return _instance;

            }
        }
        public void save()
        {
            var formater = new BinaryFormatter();
            using (Stream st = new FileStream(PATH, FileMode.Create))
            {
                formater.Serialize(st, this);
            }
            if (this.confAlbum != null)
            {
                fileRotator.save(PATH_CONF, SOV_CONF, 100);
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(PATH_CONF, settings))
                {
                    this.confAlbum.save(writer);
                }
            }
        }
    }
    [Serializable]
    class WindowPos
    {
        public double Top;
        public double Left;
        public double Width;
        public double Height;
    }
    [Serializable]
    class CmpPos
    {
        public Length cdBib;
        public Length cdMain;
        public Length cdAlbum;
        public Length cdClassement;
    }

    [Serializable]
    public class Length
    {
        public double value;
        public GridUnitType unit;
        public Length(GridLength ihm)
        {
            value = ihm.Value;
            unit = ihm.GridUnitType;
        }
        public GridLength toGrid()
        {
            return new GridLength(value, unit);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants - sans les virtuels 
        /// </summary>
        private List<Piece> listPieceInAlbumReal = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool classementChange;
        private bool _firstConsolid = true;
        private bool _albumBuild = false;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private PlayList root = new PlayList("root", null);
        public PlayList Root { get { return root; } }
        private PlayList musique;
        private PlayList classement;
        private PlayList listes;
        private PlayList genres;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new PlayList("musique", root);
            classement = new PlayList("classement", root);
            listes = new PlayList("listes", root);
            genres = new PlayList("genres", listes);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }
        public void ClassementChange() { classementChange = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating(false);
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        //public void buildClassTree()
        //{
        //    buildClassTree(classement);
        //}


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private bool filterOnlyNext = true;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                }
            }
        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums()
        {
            // pour l'instant ne fonctionne pas 
            _albumBuild = false;
            albums.invalidateAll(true);
        }

        public bool AlbumBuild { get { return _albumBuild; } }

        private void buildVirtualFromList(PlayList pl, List<Piece> list)
        {
            string path = pl.getPath(listes, genres);
            foreach (IItem item in pl.Items)
            {
                var piece = htIds[item.ID];
                var v = piece.createVirtualAlbum(path, virtualMode.list, null);
                if (v != null)
                {
                    list.Add(v);
                }
            }

            foreach (PlayList sub in pl.PlayLists)
            {
                buildVirtualFromList(sub, list);
            }
        }

        public void ConsolidInit(IEnumerable<ITrackNativeDates> dbList)
        {
            if (_albumBuild)
                return;
            allClassed.Clear();
            allClassedInAlbumEnabled.Clear();
            m_listTrackClassed.Clear();

            listPiece.Clear();
            listPieceInAlbum.Clear();
            listPieceInAlbumReal.Clear(); 
            all.Clear();

            // albums = new Albums(this);
            // VirtualPiece.init();

            //htIds.Clear();

            //  htIds = new BgDict<int, Piece>();
            foreach (ITrackNativeDates track in dbList)
            {

                if (!track.isPodcast)
                {
                    Piece piece = null;
                    int pieceId = track.PieceId;
                    if (htIds.ContainsKey(pieceId))
                    {
                        piece = htIds[pieceId];
                        piece.initRank();
                    }
                    else
                    {
                        piece = new Piece(track);
                        htIds.Add(pieceId, piece);
                    }

                    all.Add(piece);

                }
            }
            // link
            foreach (Piece piece in all)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }
            }

            // liste FORT + albums


            albums.checkBuild();
            logger.log("build albums");
            foreach (Piece piece in all)
            {

                if (piece.Parent == null)
                {
                    // piece.removeVirtualChilds(); 
                    listPiece.Add(piece);
                    foreach (Piece p in piece)
                    {
                        if (p.Virtual)
                            continue;
                        if (albums.check(p))
                        { 
                            listPieceInAlbum.Add(p);
                            listPieceInAlbumReal.Add(p); 
                        }
                    }
                }
            }

            var confGen = CConf.ConfGen;
            var min = confGen.AlbumMin;

            if (_albumVirtual)
            {
                logger.log("build albums virtuels");

                var listCandidat = new List<Piece>();
                var dictTmp = new BgDictString<Album>();
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        piece.buildVirtualAlbums(listCandidat);
                    }
                }

                if (CConf.ConfGen.ListVirtual)
                {
                    buildVirtualFromList(listes, listCandidat);
                }

                foreach (Piece p in listCandidat)
                    albums.checkVirtual(p, dictTmp);




                min = confGen.PathVirtualMin;
                if (min > 1)
                {
                    // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                    foreach (var key in new List<string>(dictTmp.Keys))
                    {
                        var a = dictTmp[key];
                        if (a.VirtualMode == virtualMode.path || a.VirtualMode == virtualMode.extended)
                        {
                            if (a.Count < min)
                            {
                                a.ClearAndMenage();
                                dictTmp.Remove(key);
                            }
                        }
                    }
                }

                if (confGen.ArtistVirtual)
                {
                    min = confGen.ArtistVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualByArtist)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }


                if (confGen.WordVirtual)
                {
                    min = confGen.WordVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualMode == virtualMode.word)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }




                var listAlbums = new List<Album>(dictTmp.Values);

                listAlbums.Sort(new VirtualAlbumComparer());
                albums.checkVirtuals(listAlbums, listPieceInAlbum);

                foreach (Piece piece in all)
                {
                    piece.menageChilds();
                }

            }

            albums.buildDone();

            // Suppression des albums avec trop peu de morceaux
            min = confGen.AlbumMin;
            if (min > 1)
            {
                // Suppression des albums standards avec trop peu de morceaux
                var dict = albums.Dict;
                foreach (var key in new List<string>(dict.Keys))
                {
                    var a = dict[key];
                    if (!a.Virtual)
                    {
                        if (a.Count < min)
                        {
                            a.ClearAndMenage();
                            dict.Remove(key);
                        }
                    }
                }
            }
            albums.sortVirtual();
            _albumBuild = true;

        }


        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;

                allClassed.Clear();
                allClassedInAlbumEnabled.Clear();
                m_listTrackClassed.Clear();

                ConsolidInit(dbList);
                if (CConf.ConfGen.LimitAlbums > 0)
                    _albumBuild = false;
                now = DateTime.Now;

                StackAlbum.Instance.init(all);

                misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (piece.Classement.isClassed())
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                misc.log("allClassed; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;



                misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                Ranking(makeSort);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            misc.log("buildMusique"); 
            //if (CConf.ConfGen.LimitList > 0)
            //    return;
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece); // addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbumReal)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif
             misc.log("fin buildMusique"); 
        }

        //private void buildMusique(PlayList musique)
        //{
        //    var d = new HashSet<int>();
        //    foreach (Piece piece in all)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece); // addObj(piece);
        //    }


        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece);
        //    }
        //}

        public void buildMusiqueAgain()
        {
            musique.DeleteBase();
            buildMusique();
        }


        public void buildLists(PlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                // mine.add(sub);
                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }


            //foreach (PlComponent c in ext)
            //{
            //    if (c is CPlayList)
            //    {
            //        var subExt = c as CPlayList;
            //        var sub = new CPlayList(subExt.Name, mine);
            //        sub.ID = subExt.ID;
            //        // mine.add(sub);
            //        buildList(sub, subExt);
            //    }
            //    else
            //    {
            //        var t = c as IFile;
            //        var piece = htIds[t.PieceId];
            //        mine.add(new TrackList(piece));
            //    }
            //}
        }



        internal Album getAlbum(Piece track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();

            if (Piece.Compact)
            {
                if (goCompact || (classementChange && CConf.ConfGen.AlbumSort.compactAny))
                {
                    lock (Albums.LockSort)
                    {
                        goCompact = false;
                        classementChange = false;
                        //var l = new List<Piece>(this.listPiece);
                        //l.Sort(new CPieceComparerByQualityAndLength2());
                        new Condenseur(listPieceInAlbum).gener2();
                    }
                }
            }


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort(_firstConsolid);
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal(false));
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating(false));
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now;



            var l_pieceComparer = new PieceDeepClassementComparer();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


            //on ordonne les morceaux top-down => sont privilégiés les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

            //compactage de la liste en tenant compte des mieux notés
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.Classement .isClassed())
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            // Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }

            logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        }

        //public void compact()
        //{
        //    if (Piece.Compact)
        //    {
        //        if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
        //        {
        //            goCompact = false;
        //            var l = new List<Piece>(this.listPiece);
        //            l.Sort(new CPieceComparerByQualityAndLength2());
        //            new Condenseur(m_listQL).gener2();
        //        }
        //    }
        //}
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            m_listQL = new List<Piece>(m_listTrackClassed);
            foreach (Piece p in m_listQL)
                p.invalidateCache(false);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }


            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;
                var list = new List<Piece>(m_listQL);
                list.Sort(new ClassementValueDecimal0Comparer());

                if (_albumSortMode.createCourant)
                {
                    var unselected = list.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = list.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(list).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(list) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(list) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            //  _buildStat(rappel); 
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(this, l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(this, l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(this, l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\CPieceComparer.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.IO;
namespace pdb.gen
{
    public class PieceDeepClassementComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.DeepClassement.CompareTo(y.DeepClassement);
        }
    }

    public class CPieceComparerByGoodness : IComparer<Piece>
    {
        /// <summary>
        /// compareur de listes
        /// </summary>
        private static CPlayListComparer c_comparer = new CPlayListComparer();
        public static bool modeBatch = true;
        public int Compare(Piece x, Piece y)
        {
            return -x.Classement.CompareTo(y.Classement); 
            return -x.RapportClassement(false).CompareTo(y.RapportClassement(false));
            //var cmp =  x.RapportClassement.CompareTo(y.RapportClassement);
            //if (cmp != 0)
            //    return -cmp;
            //cmp = x.Duration.CompareTo(y.Duration);
            //if (cmp != 0)
            //    return -cmp;
            //return x.PieceId.CompareTo(y.PieceId); 
            if (!modeBatch)
            {
                if (x.ClassPlayList == null)
                {
                    if (y.ClassPlayList == null)
                    {
                        return -(x.RatingCmp.CompareTo(y.RatingCmp));
                    }
                    else
                    {
                        return 1;
                    }
                }
                if (y.ClassPlayList == null)
                {
                    return -1;
                }
            }

            // gérer le cas ou les deux listes sont imbriquées
            // 3.4 > 33.5 et 3.2 < 33.0

            //if (x.isClassListNumeric && y.isClassListNumeric)
            //{
            String strX = x.ClassNameAndRating(false);
            String strY = y.ClassNameAndRating(false);
            var cmpnameRat = compareClassNameAndRating(strX, strY);
            if (cmpnameRat != 0) return cmpnameRat;
            //}
            if (!modeBatch)
            {

                CPlayList plX = x.ClassPlayList;
                CPlayList plY = y.ClassPlayList;

                //if( plX.isSubList(plY) || plY.isSubList(plX))
                //{
                //    string xName = plX.Name;
                //    string yName = plY.Name; 

                //}


                int l_plCmp = c_comparer.Compare(plX, plY);
                if (l_plCmp == 0)
                {
                    return -(x.RatingCmp.CompareTo(y.RatingCmp));
                }
                else
                {
                    return l_plCmp;
                }
            }
            else
                return -(x.RatingCmp.CompareTo(y.RatingCmp));


        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

    }

    public class CPieceComparerByGoodness2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Quality.CompareTo(y.Rank.Quality);
        }
    }

    public class CPieceComparerByQualityAndLength : IComparer<Piece>
    {

        private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
        public virtual int Compare(Piece x, Piece y)
        {
            int l_cmp = c_comparer.Compare(x, y);
            if (l_cmp == 0)
                return -x.Rank.Lenght.CompareTo(y.Rank.Lenght);
            return l_cmp;
        }
    }

    public class CPieceComparerByQualityAndLength2 : IComparer<Piece>
    {
        int IComparer<Piece>.Compare(Piece x, Piece y)
        {
            return x.Rank.Twice.CompareTo(y.Rank.Twice);
        }
    }

    public class CPieceComparerByQualityAndLengthInv : IComparer<Piece>
    {

        private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
        public virtual int Compare(Piece x, Piece y)
        {
            int l_cmp = c_comparer.Compare(x, y);
            if (l_cmp == 0)
                return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
            return l_cmp;
        }
    }

    public class CPieceComparerByQualityAndLengthInv2 : IComparer<Piece>
    {
        int IComparer<Piece>.Compare(Piece x, Piece y)
        {
            return x.Rank.TwiceInv.CompareTo(y.Rank.TwiceInv);
        }
    }

    /// <summary>
    /// tri pour la copie : En premier : les plus bas et les activés
    /// </summary>
    public class CPieceComparerByQualityLengthAndEnable : CPieceComparerByQualityAndLength
    {
        public override int Compare(Piece x, Piece y)
        {
            if (x.Enabled == y.Enabled)
            {
                return -base.Compare(x, y);
            }
            if (x.Enabled)
                return -1;
            return 1;
        }
    }


    public class CPieceComparerByLenght : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Duration.CompareTo(y.Duration);
        }
    }

    public class CPieceComparerByLenght2 : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
        }
    }

    public class CPieceInListComparer : IComparer<Piece>
    {

        //Public Function Compare(ByVal x As CPiece, ByVal y As CPiece) As Integer Implements System.Collections.Generic.IComparer(Of CPiece).Compare
        //    Dim val1 As Double = x.Rapport * Math.Pow(x.Duration, CDb.SortTimeProp)
        //    Dim val2 As Double = y.Rapport * Math.Pow(y.Duration, CDb.SortTimeProp)

        //    Dim l_cmp As Integer = val1.CompareTo(val2)
        //    If l_cmp <> 0 Then
        //        Return l_cmp
        //    Else
        //        Return x.Duration.CompareTo(y.Duration)
        //    End If
        //End Function
        /// <summary>
        /// Comparaison de deux fichiers en fonction du cumul des deux paramètre qualité et longueur
        /// 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        /// <remarks>En gros on ajoute le log des classements qualité et longueur, pondérés par le coefficient sortimeProp
        /// 0 --> que la longueur prise en compte
        /// 1 --> que la qualité</remarks>
        public int Compare(Piece x, Piece y)
        {
            var val1 = CTuning.Calc(x.Rank, CConf.Sort);
            var val2 = CTuning.Calc(y.Rank, CConf.Sort);

            int l_cmp = val1.CompareTo(val2);
            if (l_cmp != 0)
            {
                return l_cmp;
            }
            else
            {
                return x.Duration.CompareTo(y.Duration);
            }

        }


    }

    public class PieceMaxClassementComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.MaxClassement.CompareTo(y.MaxClassement); 
        }
    }

    public class PieceRestComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            //if ((x.Album == "A Lovaggkiraly" && x.Name == "Piste 04" && y.Album == "Only Built 4 Cuban Linx" && y.Name == "Shark Niggas (Biters)")
            //    || (y.Album == "A Lovaggkiraly" && y.Name == "Piste 04" && x.Album == "Only Built 4 Cuban Linx" && x.Name == "Shark Niggas (Biters)"))
            //{
            //    int toto = 0; 
            //}
            int cmp = x.Rank.TimeRest.CompareTo(y.Rank.TimeRest);
            if (cmp != 0)
                return cmp;

            return x.Rank.TwiceInv.CompareTo(y.Rank.TwiceInv);
            //cmp = x.QRank.CompareTo(y.QRank);
            //if (cmp != 0)
            //    return cmp; 

            //return - x.LRank.CompareTo(y.LRank);

        }
    }

    public class PieceRestComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            throw new NotImplementedException();
        }
    }



    public class PieceDeltaComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            int cmp = x.Rank.Delta.CompareTo(y.Rank.Delta);
            if (cmp != 0)
                return cmp;
            return x.QLRank.CompareTo(y.QLRank);

        }
    }

    public class PieceSortComparer : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;
            return -x.QLRank.CompareTo(y.QLRank);

        }
    }


    //public class PieceClassementDisplayComparer : IComparer<Piece>
    //{
    //    private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
    //    public int Compare(Piece x, Piece y)
    //    {
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;
    //        int cmp = 0;
    //        if (xv == 0m || yv == 0m)
    //            cmp = x.RapportClassement.CompareTo(y.RapportClassement);
    //        if (cmp != 0) return -cmp;
    //        cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //        if (cmp != 0) return -cmp;
    //        return tn.Compare(x, y);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    public class PieceVirtualClassementComparer : IComparer<Piece>
    {
        private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
            int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);


            if (cmp != 0) return -cmp;
            //cmp = x.RapportClassement.CompareTo(y.RapportClassement);
            //if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
            //  return -x.RapportClassement.CompareTo(y.RapportClassement);
        }
    }

    public class PieceClassementComparer : IComparer<PieceExtended>
    {
        private bool oldAsZero;
        private PieceExtended.mode mode = PieceExtended.mode.main;
        public PieceClassementComparer(bool oldAsZero)
            : this(oldAsZero, PieceExtended.mode.main)
        {

        }

        public PieceClassementComparer(bool oldAsZero, PieceExtended.mode mode)
        {
            this.oldAsZero = oldAsZero;
            this.mode = mode;
        }
        private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        public int Compare(PieceExtended x, PieceExtended y)
        {

            if (oldAsZero)
            {
                bool xRecent = x.LastClassementRecent;
                bool yRecent = y.LastClassementRecent;
                if (xRecent != yRecent)
                {
                    if (xRecent)
                        return -1;
                    return 1;
                }
            }
            int cmp = 0;


            if (mode == PieceExtended.mode.main)
                cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
            else if (mode == PieceExtended.mode.min)
                cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
            else
                cmp = x.Cumul.CompareTo(y.Cumul);

            if (cmp != 0) return -cmp;
            //cmp = x.RapportClassement.CompareTo(y.RapportClassement);
            //if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
            //  return -x.RapportClassement.CompareTo(y.RapportClassement);
        }
    }

    public class PieceStackCmp : IComparer<Piece>
    {
        private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
            int cmp = x.RankAlbumSt.CompareTo(y.RankAlbumSt);
            if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
        }

    }
    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés
    ///// </summary>
    //public class PieceClassementComparerInv : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        //if (x.Enabled != y.Enabled)
    //        //{
    //        //    return x.Enabled ? -1 : 1;
    //        //}

    //        if (x.IsNext != y.IsNext)
    //        {
    //            if (x.IsNext)
    //                return -1;
    //            return 1; 
    //        }
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;

    //        int cmp = 0;
    //        if (xv > 0 && yv > 0)
    //        {
    //            cmp = xv.CompareTo(yv);
    //            if (cmp != 0) return cmp;
    //            cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //            if (cmp != 0) return cmp;
    //        }

    //        cmp = x.TrackNumber.CompareTo(y.TrackNumber);
    //        if (cmp != 0)
    //            return cmp;
    //        return x.Location.CompareTo(y.Location);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés et si on veut optimiser autour du Next
    ///// </summary>
    //public class PieceClassementComparerExport : IComparer<Piece>
    //{
    //    public PieceClassementComparerExport(HashList<Piece> source)
    //    {
    //        this.source = source; 
    //    }
    //    private readonly HashList<Piece> source;
    //    public int Compare(Piece x, Piece y)
    //    {
    //        return source.IndexOf(x).CompareTo(source.IndexOf(y)); 
    //    }
    //}

    public class PieceDurationValueComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.Duration.CompareTo(y.Duration);
        }
    }

    public class PieceSortComparerList : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Sort.CompareTo(y.Rank.Sort);
            //int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            //if (cmp != 0)
            //    return cmp;
            //return x.QLRank.CompareTo(y.QLRank);

        }
    }

    public class PieceTrackNumberComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            var xpath = x.getLocation();
            var ypath = y.getLocation();
            if (x.TrackNumber <= 0)
            {
                try
                {
                    var xf = Path.GetFileNameWithoutExtension(xpath);
                    var yf = Path.GetFileNameWithoutExtension(xpath);
                    cmp = xf.CompareTo(yf);
                    if (cmp != 0)
                        return cmp;
                }
                catch
                {
                }
            }
            return xpath.CompareTo(ypath);
            //  return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    internal class PieceTrackNumberComparerE : IComparer<PieceExtended>
    {
        public int Compare(PieceExtended x, PieceExtended y)
        {
            var xx = x.Piece;
            var yy = y.Piece;
            var cmp = xx.TrackNumber.CompareTo(yy.TrackNumber);
            if (cmp != 0)
                return cmp;

            var xpath = xx.getLocation();
            var ypath = yy.getLocation();
            if (xx.TrackNumber <= 0)
            {
                try
                {
                    var xf = Path.GetFileNameWithoutExtension(xpath);
                    var yf = Path.GetFileNameWithoutExtension(xpath);
                    cmp = xf.CompareTo(yf);
                    if (cmp != 0)
                        return cmp;
                }
                catch
                {
                }
            }
            return xpath.CompareTo(ypath);


            //  return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    class LastModifClassementComparer : IComparer<Piece>
    {
        PieceTrackNumberComparer trackCmp = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {


            var dtx = x.UpdateClassement;
            var dty = y.UpdateClassement;
            int cmp = 0;
            if (dtx == null)
            {
                if (dty == null)
                {
                }
                else
                    cmp = -1;
            }
            else if (dty == null)
                cmp = 1;
            else
                cmp = dtx.Value.CompareTo(dty.Value);


            if (cmp != 0)
                return cmp;
            return trackCmp.Compare(x, y);
        }
    }

    class ClassementValueDecimal0Comparer : IComparer<Piece>
    {
        static PieceTrackNumberComparer trackCmp = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
            var cmp = x.ClassementValueDecimal(false).CompareTo(y.ClassementValueDecimal(false));
            if (cmp != 0)
                return cmp;
            return trackCmp.Compare(x, y);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>, IItem
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual virtualMode VirtualMode { get { return virtualMode.none; } }
        // public virtual bool Dirty { get { return false; } set { throw new ApplicationException();  } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } get { return gen; } }
        /// <summary>
        /// Permet d'utiliser le classement Compact. 
        /// </summary>
        private bool useCompact = Compact;
        // private bool useCompact0 = Compact;
        public static bool Compact;
        public static string compact(string strClassement)
        {
            if (!Compact)
                return null;

            if (string.IsNullOrEmpty(strClassement))
                return null;
            if (ClassementHash.ZERO_KEY == strClassement)
                return null;
            var cl = classementHash.getCache(strClassement);
            var res = tradCompact[cl.ClassementValueDecimal];
            if (string.IsNullOrEmpty(res))
            {
            }
            return res;
        }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        public bool UseCompact { get { return useCompact; } set { useCompact = value; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void resetMedianneCompact() { _infoMedianne = infoMedianne.none; useCompact = Compact; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }
        public int RankAlbumZero { get { if (album == null) return 0; return gen.Albums.RankZero - album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        // public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                    return false;
                    case selectedCoeff.noCoeff:
                    return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                    return album.Moved;
                    default:
                    return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                    return false;
                    case selectedCoeff.noCoeff:
                    return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                    return album.Empeached;
                    default:
                    return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                    return false;
                    case selectedCoeff.noCoeff:
                    return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                    return true;
                    default:
                    return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

       // public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache(true);

        }

        public string ClassementCompact
        {
            get
            {

                return getClassementCache(true).strClassement;
                //if (parent != null)
                //    return parent.ClassementCompact;
                //if (Compact)
                //{
                //    if (string.IsNullOrEmpty(_classementCompact))
                //        return ClassementCache.strClassement;
                //    return _classementCompact;
                //}
                //else
                //    return ClassementCache.strClassement;

            }
        }
        public static ClassementHash classementHash = new ClassementHash();
        //private ClassementCache _classementCache;
        //private ClassementCache ClassementCache
        //{
        //    get
        //    {


        //        if (_classementCache == null)
        //        {
        //            if (parent != null)
        //                _classementCache = parent.ClassementCache;
        //            if (_classementCache == null)
        //            {
        //                if (Compact)
        //                {
        //                    if (string.IsNullOrEmpty(_classementCompact))
        //                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
        //                    else
        //                        _classementCache = classementHash.getCache(_classementCompact);
        //                }
        //                else
        //                    _classementCache = classementHash.getCache(track.ClassName, track.Rating);

        //            }
        //        }
        //        return _classementCache;
        //    }
        //}

        // private bool keep;
        private static Dictionary<int, decimal> hsKeep = new Dictionary<int, decimal>();
        public bool Keep
        {
            get { return hsKeep.ContainsKey(PieceId); } //  .Contains(PieceId); }
            //set
            //{
            //    if (value)
            //        hsKeep.Add(PieceId);
            //    else
            //        hsKeep.Remove(PieceId);
            //}
        }

        public decimal KeepCoeff
        {
            get
            {
                if (!Keep)
                    return 0;
                return hsKeep[PieceId];
            }
        }

        public void setKeep(decimal coeff)
        {
            if (hsKeep.ContainsKey(PieceId))
            {
                if (coeff == 0m)
                    hsKeep.Remove(PieceId);
                else
                    hsKeep[PieceId] = coeff;
            }
            else
            {
                if (coeff > 0m)
                    hsKeep.Add(PieceId, coeff);
            }
        }

        private static HashSet<int> ksCompact = new HashSet<int>();
        private static Dict<decimal, string> tradCompact = new Dict<decimal, string>();
        // private static Dict<int, string> dictCompact = new Dict<int, string>();

        public static void resetCompact() { tradCompact.Clear(); }
        //private bool UseCompact0
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return useCompact0;
        //        return parent.useCompact0;
        //    }
        //}
        private ClassementCache getClassementCache(bool _compact)
        {
            //if (parent != null)
            //    return parent.getClassementCache(_compact);
            //  ClassementCache compactc = null;

            var str = StrClassementCoeff;
            if (_compact && useCompact && ClassementACompacter)
            {
                var strCompact = compact(str);
                if (str != ClassementHash.ZERO_KEY && string.IsNullOrEmpty(strCompact))
                {
                }
                else
                    return classementHash.getCache(strCompact);

            }
            return classementHash.getCache(str);
            // return classementHash.getCache(strClassement);


        }



        // private string _classementCompact;



        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache(true);

            // _classementCompact = classement;
            var _compact = classementHash.getCache(classement);
            var org = classementHash.getCache(StrClassementCoeff);

            if (org.ClassementValueDecimal <= _compact.ClassementValueDecimal)
            {
                //  useCompact0 = false;
                //tradCompact.Remove(org.strClassement); 
                // dictCompact.Remove(MasterId);
                // _classementCache = org;
                return false;
            }
            else
            {
                // useCompact0 = true;
                tradCompact[org.ClassementValueDecimal] = classement;
                // dictCompact[MasterId] = classement;
                // _classementCache = _compact;
                return true;
            }
        }

        public decimal ClassementValueDecimal(bool compact)
        {
            return getClassementCache(compact).ClassementValueDecimal;
        }



        public virtual void invalidateCache(bool razCompact)
        {
            //if (razCompact)
            //{
            //  //  useCompact0 = false;
            //  //  useCompact = false;

            //    //if (parent != null)
            //    //    parent.invalidateCache(razCompact);
            //}
            //  tradCompact.Remove(StrClassement); 
            //dictCompact.Remove(MasterId);

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //_classementProvisoireRecent = null;

            //if (parent != null)
            //    parent.invalidateCache(razCompact);
            //else
            //{
            //    // _classementCache = null;
            //    if (Compact)
            //    {
            //        if (razCompact)
            //            _classementCompact = null;
            //    }
            //    foreach (Piece p in childs)
            //    {
            //        if (Compact)
            //        {
            //            if (razCompact)
            //                p._classementCompact = null;
            //        }
            //        // p._classementCache = null;
            //    }
            //  }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return this.Classement.isClassed();
            }
        }

        // private string _classNameAndRating;
        //public String ClassNameAndRating
        //{
        //    get
        //    {
        //        return ClassementCache.ClassNameAndRating;
        //    }
        //}

        public String ClassNameAndRating(bool compact)
        {
            return getClassementCache(compact).ClassNameAndRating;

        }

        // private decimal _classementValueDecimal = -1;
        //public decimal ClassementValueDecimal
        //{
        //    get
        //    {
        //        return ClassementCache.ClassementValueDecimal;
        //    }
        //}
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        /// <summary>
        /// Convertit chaine de format 12345 en 0.17
        /// </summary>
        /// <param name="classNameAndRating"></param>
        /// <returns></returns>
        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }
        public decimal RapportClassement(bool compact)
        {
            return getClassementCache(compact).RapportClassement;
        }

        public string HrC { get { return getClassementEquiv(RapportClassement(true)); } }




        // private decimal _rapportClassement = -1;
        //public decimal RapportClassement
        //{
        //    get
        //    {
        //        return ClassementCache.RapportClassement;
        //        //if (parent != null)
        //        //    return parent.RapportClassement;
        //        //if (_rapportClassement != -1)
        //        //    return _rapportClassement;

        //        //decimal resultat = 0;
        //        //try
        //        //{
        //        //    return getRapport(ClassNameAndRating);
        //        //}
        //        //catch
        //        //{
        //        //}
        //        //_rapportClassement = resultat;
        //        //// _classementVirtuel = resultat; 
        //        //return _rapportClassement;
        //    }
        // }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        private const int END_EQUIV = 13;
        private const int NB_DEC_EQUIV = 8;
        public static string getStrClassement(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > NB_DEC_EQUIV)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return str;
        }
        public static string getClassementEquiv(decimal valRapport)
        {
            var str = getStrClassement(valRapport);
            return getReadableCl(str);
        }




        //public decimal RapportClassementDecimal
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return parent.RapportClassementDecimal;
        //        decimal resultat = 0;
        //        try
        //        {
        //            string str = ClassNameAndRating;
        //            char[] tab = str.ToCharArray();

        //            decimal K = 1m;
        //            int count = tab.GetLength(0);


        //            for (int i = 0; i < count; i++)
        //            {
        //                K = K * 6;
        //                int c = Convert.ToInt32(tab[i].ToString());
        //                resultat += (decimal)c / K;
        //            }
        //        }
        //        catch
        //        {
        //        }
        //        return resultat;
        //    }
        //}

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating(false);
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        misc.log("change artist from '{0}' to'{1}'", track.Artist, value);


                        gen.invalidateAlbums();
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        gen.invalidateAlbums();
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        gen.invalidateAlbums();
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        //public string ArtWork
        //{
        //    get { return track.ArtWork; }
        //    set { track.ArtWork = value; }
        //}

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {
                var list = DatesClassement;
                if (list.Count == 0)
                    return null;
                var dc = list[0];

                if (dc == DateTime.MinValue)
                    return null;
                if (dc == DateTime.MaxValue)
                    return null;

                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }

        public bool ClassementRecentCompact
        {
            get
            {
                return !string.IsNullOrEmpty(compact(Classement.ToString())) && LastClassementRecent;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? MasterAlbumUpdateClassement
        {
            get
            {
                var album = Master.album;
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }
        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public int NbRecentsInAlbum { get { if (album == null) return 0; return album.Recents; } }
        public int NbDoneInAlbum { get { if (album == null) return 0; return album.NbDone; } }
        public string PlusPetitEnabled
        {
            get
            {
                if (album == null || album.PlusPetitEnabled == null)
                    return "";
                return album.PlusPetitEnabled.Classement.ToString();
            }
        }

        public int MasterTrackNumber
        {
            get
            {
                if (parent == null)
                    return TrackNumber;
                return parent.TrackNumber;
            }
        }

        public int MasterTrackNumberForTri
        {
            get
            {
                var res = MasterTrackNumber;
                if (res <= 0)
                    return int.MaxValue;
                return res;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            object o = PieceAlbum;
            if (o == null)
                o = VirtualMode;
            return string.Format("{0} {1}", o, track);
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel2;
            }
        }




        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                if (modeTime == timeMode.equivNorm)
                    return ts.FormatCustomTs(3, 2, 4);
                return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                var delta = tsf - ts0;
                delta = delta * 100;
                //if (modeTime == timeMode.deltaNorm)
                //    return delta.FormatCustom(3, 2, 4);
                return "(" + delta.FormatCustomTs(2) + ")";
                default:
                throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = gen.Albums.RankZero - rank; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
                    return rank;
                }
                return 0;
            }
        }

        public int DeltaRankAbs { get { return System.Math.Abs(RankAlbumReverse - RankAlbumZero); } }
        public int DeltaRank { get { return RankAlbumZero - RankAlbumReverse; } }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                        CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                        CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                        CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                        CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                        if (album != null)
                            sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                        sb.Append(RankAlbumReverse);
                        break;
                        case displayCategory.rankEquiv:
                        if (album != null)
                            sb.Append(album.Equiv);
                        break;
                        case displayCategory.rankEquivLight:
                        if (album != null)
                            sb.Append(album.EquivLight);
                        break;
                        case displayCategory.rankEquivLight0:
                        if (album != null)
                            sb.Append(album.EquivLight0);
                        break;
                        case displayCategory.albumMoy:
                        if (album != null)
                        {
                            sb.Append(album.Moyenne);
                        }
                        break;
                        case displayCategory.lenght:
                        sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                        sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                        sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                        sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                        sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                        sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                        sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                        sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                        sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                        sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                        break;
                        case displayCategory.dclassMin:
                        sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                        sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                        break;
                        case displayCategory.dmixMin:
                        sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                        break;
                        case displayCategory.pipe:
                        sb.Append("|");
                        break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                        break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
            //gen.Albums.invalidate(Master); 
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }

        }

        public void setParent(Piece value)
        {

            if (value == parent)
                return;
            var old = parent;
            if (old != null)
            {
                old.albumMustRefresh();
                old.removeChild(this);
            }
            parent = value;
            if (parent == null)
            {
                if (old != null)
                {
                    this.PieceParentId = -1;
                }
            }
            else
            {
                parent = parent.Master;
                parent.addChild(this);
                this.PieceParentId = parent.MasterId;

            }
            if (album != null)
                this.album.mustRefresh();

        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private HashSet<Piece> childs = new HashSet<Piece>();
        public HashSet<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            if (childs.Contains(child))
                return;
            //throw new ApplicationException("enfant déjà enregistré " + this + " " + child); 


            childs.Add(child);

        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public void removeVirtualChilds()
        {
            List<Piece> list = null;
            foreach (var c in childs)
            {
                if (c.Virtual)
                {
                    // c.parent = null;
                    if (list == null)
                        list = new List<Piece>();
                    list.Add(c);
                }
            }
            if (list != null)
            {
                foreach (var c in list)
                {
                    childs.Remove(c);
                }
            }
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        //public List<string> getIntermediaryPath()
        //{
        //    var list = new List<string>();
        //    foreach (var path in track.RelativesPath)
        //    {

        //        var tab = path.Split('\\');
        //        var sb = new StringBuilder();

        //        sb.Append(@"\");
        //        var count = tab.GetLength(0);
        //        for (int i = 0; i < count; i++)
        //        {
        //            var _s = tab[i];
        //            if (string.IsNullOrEmpty(_s))
        //                continue;

        //            var s = sb.ToString();
        //            if (!string.IsNullOrEmpty(s))
        //            {
        //                if (s.Length >= 2)
        //                {
        //                    list.Add(s);
        //                }
        //            }



        //            if (i > 0)
        //                sb.Append(@"\");
        //            sb.Append(_s);
        //        }
        //    }


        //    return list;


        //}


        public void buildVirtualAlbums(List<Piece> list)
        {
            if (this.PieceId == 16222)
            {
            }
            HashSet<string> hs = new HashSet<string>();

            // Dictionary<string, VirtualAlbumPiece> dict = new Dictionary<string, VirtualAlbumPiece>();
            var reels = new List<Piece>();
            //if (this.Name =="Five Years")
            //{

            //}
            foreach (Piece p in this)
            {
                if (p.Virtual)
                {
                    //var pp = p as VirtualAlbumPiece;
                    //dict.Add(p.PieceAlbum.Key, pp);
                }
                else
                    reels.Add(p);

            }

            childs.Clear();
            foreach (Piece p in reels)
            {
                if (p == this)
                    continue;
                childs.Add(p);
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (!string.IsNullOrEmpty(p.Artist))
                    {
                        var virt = createVirtualAlbum(p.Artist, virtualMode.artist, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);

                        var tab = p.Artist.Split(",;:".ToCharArray());
                        {
                            foreach (string part in tab)
                            {
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                if (part.Equals(p.Artist))
                                    continue;
                                var _part = part.Trim();
                                var virtp = createVirtualAlbum(_part, virtualMode.artist, hs);
                                if (virtp == null)
                                    continue;
                                list.Add(virtp);
                            }
                        }
                    }
                }

            }
            if (CConf.ConfGen.PathVirtual)
            {
                foreach (var path in track.RelativesPath)
                {

                    var tab = path.Split('\\');
                    var sb = new StringBuilder();

                    sb.Append(@"\");
                    var count = tab.GetLength(0);
                    for (int i = 0; i < count; i++)
                    {
                        var _s = tab[i];
                        if (string.IsNullOrEmpty(_s))
                            continue;

                        var virt = createVirtualAlbum(sb.ToString(), virtualMode.path, hs);

                        if (virt != null)
                            list.Add(virt);



                        if (i > 0)
                        {
                            sb.Append(@"\");
                            if (i < count - 1)
                            {
                                var extended = createVirtualAlbum(_s, virtualMode.extended, hs);
                                if (extended != null)
                                    list.Add(extended);
                            }
                        }
                        sb.Append(_s);
                    }
                }
            }


            if (CConf.ConfGen.YearVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (p.Year > 0)
                    {
                        var strYear = p.Year.ToString();
                        if (strYear.Length == 4)
                        {
                            var decennie = strYear.Remove(3);
                            var virtDecennie = createVirtualAlbum(decennie, virtualMode.year, hs);
                            if (virtDecennie != null)
                                list.Add(virtDecennie);
                        }
                        var virt = createVirtualAlbum(strYear, virtualMode.year, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);
                    }
                }

            }

            if (CConf.ConfGen.AddedVirtual)
            {
                bool simu = CConf.ConfGen.AddedVirtualSimu;
                foreach (Piece p in reels)
                {
                    DateTime added = p.Added;
                    if (simu && added == DateTime.MinValue && album != null)
                        added = album.AlbumAdded;
                    if (added > DateTime.MinValue)
                    {
                        var strDate = added.ToString("dd/MM/yyyy");
                        var virt = createVirtualAlbum(strDate, virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.ToString("MM/yyyy"), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.Year.ToString(), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                    }
                }
            }
            if (CConf.ConfGen.WordVirtual)
            {
                foreach (Piece p in reels)
                {
                    buildAlbumWord(p.Name, list, hs);
                    buildAlbumWord(p.Album, list, hs);
                    buildAlbumWord(p.Artist, list, hs);
                    buildAlbumWord(p.Year.ToString(), list, hs);
                    buildAlbumWord(p.TrackNumber.ToString(), list, hs);
                }

                foreach (var path in track.RelativesPath)
                {
                    buildAlbumWord(path, list, hs);
                }
            }

            //// supprimer les liaisons remontantes ? 
            //foreach (Piece p in childs)
            //{
            //    if (p.Virtual)
            //    {
            //        if (!childs.Contains(p))
            //        {
            //            p.parent = null; 
            //        }
            //    }
            //}


        }

        private void buildAlbumWord(string phr, List<Piece> list, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(phr))
                return;
            char[] sep = @"\/ ,;:.()_[]-{}".ToCharArray();
            var tab = phr.Split(sep);
            foreach (string str in tab)
            {
                if (!string.IsNullOrEmpty(str))
                {
                    var virt = createVirtualAlbum(str, virtualMode.word, hs);
                    if (virt != null)
                        list.Add(virt);
                }
            }
        }

        public Piece createVirtualAlbum(string path, virtualMode mode, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2 && (mode == virtualMode.path || mode == virtualMode.extended))
            {
                if (!CConf.ConfGen.VirtualRoot)
                    return null;
            }
            if (hs != null)
            {
                var key = pdb.gen.albums.Album.getKey(path, mode);
                if (!hs.Add(key))
                    return null;
            }
            VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track, Master, path, mode);
            //  virt.setParent(Master);
            return virt;
        }

        public void menageChilds()
        {
            if (parent != null)
                return;
            if (childs.Count == 0)
                return;
            var toDelete = new List<Piece>();

            HashSet<string> hs = new HashSet<string>();

            foreach (Piece p in childs)
            {
                if (p.Virtual)
                {
                    if (!hs.Add(p.PieceAlbum.Key))
                    {
                        toDelete.Add(p);
                    }
                }
            }
            foreach (Piece p in childs)
            {
                if (p.Parent != this)
                    toDelete.Add(p);
            }

            foreach (Piece p in toDelete)
            {
                //removeChild(p);
                p.setParent(null);
            }

        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        //  const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private static DateTime seuilCompact;
        public static DateTime SeuilCompact
        {
            get { return seuilCompact; }
            set
            {
                seuilCompact = value;
                if (seuilCompact > DateTime.Now)
                    seuilCompact = DateTime.MaxValue;
            }
        }
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                if (!Enabled)
                    return false;
                if (seuilCompact == DateTime.MaxValue)
                    return true;
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > seuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        //public bool ClassementProvisoire
        //{
        //    get
        //    {
        //        if (RapportClassement(false) == 0)
        //            return false;
        //        var str = ClassName;
        //        int count = str.Length;
        //        if (count < 4)
        //            return true;
        //        if (count >= 8)
        //            return false;

        //        var tab = str.ToCharArray();
        //        int nb = 0;
        //        for (int i = 0; i < count; i++)
        //        {
        //            if (nb > 0)
        //                nb++;
        //            else
        //            {
        //                if (tab[i] != '0')
        //                {
        //                    nb++;
        //                }
        //            }
        //        }
        //        if (nb >= NB_CHAR_COMPLETE)
        //            return false;

        //        return true;

        //    }
        //}

        public bool Played { get { return track.Played; } }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public void setClassement(string classement)
        {
            track.setClassement(classement);
        }

        public Classement Classement
        {
            get
            {
                return Keep ? DeepClassement : track.Classement;
            }
        }

        public string StrClassementCoeff
        {
            get
            {
                if (!Keep)
                    return Classement.ToString();
                var coeff = hsKeep[PieceId];
                if (coeff == 1m)
                    return DeepClassement.ToString();
                var cl = classementHash.getCache(DeepClassement.ToString());

                var rapport = cl.RapportClassement;
                rapport *= coeff;
                var clReduit = getStrClassement(rapport);
                return clReduit;
                // return Keep ? DeepClassement : strClassement;
            }
        }

       

        public Classement DeepClassement
        {
            get { return track.DeepClassement; }
        }
      

        public Classement MaxClassement
        {
            get { return track.MaxClassement; }
        }


    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\TrackList.cs">
    <content><![CDATA[
using System;
using System.Collections.Generic;
using pdb.obj;
using System.Diagnostics;

namespace pdb.gen
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            if (source is Piece)
                return new TrackList(source as Piece);
            else
                throw new ApplicationException(source + " n'est pas du bon type");
        }
    }
    public class TrackList : PlComponent, ITrackMetaData, IFile, ITrackNativeDates
    {

        private Piece piece;
        public TrackList(Piece piece)
        {
            if (piece == null)
                Debugger.Launch();
            this.piece = piece;
        }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public Piece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }
        public bool Virtual { get { return piece.Virtual; } }
        public bool Played { get { return piece.Played; } }
       

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        //public string Comment
        //{
        //    get
        //    {
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        piece.Comment = value;
        //    }
        //}

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        //public string ArtWork
        //{
        //    get
        //    {
        //        return piece.ArtWork;
        //    }
        //    set
        //    {
        //        piece.ArtWork = value;
        //    }
        //}

        

        //public string Grouping
        //{
        //    get { return piece.Grouping; }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    piece.setGrouping(value, prior);
        //}



       // public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    piece.AddPlayList(a_playList);
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    piece.removePlayList(list);
        //}

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
            set { piece.PieceParentId = value; }
        }




        public TrackIdentity Key
        {
            get { return piece.Key; }
        }

        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
        }

        public List<DateTime> Dates
        {
            get { return piece.Dates; }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return piece.ClassEvol; }
        }

        public List<string> RelativesPath
        {
            get { return piece.RelativesPath; }
        }


        public exportState ExportStatus
        {
            get
            {
                return piece.ExportStatus;
            }
            set
            {
                piece.ExportStatus = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return piece.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation() ;
        }


        public DateTime Added
        {
            get { return piece.Added;  }
        }


        public void setClassement(string classement)
        {
            piece.setClassement(classement); 
        }


      


        public Classement DeepClassement
        {
            get { return piece.DeepClassement; }
        }


        public Classement MaxClassement
        {
            get { return piece.MaxClassement; }
        }

        public Classement Classement
        {
            get
            {
                return piece.Classement; 
            }
        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\Condenseur.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Text.RegularExpressions;
using System;
using pdb.util;
using System.IO;
using pdb.gen.conf;

namespace pdb.gen.stat
{
    public class Condenseur
    {
        private Regex reg = new Regex("[6789]");
        public const string FILE = @"..\compact.txt";
        public const string FILE_SOV = @"..\compact_sov.txt";
        const char SEP = ';';

        private List<NewClassement> list;
        private int total;
        const int MIN = 6;
        const int MAX = 36;
        const double PART = 6;
        const int MAX_LEVEL = 9;
      //  double moy;

        /// <summary>
        /// Liste candidate 1234.2  au million 1234.2 ==> 1 234 200
        /// </summary>
        ClassStruct currentListLevel = new ClassStruct();


        const int MILLION = 1000 * 1000;

        int index = 0;

        /// <summary>
        /// Fichier de dauvegarde
        /// </summary>
        System.IO.TextWriter tw;
        /// <summary>
        /// éléments enregistrés
        /// </summary>
        HashSet<int> hs = new HashSet<int>();


        /// <summary>
        /// Liste à placer
        /// </summary>
        List<NewClassement> nextList = new List<NewClassement>();





        public Condenseur(IEnumerable<Piece> list)
        {
            this.list = new List<NewClassement>();
            foreach (Piece piece in list)
            {
                if (piece.Classement.isPositive())
                    this.list.Add(new NewClassement(piece));
            }
            this.list.Sort((x, y) => x.Piece.Classement.CompareTo(y.Piece.Classement));
            // this.list.Reverse();
            this.total = this.list.Count;

        }

        public List<NewClassement> NewClass { get { return list; } }

        private NewClassement lastItem;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m;
        int headLevel = 5;
        private void affect(int level, int nb)
        {
            if (index >= total)
                return;


            if (nb <= 6)
            {
                int nbRange = 0;
                currentListLevel.position();

                while (true)
                {
                    if (nbRange >= nb)
                        break;

                    var item = list[index];
                    lastItem = item;

                    Piece piece = item.Piece;
                    bool newp = hs.Add(piece.MasterId);

                    var values = currentListLevel.getValues();
                    item.setLevel(values);

                    if (newp)
                    {

                        var newc = item.getClassement();
                        var compact = Piece.classementHash.getCache(newc);


                        if (compact.ClassementValueDecimal == 0 || currentListLevel.isOccupe(compact.ClassementValueDecimal))
                        {

                            nbRange++;
                            currentListLevel.move();
                            continue;
                        }
                    }





                    //  bool compacte = false;

                    //if (piece.Enabled && piece.ClassementACompacter)
                    //{





                    if (Piece.Compact)
                    {

                        if (piece.setClassementCompact(item.getClassement()))
                        {
                            //misc.log("fin du compactage pour {0}", piece);
                            //index = total;
                            //return;

                            //tw.Write(piece.MasterId);
                            //tw.Write(SEP);
                            //tw.WriteLine(item.getClassement());
                            //nbRange++;
                            // compacte = true;

                        }
                    }

                    else
                        piece.setClassement(item.ClassList, item.Rating);
                    currentListLevel.occupe(item.Piece.ClassementValueDecimal(true));
                    //if (newp)
                    //{
                    //    nbRange++;
                    //    currentListLevel.move();
                    //}

                    index++;
                    if (index >= total)
                        return;

                    // currentListLevel.move();



                    //}
                    //else
                    //{

                    //  }




                    //if (compacte)
                    //{
                    //    var cl = lastItem.Piece.ClassementValueDecimal(false);
                    //    var curr = currentListLevel.getValueBase10();

                    //    if (curr - EPSILON <= cl)
                    //    {
                    //        currentListLevel.move();
                    //    }
                    //}

                }


            }
            else
            {
                // répartition
                int nbRestant = nb;
                for (int idir = 0; idir < 6; idir++)
                {
                    decimal nbth = (decimal)nbRestant / ((decimal)6 - (decimal)idir);
                    int subNb = (int)System.Math.Ceiling(nbth);
                    affect(level + 1, subNb);
                    nbRestant -= subNb;
                }
            }



        }

        private void load()
        {
            var dict = new Dictionary<int, Piece>();
            foreach (NewClassement nc in list)
            {
                var p = nc.Piece;
                if (!dict.ContainsKey(p.MasterId))
                    dict.Add(p.MasterId, p);

            }
            var lines = File.ReadAllLines(FILE);

            foreach (string line in lines)
            {
                if (string.IsNullOrWhiteSpace(line))
                    continue;
                var tab = line.Split(SEP);
                if (tab.GetLength(0) < 2)
                    continue;
                int id = Convert.ToInt32(tab[0]);
                if (!dict.ContainsKey(id))
                    continue;
                var piece = dict[id];
                if (Piece.Compact)
                {
                    if (piece.Enabled && piece.ClassementACompacter)
                        piece.setClassementCompact(tab[1]);
                }

            }

        }


        public static void deleteFile()
        {
            var f = new FileInfo(FILE);
            if (f.Exists)
            {
                f.CopyTo(FILE_SOV, true);
                f.Delete();
            }

        }
        public void gener2()
        {
            if (CConf.ConfGen.AlbumSort.compactAny)
                deleteFile();
            else if (File.Exists(FILE))
            {
                load();
                return;
            }
            Piece.resetCompact();
            using (tw = new System.IO.StreamWriter(FILE))
            {

                decimal densite = 1.0m;

                //moy = total + 100;
                //for (int i = 0; i < MAX_LEVEL; i++)
                //{
                //    moy /= PART;
                //}
                currentListLevel = new ClassStruct(); // list[0].Piece.ClasssementVakdlue;
                currentListLevel.init(7);
                int phase = 0;
                while (true)
                {
                    if (index >= total)
                        break;
                    NewClassement nPiece = list[index];
                    Piece piece = nPiece.Piece;
                    var classement = piece.ClassementValueDecimal(false);
                    if (classement <= 0)
                    {
                        index++;
                        continue;
                        // moy = 90; nbPieceByLevel = 10;
                    }

                    // 
                    var v = currentListLevel.getValue();
                    var v2 = piece.RapportClassement(false);

                    if (v2 > v)
                        v = v2;

                    if (v < 1)
                    {
                        if (phase == 0)
                            densite = 6;
                        else if (phase < 3)
                            densite = 6 - phase;
                        else
                        {
                            //if (currentListLevel < 0.1 * MILLION)
                            densite = 4 - 2 * v;
                            //else
                            //    densite = 6.444444444444 - 4.44444444 * (double)currentListLevel / MILLION; 
                        }

                    }
                    else if (v < 2)
                        densite = 3 - v;
                    //else if (currentListLevel < 2 * MILLION)
                    //{
                    //    densite = 3 - (double)currentListLevel / MILLION;
                    //}
                    else
                        densite = 1;

                    //densité = 1 ==> 6t par liste pour une profondeur de 4 (1234.5)
                    // je veux une distribution correspondant à une densité de 1 (6 par liste)

                    /*
    type    ex      nb	    niveau
    d	    1	    1296	1
    d	    1,2	    216	    2
    d	    1,23	36	    3
    l	    1,234	6	    4
    i	    1,234,5	1	    5

    // pour éviter de m'emmerder, je peux simplement remplir chaque niveau 3 avec les 36 * densité éléments. en descendant plus bas si nécessaire
    // soit 36 éléments normalement, mais 216 avec une densité 6 par exemple
                     * 
                     * A chaque passe , je positionne la structure au pas suivant profondeur 3 
                     * je calcule le nb d'éléments à répartir
                     * ex densité 1.1 : 36 *1.1 = 39.6 soit 7 + 7 + 7 + 6 +6
                     * pour chaque répartition, je descend en profondeur jusqu'à obtenir une densité relative <=1
                     * Soit : 2+1+1+1+1+1
                     *        2+1+1+1+1+1
                     *        2+1+1+1+1+1
                     *        1+1+1+1+1+1
                     *        1+1+1+1+1+1
                     *        
                     * au niveau 3
                
                     * 
                     * Comment on fait ? 
                     * fonction récursive? 
                     * */

                    //var d1 = densite;
                    //var incr = 1;
                    //var depth = 4; 

                    //while (true)
                    //{
                    //    if (d1 <= 1)
                    //        break;
                    //    depth++;
                    //    d1 /= 6; 
                    //}



                    //  densite = densite * 0.5; 
                    //else if (classement < 0.1)
                    //{ moy = 36; nbPieceByLevel = 6; }
                    //else if (classement < 0.2)
                    //{ moy = 24; nbPieceByLevel = 4; }
                    //else if (classement < 1)
                    //{ moy = 18; nbPieceByLevel = 3; }
                    //else if (classement < 2)
                    //{ moy = 12; nbPieceByLevel = 2; }
                    //else { moy = 6; nbPieceByLevel = 1; }

                    // 1234.2  au million 1234.2 ==> 1 234 200
                    //cas densite 1 100
                    //cas densite 2 100
                    // cas densite 3 100

                    // valeurs possibles de l'increment 1,2,3,10,20,30,100,200
                    //// maintenant 1234.2 ==> 1 234 200
                    //int increment = 200; // par 3
                    //int depth = 4;
                    //if (densite > 1)
                    //{ increment = 100; }
                    //if (densite > 2)
                    //{ increment = 30; depth = 5; }
                    //if (densite > 3)
                    //    increment = 20;
                    //if (densite > 6)
                    //{ increment = 10; }
                    //if (densite > 12)
                    //{ increment = 3; depth = 6; }
                    //if (densite >= 24)
                    //    increment = 1;
                    //var _current0 = currentListLevel;

                    misc.log("compact phase {0} courant {1} classement={2} densite {3} ", phase, currentListLevel, piece.ClassementValueDecimal(false), densite);

                    if (index >= total)
                        break;
                    decimal nbth = densite * 1296.0m;
                    int nbARepartir = (int)System.Math.Ceiling(nbth);

                    affect(headLevel, nbARepartir);
                    //  headLevel = currentListLevel.Level; 

                    phase++;
                    //if (phase >= 35)
                    //{
                    //    int toto = 0;
                    //}

                }


                //    while (currentListLevel < _current0 + 1000)
                //    {
                //        do
                //        {
                //            currentListLevel = currentListLevel + 1;
                //        }
                //        while (reg.IsMatch(currentListLevel.ToString()));
                //        nPiece.setLevel(currentListLevel); 
                //    }


                //    if (currentListLevel >= _current0 + 1000)
                //    {
                //        _current0 = currentListLevel;
                //        doWork2();
                //        nextList.Clear();

                //    }               
                //    nextList.Add(nPiece);

                //}
                //doWork2();

                //            foreach (NewClassement np in list)
                //            {
                //                Piece piece = np.Piece;
                //#if COMPACT
                //                piece.setClassementCompact(np.getClassement());
                //#else
                //                 piece.setClassement(np.ClassList, np.Rating);
                //#endif


                //            }
            }



            //private void doWork2()
            //{
            //    //   milieuCand = nbPiece + 0.5 * nextList.Count;

            //    foreach (NewClassement _new in nextList)
            //    {
            //        _new.setLevel(currentListLevel, 5);
            //        lastItemInConstruction = _new;
            //        nbPiece++;
            //    }


            //    incrementCurrentListLevelMinus();
            //}

            //    while (true)
            //    {
            //        if (milieuCand <= _objectif)
            //        {

            //            if (lastItemInConstruction != null)
            //            {
            //                incrementCurrentListLevelMinus();
            //            }

            //            foreach (NewClassement _new in nextList)
            //            {
            //                _new.Level = currentListLevel;
            //                lastItemInConstruction = _new;
            //                nbPiece++;
            //            }

            //            nextList.Clear();

            //            break;
            //        }

            //        changeCurrentList();

            //    }
            //}

            #region OLD
            //public void gener()
            //{
            //    //1. total
            //    total = list.Count;
            //    moy = total + 100;
            //    for (int i = 0; i < MAX_LEVEL; i++)
            //    {
            //        moy /= PART;
            //    }



            //    currentClassement = list[0].Piece.ClassementValueDecimal;
            //    for (int i = 0; i < total; i++)
            //    {
            //        NewClassement nPiece = list[i];
            //        Piece piece = nPiece.Piece;
            //        var classement = piece.ClassementValueDecimal;
            //        if (classement != currentClassement)
            //        {
            //            currentClassement = classement;
            //            doWork();
            //        }

            //        nextList.Add(nPiece);

            //    }

            //    doWork();

            //    foreach (NewClassement np in list)
            //    {
            //        Piece piece = np.Piece;
            //        piece.setClassement(np.ClassList, np.Rating);

            //    }
            //}

            //private void doWork()
            //{
            //    milieuCand = nbPiece + 0.5 * nextList.Count;
            //    while (true)
            //    {
            //        if (milieuCand <= _objectif)
            //        {

            //            if (lastItemInConstruction != null)
            //            {
            //                incrementCurrentListLevelMinus();
            //            }

            //            foreach (NewClassement _new in nextList)
            //            {
            //                //  _new.setLevel(currentListLevel, 4);
            //                lastItemInConstruction = _new;
            //                nbPiece++;
            //            }

            //            nextList.Clear();

            //            break;
            //        }

            //        changeCurrentList();

            //    }
            //}

            //private void incrementCurrentListLevel()
            //{
            //    nbList++;
            //    do
            //    {
            //        //     currentListLevel = (int)(currentListLevel) + 10;
            //    }
            //    while (reg.IsMatch(currentListLevel.ToString()));
            //    calculObj();

            //}

            //private void incrementCurrentListLevelMinus()
            //{
            //    var _old = currentListLevel;
            //    do
            //    {
            //        //        currentListLevel = currentListLevel + 1;
            //    }
            //    while (reg.IsMatch(currentListLevel.ToString()));
            //    //if ((int)_old != (int)currentListLevel)
            //    //{
            //    //    nbList++;
            //    //    lastItemInConstruction = null;
            //    //}
            //    calculObj();

            //}

            //private void calculObj()
            //{
            //    _objectif = moy * nbList;
            //}

            //private void changeCurrentList()
            //{
            //    incrementCurrentListLevel();
            //    lastItemInConstruction = null;
            //}

            #endregion

        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\NewClassement.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.gen.stat
{
    public class NewClassement
    {
        public readonly Piece Piece;
        //1.01 => 1010
        //1.0112=> 1011 et 40
        // private int level;
        const int MULT = 1;
        //private int depth;
        string classList;
        int rating;

        public NewClassement(Piece piece)
        {
            this.Piece = piece;
        }

        public NewClassement()
        {
        }

        public void setLevel(IEnumerable<int> tab)
        {
          
            StringBuilder sb = new StringBuilder();
            int current = -1;
            foreach (int v in tab)
            {
                if (current >= 0)
                    sb.Append(current);
                current = v; 
            }
            classList = sb.ToString();

            if (current >= 0)
                rating = current; 
        }



        public void setLevel(int l, int depth)
        {

            // 1234.2 ==> 1 234 200 => 12342
            // 234200 (0.2342) => 02342


            string s = l.ToString();
            var sb = new StringBuilder();
            var nb = 0;

            int k = 1000 * 1000;

            while (k > 1)
            {
                if (nb >= depth)
                    break;
                if (l < k)
                {
                    sb.Append("0");
                    nb++;
                }
                else
                    break;
                k /= 10;
            }

            var chars = s.ToCharArray();
            int i=0; 
            for (i = 0; i < chars.GetLength(0); i++)
            {
                if (nb >= depth)
                    break;
                sb.Append(chars[i]);
                nb++;

            }

            classList = sb.ToString();

            if (i < chars.GetLength(0))
                rating = Convert.ToInt32(chars[i].ToString()); 
         //   rating = l - Convert.ToInt32(classList);


        }
        public string ClassList
        {
            get
            {
                return classList;
                //int l = (int)(level * MULT);
                //var sb = new StringBuilder();
                //for (int i = 0; i < depth; i++)
                //    sb.Append("0");
                //string s = l.ToString(sb.ToString());
                //return s;
            }
        }

        public int Rating
        {
            get
            {
                return rating * 20;
                //double l = level * MULT;
                //int ll = (int)(level * MULT);
                //double r = (l - ll) * 10;
                //return Convert.ToInt32(r * 20);
            }
        }

        public string getClassement()
        {
            return string.Format("{0}.{1}", classList, rating); 
        }

        public override string ToString()
        {
            if (Piece != null)
                return Piece.Location + " old: " + Piece.Classement +  ", new:" + ClassList + ":" + Rating;

            return ClassList + ":" + Rating;
        }


    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math;

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        // const string ZIP_KEY = "db"; 
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        //private bool loadLastFull;
        //private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            if (conf.compressID)
            {
                compressIds();
                WriteDB1();

                return;
            }
            else if (conf.synchroID)
            {
                synchroIds();
                WriteDB1();
                return;
            }
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        //// r�cup�ration des infos externes
        //public void LegacyConsolid(CListPiece list, DateTime date)
        //{
        //    misc.log("Cdb::LegacyConsolid");

        //    DateTime now = DateTime.Now;
        //    ChronoData.refreshDate(date);

        //    foreach (CPiece ext in list)
        //    {
        //        m_list.legacyConsolid(ext);
        //    }

        //    m_list.bilanNatives();

        //    // setAlbumArtistFromFile();

        //}

        //public void LegacyConsolid(CPiece ext)
        //{
        //    m_list.legacyConsolid(ext);
        //}

        //public void SynchroNative(DateTime date)
        //{
        //    misc.log("Cdb::SynchroNative");
        //    ChronoData.refreshDate(date);
        //    foreach (CPiece piece in m_list)
        //    {
        //        piece.SynchroNative();
        //    }

        //}

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        //public void Sov(string fileIt)
        //{
        //    if (SOV == null)
        //        return;
        //    var list = new List<string> { fileIt, LOCAL_FILE.FullName };
        //    if (loadRemote)
        //        list.Add(REMOTE_FILE.FullName);
        //    if (loadTrace)
        //        list.Add(remoteTrace.FullName);

        //    ZipUtil.compress(SOV.FullName, sovRep, list);
        //}

        public void SovIni()
        {
            ZipUtil.Enter();
            if (SOV == null)
                return;
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni);

            ZipUtil.CompressAsync(SOV.FullName, sovRep, list);
            ZipUtil.Release();
        }


        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                ZipUtil.Enter();
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
                ZipUtil.Release();
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        public void export(string filename, List<CPiece> l)
        {

            var list = new List<CPiece>();
            var hs = new HashSet<int>();
            foreach (CPiece p in l)
            {
                if (hs.Add(p.PieceId))
                    list.Add(p);
                if (p.PieceParentId > 0)
                {
                    var parent = m_list.getPiece(p.PieceParentId);
                    if (hs.Add(parent.PieceId))
                        list.Add(p);
                }
            }

            m_list.Sort(list);

            var f = conf.getFilename(filename);
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(f, settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());


                writer.WriteStartElement(CListPiece.PIECES);

                foreach (CPiece l_piece in list)
                {
                    l_piece.write(writer);
                }
                writer.WriteEndElement();


                writer.WriteEndDocument();
                writer.Flush();
            }
        }

        private void write()
        {
            try
            {
                ZipUtil.Enter();
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
                {
                    writer.WriteStartElement("db");
                    writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                    m_list.write(writer);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



                if (lastFull != null)
                {
                    try
                    {
                        var diff = DiffFile.FullName;
                        if (mode == dbMode.full)
                            diff = diff.Replace(".xml", ".d.xml");

                        using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                        {
                            writer.WriteStartElement("db");
                            writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                            writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                            m_list.writeDiff(writer, lastFull);
                            writer.WriteEndDocument();
                            writer.Flush();
                        }

                        File.Copy(diff + ".tmp", DiffFile.FullName, true);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }



                WriteDB2();
            }
            finally
            {
                ZipUtil.Release();
            }
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        private void WriteDB2()
        {

            misc.log("CDb:WriteDB2");

            lock (lockSave)
            {
                ZipUtil.Enter();
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
                ZipUtil.Release();
            }
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff);
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }
            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            if (SOV == null)
                return; 
            ZipUtil.CompressAsync(SOV.FullName, sovRep, list, withHorodate,true);
            //   ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece);
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }


        public void synchroIds()
        {
            misc.log("WARNING:::::::::::Compressids");
            lastFull = loadData(LastFullFile);


            m_list = loadData(LOCAL_FILE);

            List<CPiece> listC = m_list.getList();

            for (int i = 0; i < listC.Count; i++)
            {
                var p = listC[i];
                var parent = p.Parent;


                var org = lastFull.tryGetPiece(p);
                // var org0 = lastFull.tryGetPieceWithoutId(p);
                if (org.Location != p.Location)
                {
                    org = lastFull.tryGetPieceWithoutId(p);
                }

                if (p.PieceId == org.PieceId)
                {

                }
                else
                {
                    // ????
                    p.setId(org.PieceId);
                }



                if (parent != null)
                {
                    var porg = lastFull.tryGetPiece(parent);

                    if (porg.Location != parent.Location)
                        porg = lastFull.tryGetPieceWithoutId(parent);


                    if (parent.PieceId == porg.PieceId)
                    {

                    }
                    else
                    {
                        // ????
                        p.PieceParentId = porg.PieceId;
                    }
                }

            }
            m_list.refresh(); 

        }


        public void compressIds()
        {
            misc.log("WARNING:::::::::::Compressids");

            lastFull = loadData(LastFullFile);


            List<CPiece> listFull = lastFull.getList();
            // loadList(LastFullFile, listFull);
            listFull.Sort((x, y) => x.PieceId.CompareTo(y.PieceId));
            var dict = new Dict<int, int>();

            int newID = 0;
            for (int i = 0; i < listFull.Count; i++)
            {
                newID++;
                var p = listFull[i];
                dict[p.PieceId] = newID;
            }

            pieceSequenceId = newID;

            for (int i = 0; i < listFull.Count; i++)
            {
                var p = listFull[i];
                p.setId(dict[p.PieceId]);
                if (p.PieceParentId > 0)
                {
                    p.PieceParentId = dict[p.PieceParentId];
                }
            }

            //     lastFull = new CListPiece(listFull, LastFullFile.LastWriteTime);
            lastFull.refresh();
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(LastFullFile.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                lastFull.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(LastFullFile.FullName + ".tmp", LastFullFile.FullName, true);

            m_list = loadData(LOCAL_FILE);

            List<CPiece> listC = m_list.getList();

            for (int i = 0; i < listC.Count; i++)
            {
                var p = listC[i];
                var parent = p.Parent;

                var newId = dict[p.PieceId];
                if (newID > 0)
                {
                    var org = lastFull.tryGetPiece(p);
                    var org0 = lastFull.tryGetPieceWithoutId(p);
                    if (org == org0)
                    {
                        p.setId(newId);

                        if (parent != null)
                        {
                            var newPId = dict[parent.PieceId];
                            if (newPId > 0)
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                var porg0 = lastFull.tryGetPieceWithoutId(parent);

                                if (porg == porg0)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }
                            else
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                if (porg.Location == parent.Location)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }

                        }

                    }
                    else
                    {
                        if (org0.Location == p.Location)
                        {
                            p.setId(org0.PieceId);
                        }
                    }
                }
                else
                {
                    var org = lastFull.tryGetPiece(p);
                    if (org.Location == p.Location)
                    {
                        p.setId(org.PieceId);

                        if (parent != null)
                        {
                            var newPId = dict[parent.PieceId];
                            if (newPId > 0)
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                var porg0 = lastFull.tryGetPieceWithoutId(parent);

                                if (porg == porg0)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }
                            else
                            {
                                var porg = lastFull.tryGetPiece(parent);
                                if (porg.Location == parent.Location)
                                {
                                    p.PieceParentId = porg.PieceId;
                                }
                                else
                                {

                                }
                            }

                        }
                    }
                    else
                    {

                    }



                }


            }
            m_list.refresh();
            //  m_list = new CListPiece(listC, LOCAL_FILE.LastWriteTime); 

        }

        private CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }




        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(PlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
  <file path="\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_FOLDER = "f";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private PlayList listes = new PlayList("listes");
        public PlayList Listes { get { return listes; } }

        public const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            init(a_list);

            //foreach (CPiece l_file in a_list)
            //{
            //    htIds[l_file.PieceId] = l_file;
            //    foreach (CFile file in l_file.Files)
            //    {
            //        htLoc[file.Path] = l_file;
            //    }
            //}
            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            //DateTime maxEnabled = DateTime.MinValue;
            //foreach (CPiece l_file in a_list)
            //{
            //    Add(l_file);
            //    //if (l_file.Enabled)
            //    //{
            //    //    var t = l_file.LastModifClass;
            //    //    if (t > maxEnabled)
            //    //        maxEnabled = t;
            //    //}
            //}
            //misc.log("***********************************************************");
            //misc.log("maxEnabled: {0}", maxEnabled);
            //misc.log("***********************************************************");
        }


        public void refresh()
        {
            var list = getList();
            ht = new DictRef<CPiece>();
            htIds = new BgDict<int, CPiece>();
            htLoc = new BgDictString<CPiece>();

            init(list);
        }

        private void init(ICollection<CPiece> a_list)
        {
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
            }
        }

        public CListPiece()
        {

        }

        #endregion


        public void checkId(CPiece toCheck)
        {
            foreach (CFile f in toCheck.Files)
            {
                if (htLoc.ContainsKey(f.Path))
                {
                    var pOrg = htLoc[f.Path];
                    toCheck.setId(pOrg.PieceId);
                    toCheck.PieceParentId = pOrg.PieceParentId;
                }
            }
        }

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        public void bilanNatives()
        {
            misc.log("Bilan Natives");
            foreach (CPiece piece in this)
            {
                if (piece.HasNoNative)
                    misc.logNoDate(piece.ToString());
            }
        }

        private void merge(CPiece org, CPiece cand)
        {
            misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
            org.merge(cand);
        }

        public void AddOrMerge(CPiece piece, CPiece org)
        {
            if (org != null)
            {
                org.consolid(piece, mergePriority.right);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
            }
            htIds[piece.PieceId] = piece;
            foreach (CFile file in piece.Files)
            {
                htLoc[file.Path] = piece;
            }


        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.addDataLink(toDelete);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            if (remote.PieceParentId > 0)
            {
                if (remote.Parent == null)
                    remote.Parent = htIds[remote.PieceParentId];


            }
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (remote.PieceParentId > 0)
                {
                    var parent = htIds[remote.PieceParentId];
                    misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                    l_pieceOrg.PieceParentId = remote.PieceParentId;
                    l_pieceOrg.Parent = parent;
                }
                //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                l_pieceOrg.consolid(remote, a_priority);
            }
        }

        ///// <summary>
        ///// synchro enrte base locale et liste native
        ///// </summary>
        ///// <param name="native"></param>
        ///// <remarks></remarks>
        //public void legacyConsolid(CPiece native)
        //{
        //    CPiece l_pieceOrg = getPiece(native);

        //    if (l_pieceOrg == null)
        //    {
        //        log("add from business:" + native.ToString());
        //        l_pieceOrg = new CPiece(native);
        //        l_pieceOrg.legacyConsolid(native);
        //        Add(l_pieceOrg);
        //    }
        //    else
        //    {
        //        l_pieceOrg.legacyConsolid(native);
        //    }

        //}

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece tryGetPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.Try(key);
        }

        public CPiece tryGetPieceWithoutId(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.TryWithoutId(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        public void moveId(int oldId, CPiece piece)
        {

        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, PIECES);
            foreach (CPiece l_piece in this)
            {
                l_piece.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, PIECES);
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            Sort(list);

            return list;
        }

        public void Sort(List<CPiece> list)
        {
            list.Sort(new PieceComparer());
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, PlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    PlayList sub = new PlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];

                    // var tl = new TrackList(piece);
                    parent.add(piece);
                }
            }
        }

        private void writeList(XmlWriter w, PlayList parent)
        {
            foreach (PlayList pl in parent.PlayLists)
            {
                w.WriteStartElement(TOKEN_LIST);
                w.WriteAttributeString("id", pl.ID.ToString());
                w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                writeList(w, pl);
                w.WriteEndElement();
            }

            foreach (IItem t in parent.Items)
            {
                w.WriteStartElement(TOKEN_LIST_TRACK);
                w.WriteAttributeString("id", t.ID.ToString());
                w.WriteEndElement();
            }
            //foreach (PlComponent c in parent)
            //{
            //    if (c is CPlayList)
            //    {
            //        var pl = c as CPlayList;
            //        w.WriteStartElement(TOKEN_LIST);
            //        w.WriteAttributeString("id", pl.ID.ToString());
            //        w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
            //        writeList(w, pl);
            //        w.WriteEndElement();
            //    }
            //    else if (c is TrackList)
            //    {
            //        var t = c as TrackList;
            //        w.WriteStartElement(TOKEN_LIST_TRACK);
            //        w.WriteAttributeString("id", t.PieceId.ToString());
            //        w.WriteEndElement();
            //    }
            //}
        }

        public void buildLists(PlayList listes)
        {
            this.listes.DeleteChilds();
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                CDb.checkId(sub);
                subExt.ID = sub.ID;

                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }
        }
        #endregion
    }

}






]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 


    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes, IItem
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
        //  private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";
        private const string TOKEN_ADDED = "added";

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private DateTime added;
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
        // private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        public DateTime Added { get { return added; } }
        public void setAdded(DateTime dt) { added = dt; }

        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        //public bool FirstClass
        //{
        //    get
        //    {
        //        if (native == null) return false;
        //        return native.FirstClass;
        //    }
        //    set { if (native == null) return; native.FirstClass = value; }
        //}
        public bool HasNoNative { get { return native == null; } }
        //private void OnCommentChange(String value)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.Comment = value;
        //}
        //private void OnGroupingChange(String value, bool prior)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.setGrouping(value, prior);
        //}
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement(this);
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(this, baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            //  string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
            // this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(this, ext.Classement);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;

            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(this, a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable();
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement(this);

            }





            var xtool = new XMLTool(a_xml);
            //  artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);




            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            string strAdded = "";
            var attAdded = a_xml.Attributes[TOKEN_ADDED];
            if (attAdded != null)
                strAdded = attAdded.Value;
            else
                strAdded = xtool.getNodeValue(TOKEN_ADDED);

            if (!string.IsNullOrEmpty(strAdded))
            {
                try
                {
                    added = Convert.ToDateTime(strAdded);
                }
                catch (Exception ex)
                {
                    log(string.Format("impossible de parser {0} {1} {2}", strAdded, this, ex));
                }
            }


            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        private void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        public void addDataLink(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement);
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                if (remote.added > DateTime.MinValue && remote.added < DateTime.MaxValue && remote.added != added)
                    added = remote.added;

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        ///// <summary>
        ///// piece de la liste native consolidée ou mise à jour 
        ///// suivant le cas par le fichier maison
        ///// </summary>
        ///// <param name="native"></param>
        ///// <remarks></remarks>
        //public void legacyConsolid(CPiece l_native)
        //{



        //    //TODO éviter de créer un objet juste pour la comparaison
        //    //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



        //    //this.grouping = l_native.Grouping;
        //    //this.m_comment = l_native.Comment; 







        //    l_native.m_ref.legacyConsolid(this.m_ref);
        //    l_native.m_infos.legacyConsolid(this.m_infos);

        //    l_native.setClassPlayList(this);
        //    l_native.Classement.LegacyConsolid(this.Classement);
        //    l_native.Checked.LegacyConsolid(this.Checked);

        //    //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

        //    addData(l_native);

        //    this.m_playList = l_native.PLayLists;
        //    this.m_classPlayLists = l_native.ClassPlayLists;
        //    this.m_duration = l_native.Duration;
        //    raiseChangeRefEvent();

        //    //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
        //    this.native = l_native.native;

        //    checkNative();
        //}

//        /// <summary>
//        /// Synchro directe entre la Db et le track Itunes (mode daemon)
//        /// </summary>
//        public void SynchroNative()
//        {
//            checkNative();
//            if (native == null)
//                return;

//            m_ref.SynchroNative(native);
//#if VOL
//            m_infos.SynchroNative(native.Year, native.Volume);
//#else
//            m_infos.SynchroNative(native.Year);
//#endif
//            var newClassList = getClassName(native);
//            Classement newCl = pdb.obj.Classement.create(native.Classement); //  new Classement(newClassList, native.Rating);
//            Classement.SynchroNative(newCl);
//            Checked.SynchroNative(native.Enabled);

//            this.ListDates.merge(native.PlayedDate);



//            //  this.m_playList = native.PLayLists;
//            this.m_classPlayLists = native.ClassPlayLists;
//            if (native.Duration.TotalMilliseconds > 1)
//                this.m_duration = native.Duration;
//            raiseChangeRefEvent();
//        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }



        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        //private void setClassPlayList(ITrackNative pieceDb)
        //{
        //    string dbClasslist = pieceDb.Classement.ClassList;
        //    int count = m_classPlayLists.Count;
        //    if (count > 0)
        //    {
        //        string className = m_classPlayLists[0].Name;
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //            foreach (var list in m_classPlayLists)
        //            {
        //                className = list.Name;
        //                if (className == dbClasslist)
        //                    continue;
        //                break;
        //            }
        //        }

        //        if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
        //        {
        //            misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
        //            return;
        //        }
        //        if (Classement.Value.ClassList != className)
        //        {
        //            throw new NotImplementedException("gloups"); 
        //        }


        //    }
        //}

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        ////utilisé par le player maison
        //public void setClassPlayList(String name)
        //{
        //    Classement.ClassList = name;
        //    // TODO Gérer l'absence de classList
        //}

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.Value.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            //if (artWork.NotNullOrEmpty())
            //    XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
            if (added > DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_ADDED, added.ToString());

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (added > DateTime.MinValue)
                    w.WriteAttributeString(TOKEN_ADDED, added.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }



                //if (artWork.NotNullOrEmpty())
                //    w.WriteElementString(TOKEN_ARTWORK, artWork);



                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0} {1}", this, ex);
                throw;
            }
        }


        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());
            if (added != lastFull.added)
                w.WriteAttributeString("added", added.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }






            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;

            if (added != lastFull.Added)
                return true;

            //if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
            //    return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.obj.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }




        public CListFile Files
        {
            get { if (parent == null) return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.Value.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating * 20; }
            set
            {
                if (Classement.Rating * 20 != value)
                {
                    throw new NotImplementedException();
                }
            }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        // public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id == value)
                return;
            if (value > 0)
            {
                key = null;
                if (m_id > 0)
                    misc.log("id from {0} to {1} {2}", m_id, value, this);
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        Classement ITrackNative.Classement { get { return Classement.Value; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value;
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }





        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId);
            return string.Format("{0} {1}{2}{3} {4} {5}", Classement.Value, PieceId, parent, Name, Album, getLocation());
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return getLocation() + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return Files.Path;
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public string getLocation()
        {
            return Files.getLocation();
        }

        public bool? Exists { get { return Files.Exists; } }
        public bool ExistsNow { get { return Files.ExistsNow(); } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        //private string _comment;
        //public string Comment
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return "";
        //        if (_comment == null)
        //        {
        //            if (native != null)
        //                _comment = native.Comment;
        //        }
        //        return _comment;

        //        //string l_pref = "";
        //        //string l_str = "";

        //        //string l_strList = "";
        //        //if (ClassPlayList != null)
        //        //    l_strList = ClassPlayList.Name;

        //        //if (Classement.Imported)
        //        //{
        //        //    if (l_strList != ClassList)
        //        //    {
        //        //        l_pref = "m (" + ClassList + ") ";
        //        //    }
        //        //}
        //        //int l_rank = m_rank.Twice;
        //        //if (l_rank > 0)
        //        //{
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }

        //        //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
        //        //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //    //getTx(m_rank.Lenght)
        //        //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
        //        //}

        //        //return l_pref + l_str + getClassementEvol();

        //    }
        //    set
        //    {
        //        if (parent != null)
        //            return;
        //        if (value != _comment)
        //        {
        //            _comment = value;
        //            //if (value != Comment)
        //            //{
        //            // m_comment = value;
        //            OnCommentChange(value);
        //        }
        //        // }
        //    }
        //}
        //private string _grouping;
        //public string Grouping
        //{
        //    get
        //    {
        //        if (_grouping == null)
        //        {
        //            if (native != null)

        //                _grouping = native.Grouping;
        //        }
        //        return _grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (value != Grouping)
        //    //    //{
        //    //    //  grouping = value;
        //    //    OnGroupingChange(value);
        //    //    //}
        //    //}
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    if (value != _grouping)
        //    {
        //        _grouping = value;
        //        OnGroupingChange(value, prior);
        //    }
        //}

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            throw new NotImplementedException(); 
          
          //  native.Rating = value.Rating; native.Classement.ClassList = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }


        private CPiece parent;

        public void setParent(CPiece parent)
        {
            this.parent = parent;
        }
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {

                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    parent = null;
                    return;
                }
                else
                {
                    value.Master.addDataLink(this);
                    parent = value.Master;
                    PieceParentId = parent.PieceId;
                }



            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState;
        public exportState ExportStatus
        {
            get
            {
                return _exportState;
            }
            set
            {
                _exportState = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return Classement.getDates();
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public bool Played
        {
            get { return Dates.Count > 0; }
        }


        public string strClassement
        {
            get { return Classement.ToString(); }
        }


        public Classement DeepClassement
        {
            get { return Classement.DbValue; }
        }

        public Classement MaxClassement { get { return Classement.MaxClassement(); } }






    }
}






]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceDataClassement.cs">
    <content><![CDATA[using System;
using pdb.obj;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;
using pdb.db.obj;
using System.Collections.Generic;
using System.Xml;
namespace pdb.db.piece.data
{


    public class CPieceClassement : CPieceData<Classement>
    {
        private CPiece piece;
        private const string TOKEN_CLASSEMENT = "classement";


        public CPieceClassement(CPiece piece, System.Xml.XmlElement a_node)
            : base(a_node)
        {
            this.piece = piece;
            if (XMLTool.NodeLookUp(a_node, getToken()) == null)
            {
                CPieceDataValueClassement l_data = new CPieceDataValueClassement(a_node);
                m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, l_data));
            }
            //  int count = m_list.Count;
            //            if (count > 0)
            //            {
            //                var version = m_list[count - 1];
            //                if (string.IsNullOrEmpty(version.Data.Value.ClassList))
            //                {
            //                    version.Consider = false;
            //                    //  empty = Bool.not_defined; 
            //                }
            //#if ASC
            //                var versionF = m_list[0];
            //                var valueOrg = versionF.Data;
            //                var classOrg = valueOrg.Value.ClassList;
            //                var rating = valueOrg.Value.Rating;
            //                if (classOrg.StartsWith("0"))
            //                {
            //                    classOrg = "1";
            //                    rating = 0; 
            //                  //  classOrg = classOrg.Remove(0, 1);
            //                }

            //                valueOrg.Value = new Classement(classOrg, rating); 

            //#endif
            //            }


        }

        public void initClassementIfEmpty(string classement)
        {
            if (m_list.Count > 0)
                return;
            var cl = pdb.obj.Classement.create(classement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public void eraseClassement()
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            initClassementIfEmpty("0.0");
        }


        public CPieceClassement(CPiece piece, string strClassement)
        {
            this.piece = piece;
            var cl = pdb.obj.Classement.create(strClassement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public CPieceClassement(CPiece piece, Classement o)
        {
            this.piece = piece;
            //   var cl = pdb.obj.Classement.create(o);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(o)));
        }

        //public CPieceClassement(CPiece piece, string a_class, int a_rating)
        //{
        //    this.piece = piece;
        //    Classement l_class = Classement.create(a_class, a_rating);
        //    m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_class)));
        //    // empty = Bool.not_defined; 

        //}

        //public CPieceClassement(CPiece piece, int a_rating)
        //    : this(piece, "", a_rating)
        //{
        //}
        public CPieceClassement(CPiece piece)
            : base()
        {
            this.piece = piece;
        }

        protected override bool CheckLegacyConsistency()
        {
            return false;
        }
        public override CPieceDataValue<Classement> createPieceDataValue(System.Xml.XmlElement a_node)
        {
            return new CPieceDataValueClassement(a_node);
        }

        public override string getToken()
        {
            return TOKEN_CLASSEMENT;
        }

        public override CPieceDataValue<Classement> createPieceDataValue(string a_str)
        {
            return null;
        }

        public override Classement getNullValue()
        {
            return Classement.NULL;
        }
        public override CPieceDataValue<Classement> createPieceDataValueT(Classement value)
        {
            return new CPieceDataValueClassement(value);
        }

        public override bool isSignificant(Classement value)
        {
            return value.ClassList != "";
        }


        protected override void writeSimple(XmlWriter w)
        {
            w.WriteStartElement(getToken());
            m_list[0].Data.write(w);
            w.WriteEndElement();
        }

        public void setClassement(string className, int rating)
        {
            Classement cl = Classement.create(className, rating);
            if (m_list.Count == 0)
                m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
            else
                m_list[0].Data.Value = cl;
            sortAndCompact();
        }

        public void eraseClassement2()
        {
            Classement cl = Classement.create("0.0");
            eraseClassement2(cl);
        }

        public void eraseClassement2(Classement cl)
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, new CPieceDataValueClassement(cl)));
        }

        public int Rating
        {
            get { return Value.Rating; }
            //set { Value.Rating = value; }
        }



        protected override bool canErase()
        {
            return true;
        }

        public override void Consolid(CPieceData<Classement> remote, mergePriority a_priority)
        {
            base.Consolid(remote, a_priority);
            this.checkList(remote);
        }

        public override void LegacyConsolid(CPieceData<Classement> local)
        {
            base.LegacyConsolid(local);
            this.checkList(local);
        }

        public bool isClassListNumeric { get { return Value.isClassListNumeric; } }



        public String Evol
        {
            get
            {

                if (m_list.Count <= 1) return "++";

                Classement last = m_list[0].Data.Value;
                Classement before = m_list[1].Data.Value;

                String strLast = last.ClassNameAndRating;
                String strBefore = before.ClassNameAndRating;

                int cmp = compareClassNameAndRating(strLast, strBefore);
                if (cmp == 0)
                    return "=";  // normalement impossible
                if (cmp < 0) return "+";
                return "-";
            }

        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

        public List<DateTime> getDates()
        {
            var list = new List<DateTime>();
            foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
            {
                list.Add(version.Date);
            }
            return list;

        }

        public override CListDate Dates
        {
            get
            {
                var list = new List<DateTime>();
                //    double current = -1;
                // sortAndCompact();
                foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
                {
                    //double aux = version.Data.Value.getNormValue();
                    //if (aux != current)
                    //{
                    list.Add(version.Date);
                    // current = aux; 
                    //}
                }
                return new CListDate(list);
            }
        }

        public void Menage(CPiece piece)
        {
            sortAndCompact();
            //   misc.log("ménage " + this); 

            var aux = new List<CPieceDataVersion<Classement>>(m_list);


            //// 1. parcours jusqu'à trouver 1.0
            //int index1 = -1;
            //int count = aux.Count;

            //for (int i = 0; i < count; i++)
            //{
            //   CPieceDataVersion <Classement> clv = aux[i];
            //   if (clv.Data.Value.getNormValue() == 1)
            //   {
            //       index1 = i;
            //       break; 
            //   }
            //}

            //if (index1 >= 0)
            //{
            //    while (aux.Count > index1 + 1)
            //    {
            //        misc.log( piece  + " suppression " + aux[index1 + 1] + " cause départ à 1");
            //        aux.RemoveAt(index1 + 1);
            //    }
            //}

            //2. vérification des allez-retours 
            int count = aux.Count;

            while (count > 2)
            {
                for (int i = 0; i < count; i++)
                {
                    var clv0 = aux[i].Data.Value;
                    if (i + 2 >= count)
                    {
                        count = -1;
                        break;
                    }
                    var clv2 = aux[i + 2].Data.Value;
                    if (clv2.getNormValue() == clv0.getNormValue())
                    {
                        misc.log(piece + "suppression " + aux[i] + " cause doublon avec " + aux[i + 2]);
                        aux.RemoveAt(i);
                        count = aux.Count;
                        break;
                    }
                }

            }

            m_list = aux;
            sortAndCompact();



        }

        public override string ToString()
        {
            return Value.ToString();
        }

        protected override void changeNativeValue(Classement value)
        {
            observer.changeNativeValueClassement(value);
        }

        #region on repart de zero
        private static DateTime dateMin;
        public static DateTime DateMin { set { dateMin = value; } }
        //private bool keep;
        //public bool Keep { get { return keep; } set { keep = value; } }

        protected override Classement getPlainValue()
        {
            if (piece.Enabled && m_list[0].Date < dateMin) //&& !keep
            {
                if (m_list[0].Data.Empty)
                    return getNullValue();
                return Classement.ZERO;
            }
            return base.getPlainValue();
        }
        #endregion


        public Classement MaxClassement()
        {
            if (m_list.Count == 0)
                return getNullValue();
            Classement max = null;
            foreach (var p in m_list)
            {
                var cand = p.Data.Value;
                if (max == null || max.CompareTo(cand) < 0)
                    max = cand;
            }
            return max;
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValueClassement.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.obj;
using pdb.util;
using pdb.db.piece.data;

namespace pdb.db.piece.value
{
    public class CPieceDataValueClassement : CPieceDataValue<Classement>
    {
        public const string TOKEN_CLASS = "class";

        private const string TOKEN_RATING = "rating";
        //private const string TOKEN_CL = "cl"; 
        public CPieceDataValueClassement(Classement a_value)
        {
            m_data = a_value;
        }

        public override CPieceDataValue<Classement> createCopy()
        {
            var o = new CPieceDataValueClassement(m_data);
            return o;
        }

        private void new_(System.Xml.XmlElement a_node)
        {
            var att = a_node.Attributes[TOKEN];
            if (att != null)
            {
                string cl = att.Value;
                m_data = Classement.create(cl);
                return;
            }
            string l_class = XMLTool.getNodeValue(a_node, TOKEN_CLASS);
            int l_rating = -1;
            string l_strRating = XMLTool.getNodeValue(a_node, TOKEN_RATING);
            if (!string.IsNullOrEmpty(l_strRating))
                l_rating = Convert.ToInt32(l_strRating);

            m_data = Classement.create(l_class, l_rating);

        }

        public CPieceDataValueClassement(System.Xml.XmlElement a_node)
        {
            XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
            if (l_v2 != null)
            {
                new_(l_v2);
            }
            else
            {
                new_(a_node);
            }

        }

        public override bool Equals(object obj)
        {
            if (obj is CPieceDataValueClassement)
            {
                CPieceDataValueClassement l_obj = (CPieceDataValueClassement)obj;
                return this.m_data.Equals(l_obj.m_data);
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_data.GetHashCode();
        }

        public override bool Empty
        {
            get
            {
                if (m_data == null)               
                    return true;
              
                return string.IsNullOrEmpty(m_data.ClassList);
            } //&& m_data.Rating <= 0; }
        }
        public override bool Significant
        {
            get { return !string.IsNullOrEmpty(m_data.ClassList) && m_data.Rating >= 0; }
        }

        public override string ToString()
        {
            return m_data.ClassNameAndRatingWithPt;
            var l_sw = new StringBuilder();
            XMLTool.writeValue(l_sw, TOKEN_CLASS, m_data.ClassList);
            XMLTool.writeValue(l_sw, TOKEN_RATING, m_data.Rating);
            //  l_sw.Close();
            return l_sw.ToString();
        }

        protected override void writeDb(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN_CLASS, XMLTool.RefToXml(m_data.ClassList));
            XMLTool.writeValue(a_sw, TOKEN_RATING, m_data.Rating);
        }

        //protected override void writeDb(XmlWriter w)
        //{
        //    w.WriteAttributeString(CPieceClassement.TOKEN_CLASSEMENT, m_data.ClassNameAndRatingWithPt);  
        //   //w.WriteElementString(TOKEN_CLASS, m_data.ClassList);
        //   //w.WriteElementString(TOKEN_RATING, m_data.Rating.ToString()); 
        //}

    }
}
]]></content>
  </file>
  <file path="\pieceDb.iT\Loader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Diagnostics;
using pdb.it.detect;
using System.Collections;
using pdb.it.auto;
using pdb.it.persistance;
using pdb.ordo;
using System.Threading.Tasks;
using pdb.iit;

namespace pdb.it
{

    public class Loader : ITrackBuilder, IAbortTask
    {
        private Action abortList;
        protected Logger log = Logger.getLogger("Loader");
        private iTunesApp app;
        private IITSource mainLibrairy;
        private IITPlaylistCollection mainPlayLists;
        //  private IITUserPlaylist BIB;
        private PlayList root = PlayList.create("root", null);
        private List<PlayList> logicals = new List<PlayList>();
        private bool listLoaded;
        //private CPlayList rootComposite = new PlayListComposite("root");
        private String m_defaultFolder = @"D:\zique\";
        private String _dBLegacyPath = "";
        private String _dBLegacyDir = "";
        private XmlElement contentXml;

        private ITrackBuilder trackBuilder;
        private List<ITrackInfoItunes> list;
        public ITrackBuilder TrackBuilder { set { trackBuilder = value; } }
        private IPlayListFilter filterPlaylist = new PlayListDefaultFilter();
        public IPlayListFilter PlayListFilter { set { filterPlaylist = value; } }
        public int VolumeMin = -125;

        public bool Slave { get { return conf.slave; } }

        private bool checkSong;

        private bool writeOnlyEnabled;
        private bool writeOnlyUnRead;


        private BgDict<int, TrackInfoItunes> m_htPieces = new BgDict<int, TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> m_htLoc = new BgDictString<TrackInfoItunes>();
        private BgDict<int, IITFileOrCDTrack> m_htTracks = new BgDict<int, IITFileOrCDTrack>();

        public void getNatives(ArrayList list)
        {
            foreach (IITFileOrCDTrack t in m_htTracks.Values)
                list.Add(t);
        }

        // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();

        //   private Dictionary<int, TrackInList> m_htPiecesInAList = new Dictionary<int, TrackInList>();
        private BgDict<int, PlayListComposite> m_htPlayLists = new BgDict<int, PlayListComposite>();
        private PlayListRegister m_htLegacyPLayList; // Dictionary<int, IITUserPlaylist>();

        /// <summary>
        /// index des listes suivant persistantID (Xml) 
        /// </summary>
        private BgDictString<PlayList> persistentIDs = new BgDictString<PlayList>();

        #region parsing natif asynchrone
        //  private bool bParsingNativeAsync = true;
        //  private ThreadUtil loopbgLoadTracksNative;

        /// <summary>
        /// dictionnaire des Tracks musique par ID
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTracks = new BgDict<int, IITFileOrCDTrack>();

        private TracksDb persist;
        /// <summary>
        /// dictionnaire tracks par location
        /// </summary>
        //   private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb persistTracks; 
        //  private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        /// <summary>
        /// dictionnaires des tracks de playlist par ID (pas l'ID du track de liste mais l'ID du track de bib)
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTrackList = new BgDict<int, IITFileOrCDTrack>();

        /// <summary>
        /// Cumul des dictionnaires des tracks de playList par location
        /// </summary>
        // private BgDictString<IITFileOrCDTrack> memoTrackList = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb memoTrackList;

        private BgDictString<TrackInList> dictTrackInList = new BgDictString<TrackInList>();

        private BgDictString<TrackInList> logicalDictTrackInList = new BgDictString<TrackInList>();
        private BgDictString<TrackInList> logicalDictTrackInListDeleted = new BgDictString<TrackInList>();


        private static string getKey(string path, string location)
        {
            return String.Concat(path, ":", location).ToLower();
        }

        /// <summary>
        /// Récupération d'un track base ou liste pour ajout de trackListe
        /// </summary>
        /// <param name="location"></param>
        /// <returns></returns>
        public TrackId getAnyTrackByLocation(string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            var t = persist.getTrack(location);
            if (t == null)
            {
                if (FileRegister.ExistNow(location)) //  File.Exists(location))
                    loadScan("recherche location" + location);
            }
            return t;
        }



        public TrackInList getTrackInList(string path, string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            return dictTrackInList[getKey(path, location)];
        }

        public void recordTrackList(string pl, IITFileOrCDTrack track, int trackDataBaseID, string location, bool memo)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(location))
            {
                StackTrace st = new StackTrace();
                log.log("Loader::recordTrackList location nulle " + st.ToString());
                return;
            }
            //if (!dictTrackList.ContainsKey(trackDataBaseID))
            dictTrackList[trackDataBaseID] = track;
            var key = getKey(pl, location);
            persist.recordTrackList(key, location, track);
            //if (!locationTrack.ContainsKey(location))
            //    locationTrack.record(location, track);

            //if (memo && !memoTrackList.ContainsKey(key))
            //    memoTrackList.record(key, track);

            //  return id;

        }

        public void invalidationTrack(TrackInfoItunes info)
        {
            log.log("invalidation track lors de modification " + info);

            dictTracks.Remove(info.ID);
            dictTrackList.Remove(info.ID);
            persist.invalidation(info.Location);
        }

        public void invalidationTrackInList(string pl, TrackInList tl, IITUserPlaylist _pl)
        {
            log.log("invalidation trackinList " + tl);
            removeTrackInList(pl, tl, _pl);
        }

        /// <summary>
        /// Appelé en cas d'erreur ajout trackList
        /// </summary>
        /// <param name="location"></param>
        /// <param name="id"></param>
        public void invalidationLocation(string location)
        {
            log.log("invalidation track (AddTrack)" + location);
            persist.invalidation(location);
        }


        //public void recordTrackList(PlayList pl, IITFileOrCDTrack track, string location)
        //{

        //    if (!locationTrack.ContainsKey(location))
        //        locationTrack[location] = track;
        //    var key = getKey(pl, location);
        //    memoTrackList[key] = track;
        //}

        public TrackId getMemoTrackList(string path, IITUserPlaylist pl, string location)
        {
            var key = getKey(path, location);
            return persist.getTrackList(key, path, pl);
            // return memoTrackList.getTrackList(key, pl); //  [key];
        }



        private static bool erreurTrackList;
        public static bool ErreurTrackKist { get { return erreurTrackList; } set { erreurTrackList = value; } }



        public void recordTrackInList(string pl, TrackInList track, bool verifDoublon)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            //if (dictTrackInList.ContainsKey(key))
            //{
            //    if (verifDoublon)
            //    {
            //        string txt = "pas deux fois le même élément de liste \r\n" + track + "\r\n" + track.Location;
            //        log.log(txt);

            //        throw new ApplicationException(txt);
            //    }
            //}
            //else
            if (!dictTrackInList.ContainsKey(key))
                dictTrackInList[key] = track;
            // dictTrackInList[getKey(pl, track.Location)] = track;
        }

        public void removeTrackInList(string pl, TrackInList track, IITUserPlaylist plt)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, track.Location, plt);

            dictTrackList.Remove(track.TrackDataBaseId);
            //  locationTrack.remove(track.Location);

        }

        public void removeTrackInList(string pl, string location, int TrackDataBaseId, IITUserPlaylist plt)
        {

            string key = getKey(pl, location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, location, plt);

            dictTrackList.Remove(TrackDataBaseId);
            //  locationTrack.remove(track.Location);
        }

        public void removeTrack(TrackInfoItunes track)
        {
            persist.removeTrack(track.Location);
        }
        /// <summary>
        /// Utilisé pour vérifier avant l'ajout que le track existe
        /// </summary>
        /// <param name="pl"></param>
        /// <param name="track"></param>
        /// <returns></returns>
        public bool LogicalContainsTrackInList(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInList.ContainsKey(key);
        }

        public bool LogicalTrackInListDeleted(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInListDeleted.ContainsKey(key);
        }


        public void LogicalRecordTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInListDeleted.Remove(key);
            logicalDictTrackInList.Add(key, track);
        }

        public void LogicalRemoveTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInList.Remove(key);
            logicalDictTrackInListDeleted.Add(key, track);
        }



        #endregion






        private bool modeXml = true;
        private bool deleteFile;
        private bool errorAccess;
        private bool singleThread;

        //public static Loader Instance
        //{
        //    get
        //    {
        //        if (_instance == null)
        //            _instance = new Loader();
        //        return _instance;
        //    }
        //}


        private Conf conf = new Conf();

        public Conf Conf
        {
            set
            {
                conf = value;
                if (detector != null)
                    detector.Conf = value.Detect;

                PlayList.Conf = conf;
                if (player != null)
                    player.Conf = value;
                TrackWrapper.SingleThread = conf.SingleThread;
                ItUtil.SingleThread = conf.SingleThread;
                singleThread = conf.SingleThread;
                checkSong = conf.checkSong;

            }
        }

        public void setConf(XmlElement xelt)
        {
            Conf = new Conf(xelt);
        }

        public bool ModeXml { set { modeXml = value; } }
        private Loader(bool deleteFile, bool writeOnlyEnabled, bool writeOnlyUnRead)
        {
            this.deleteFile = deleteFile;
            this.writeOnlyEnabled = writeOnlyEnabled;
            this.writeOnlyUnRead = writeOnlyUnRead;

        }



        #region events
        private string currentReading = "";
        void app_OnPlayerPlayingTrackChangedEvent(object iTrack)
        {

            log.log("app_OnPlayerPlayingTrackChangedEvent:" + iTrack);
            checkChangeSong();
        }

        void app_OnPlayerPlayEvent(object iTrack)
        {
            try
            {
                log.log("app_OnPlayerPlayEvent:" + iTrack);
                checkChangeSong();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

        }

        private string currentSong;
        private DateTime currentSongDt;
        private void getCurrentSong()
        {
            if (!checkSong)
                throw new ArgumentException("checkSong!");
            getCurrentTrack();
            getCurrentPlayList();
            currentSongDt = DateTime.Now;


            try
            {

                if (_currentTrack != null)
                {
                    getPlayerState();

                    //BackGroundTaskMgr.Playing = _playerState != ITPlayerState.ITPlayerStateStopped;
                    currentSong = _currentTrack.Location + " " + _playerState.ToString();
                }
            }
            catch { }
            getCurrentPlayList();
        }
        private string CurrentSong
        {
            get
            {
                if (!checkSong)
                    return "";
                if ((DateTime.Now - currentSongDt).TotalMinutes > 1)
                {
                    getCurrentSong();
                }

                return currentSong;
            }
        }

        private PlayListComposite _currentPlayList;
        private DateTime _currentPlayListTempo;
        private void getCurrentPlayList()
        {
            if (!checkSong)
                throw new ArgumentException();
            _currentPlayListTempo = DateTime.Now;
            try
            {
                enter();
                var _cur = app.CurrentPlaylist;
                if (_cur == null)
                    _currentPlayList = null;
                else
                    _currentPlayList = m_htPlayLists[_cur.playlistID];
            }
            finally
            {
                release();
            }
        }
        private IITFileOrCDTrack _currentTrack;
        private void getCurrentTrack()
        {
            if (!checkSong)
                throw new ArgumentException();
            currentTrackTempo = DateTime.Now;
            try
            {
                enter();
                _currentTrack = TrackWrapper.create(app.CurrentTrack);
                _currentTrackLocation = "";
                if (_currentTrack != null)
                    _currentTrackLocation = _currentTrack.Location;
            }
            finally
            {
                release();
            }
        }
        public PlayListComposite CurrentPlaylist
        {
            get
            {
                return null;
                //if ((DateTime.Now - _currentPlayListTempo).TotalMinutes > 1)
                //{
                //    getCurrentPlayList();
                //}
                //return _currentPlayList;
            }
        }
        private DateTime currentTrackTempo;
        public IITFileOrCDTrack CurrentTrack
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrack;
            }

        }
        private string _currentTrackLocation;
        public string CurrentTrackLocation
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrackLocation;

            }
        }

        private ITPlayerState _playerState;
        private void getPlayerState()
        {
            currentStateTempo = DateTime.Now;
            try
            {
                enter();
                _playerState = app.PlayerState;
            }
            finally
            {
                release();
            }
        }
        private DateTime currentStateTempo;
        public ITPlayerState PlayerState
        {
            get
            {
                if (!checkSong)
                    return ITPlayerState.ITPlayerStateStopped;
                if ((DateTime.Now - currentStateTempo).TotalMinutes > 1)
                    getPlayerState();
                return _playerState;
            }
        }


        private void checkChangeSong()
        {
            if (!checkSong)
                return;
            getCurrentSong();

            var track = CurrentTrackLocation;
            if (!track.Equals(currentReading))
            {
                currentReading = track;
                PlayComputedTrack();
            }

        }
        #endregion



        private bool useDetect;
        public Loader(Conf conf, bool useDetect,  bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf.DeleteFile, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.Conf = conf;
            this.m_defaultFolder = conf.DefaultFolder;
            if (!m_defaultFolder.EndsWith(@"\"))
                m_defaultFolder += @"\";
            this.useDetect = useDetect;

            this.player = new AutoPlayer(this, conf);

        }

        public Loader(Conf conf, Action abortList, bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf, true, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.abortList = abortList;
        }

        public void saveIds()
        {
            if (persist != null)
                persist.record();
        }

        private bool initialized;

        public void init()
        {
            if (initialized)
                return;
            initialized = true;
            app = new iTunesApp();

            mainLibrairy = app.LibrarySource;
            mainPlayLists = mainLibrairy.Playlists;

            TrackInfoItunes.Loader = this;
            PlayList.Loader = this;
            //BackGroundTaskMgr.Async = true;
            //BackGroundTaskMgr.start(); 
            trackBuilder = this;
            m_htLegacyPLayList = new PlayListRegister(this.app);
            m_htLegacyPLayList.load("init");

            app.OnPlayerPlayEvent += new _IiTunesEvents_OnPlayerPlayEventEventHandler(app_OnPlayerPlayEvent);
            app.OnPlayerPlayingTrackChangedEvent += new _IiTunesEvents_OnPlayerPlayingTrackChangedEventEventHandler(app_OnPlayerPlayingTrackChangedEvent);


            detector = new Detector(app.LibraryXMLPath, logDetect, conf.Detect);
            if (useDetect)
                detector.start();


            string file = app.LibraryXMLPath;
            // bool exists = File.Exists(file);
            //while (!File.Exists(file))
            //    Thread.Sleep(30);
            m_defaultFolder = getDefaultFolder();
            log.log(m_defaultFolder);

            log.log("suppression:{0} erreur accès:{1}", deleteFile, errorAccess);

            FileInfo fTrack = new FileInfo(_dBLegacyDir + conf.DbTrack);
            DirectoryInfo dir = fTrack.Directory;
            if (!dir.Exists) dir.Create();
            // persistTracks = new TrackDb(app, f.FullName);

            var fTrackList = new FileInfo(_dBLegacyDir + conf.DbTrackList);
            dir = fTrackList.Directory;
            if (!dir.Exists) dir.Create();
            //memoTrackList = new TrackDb(app, f.FullName);

            persist = new TracksDb(app, fTrack.FullName, fTrackList.FullName, conf.ProxyTrack, conf.ProxyTrackList, conf.PersistIt, conf.SingleThread);








            //if (deleteFile)
            //{

            //    //  log.log("suppression de " + file);
            //    while (true)
            //    {
            //        try
            //        {
            //            //if (!errorAccess)
            //            log.log("suppression de " + file);
            //            File.Delete(app.LibraryXMLPath);
            //            break;
            //        }
            //        catch (Exception e)
            //        {
            //            // log.log("error acces " + file);
            //            errorAccess = true;
            //            Thread.Sleep(1000);
            //        }
            //    }
            //}



            //if (deleteFile && errorAccess)
            //    log.log("finalement pas suppression de " + file + " car erreur accès");


        }

        private void enter()
        {
            if (singleThread)
            {
                BgTask.chrono.bip("l:ent0");
                Locker.Enter();
                BgTask.chrono.bip("l:ent1");
            }
        }
        private void release()
        {
            if (singleThread)
                Locker.Release();
        }

        # region detect
        //  private bool waitForNextSong;


        // public bool WaitForNextSong { get { return waitForNextSong; } set { waitForNextSong = value; } }



        private DateTime lastLoad;
        //private DateTime confirmLoad = DateTime.MaxValue;
        private string currentSongWhenLoaded = "";
        private Detector detector;

        public void logDetect(string info)
        {
            log.logNoDate("------------------------------------------------------------------------------------");
            log.log(info);
            log.logNoDate("------------------------------------------------------------------------------------");
        }

        public bool detectModif() { return !detector.canLoad(); }

        public void checkDetect(DateTime ini)
        {
            detector.check(ini);
        }

        public void exception()
        {
            currentSongWhenLoaded = "-";
        }
        public void reset(bool firstStep, bool forceLoad)
        {
            string _current = CurrentSong;
            log.log("reset ::firstStep {0} forceLoad {1} currentSongWhenLoaded :{2} currentSong:{3}", firstStep, forceLoad, currentSongWhenLoaded, _current);

            if (!forceLoad)
                detector.reset();
            //  DateTime lastLoad = DateTime.Now;
            // string currentSongWhenLoaded = "";

            //if (waitForNextSong)
            //    currentSongWhenLoaded = CurrentSong;


            //if (!deleteFile && firstStep)
            //    lastLoad = DateTime.MinValue;
            bool canread = false;

            FileInfo fLibrary = new FileInfo(app.LibraryXMLPath);
            bool condition = false;

            while (!canread)
            {

                try
                {
                    Thread.Sleep(1000);
                    _current = CurrentSong;
                    fLibrary.Refresh();
                    if (fLibrary.Exists)
                    {
                        //DateTime dt = fLibrary.LastWriteTime;
                        ////if (lastLoad == DateTime.MinValue)
                        ////{
                        ////    lastLoad = dt;
                        ////    confirmLoad = dt.AddSeconds(conf.Confirm);
                        ////    condition = true;
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////    log.log("temps chargement:{0} confirm :{1}", lastLoad, confirmLoad);
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////}
                        DateTime now = DateTime.Now;
                        TimeSpan _delta = now - lastLoad;


                        if (condition)
                        {
                            bool load = true;
                            if (!forceLoad)
                                load = detector.canLoad();
                            //if (now > confirmLoad)
                            //{
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("temps de confirmation dépassé {0}", confirmLoad);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    load = true;
                            //}
                            //else if (dt > lastLoad)
                            //{
                            //    nbTick++;
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("library modifiée {0} {1}", dt, nbTick);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    lastLoad = dt;

                            //    if (nbTick <= conf.TickRefresh)
                            //    {
                            //        int delta = conf.ConfirmTick; // (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                            //        DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;
                            //        var _confirmLoad = dt0.AddSeconds(delta);
                            //        var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                            //        if (_confirmLoad2 > _confirmLoad)
                            //            _confirmLoad = _confirmLoad2; 
                            //        if (_confirmLoad > confirmLoad)
                            //            confirmLoad = _confirmLoad;
                            //        log.log("confirm {0}", confirmLoad);
                            //    }

                            //}

                            if (load)
                            {
                                DateTime ini = DateTime.Now;
                                try
                                {

                                    log.logNoDate("***********************************************************************");
                                    log.log("chargement library {0} {1}", _current, _delta);
                                    log.logNoDate("***********************************************************************");
                                    DateTime __tick = DateTime.Now;
                                    XmlDocument doc = new XmlDocument();
                                    doc.XmlResolver = null;
                                    contentXml = null;

                                    gcCollect();
                                    string itXml = app.LibraryXMLPath;
                                    doc.Load(itXml);



                                    var root = doc.DocumentElement;
                                    contentXml = root.ChildNodes[0] as XmlElement;

                                    doc = null;
                                    root = null;
                                    gcCollect();
                                    if (!forceLoad)
                                    {

                                        if (conf.Detect.CancelLoad && !detector.canLoad())
                                        {
                                            log.log("Abort car modif fichiers");
                                            continue;
                                        }
                                        checkDetect(ini);
                                        detector.signalLoad();
                                        canread = true;
                                        lastLoad = DateTime.Now;
                                        condition = false;
                                    }

                                    //   confirmLoad = DateTime.MaxValue;
                                    currentSongWhenLoaded = _current;
                                    log.logNoDate("***********************************************************************");
                                    log.log("fin chargement library {0} ", (DateTime.Now - __tick));
                                    log.logNoDate("***********************************************************************");


                                    return;
                                }
                                catch (Exception ex)
                                {

                                    log.log(ex.ToString());
                                    Thread.Sleep(1000);
                                    //nbTick++;
                                    //dt = fLibrary.LastWriteTime;

                                    //int delta = (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                                    //DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;

                                    //var _confirmLoad = dt0.AddSeconds(delta);
                                    //if (_confirmLoad > confirmLoad)
                                    //    confirmLoad = _confirmLoad;
                                    //var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                                    //if (_confirmLoad2 > _confirmLoad)
                                    //    _confirmLoad = _confirmLoad2; 
                                    //log.log("confirm {0}", confirmLoad);
                                }
                            }
                            else
                            {
                                misc.Pre = "[Load " + detector.Limit.ToLongTimeString() + "] ";
                                continue;
                            }
                        }



                        //  log.log("library modifiée {0}", dt);

                        bool conditionWait = false;
                        bool conditionNoWait = false;


                        if (conf.WaitForNextSong)
                        {
                            conditionWait = _current != currentSongWhenLoaded;
                        }
                        else
                        {
                            conditionNoWait = _delta > conf.Refresh;
                        }




                        if (firstStep || forceLoad || conditionWait || conditionNoWait || _delta > conf.RefreshMax)
                        {

                            condition = true;
                            if (!forceLoad)
                                detector.reset();
                            checkChangeSong();
                            if (abortList != null)
                                abortList();
                            // lastLoad = dt;

                            //if (firstStep)
                            //    confirmLoad = dt.AddSeconds(conf.Confirm);
                            //else
                            //{
                            //    log.log("library modifiée {0} attente modif {1}", dt, (nbTick + 1));
                            //    // if (nbTick <= 1)
                            //    confirmLoad = now.AddSeconds(conf.Confirm);
                            //    log.log("confirm {0}", confirmLoad);


                            //}

                        }
                        //}
                    }


                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                if (!canread)
                {
                    Thread.Sleep(100);
                    if (!condition)
                    {
                        if (conf.WaitForNextSong)
                            Thread.Sleep(conf.Delay);
                    }
                }

            }


        }

        #endregion

        #region Infos

        //public CPiece getPiece(IITTrack track)
        //{
        //    return m_htPieces[track.TrackDatabaseID];
        //}


        //public IITFileOrCDTrack getPieceInList(PieceInAList trackList)
        //{
        //    return m_htPiecesInAList[trackList.ID];
        //}

        //public void deleteTrackInList(PieceInAList trackList)
        //{
        //    TrackInList track = m_htPiecesInAList[trackList.ID];
        //    track.Delete();
        //    //   track.Track.Delete();
        //    m_htPiecesInAList.Remove(trackList.ID);
        //}

        private String getDefaultFolder()
        {
            string path = app.LibraryXMLPath;

            _dBLegacyDir = Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
            _dBLegacyPath = _dBLegacyDir + "iTunes Library.itl";

            String uri = "";

            String token = "<key>Music Folder</key><string>";
            //<key>Music Folder</key><string>file://localhost/F:/bernard/zique/</string>
            log.log("load {0}", path);

            while (true)
            {
                try
                {
                    foreach (String line in File.ReadAllLines(path))
                    {
                        if (line.Contains(token))
                        {
                            Regex regex = new Regex("<string>(.+)</string>");
                            Match m = regex.Match(line);
                            if (!m.Success) return "";
                            uri = m.Groups[1].Value;
                            return new Uri(uri).LocalPath.Replace("\\\\localhost\\", "");
                        }
                    }
                }
                catch
                {
                    errorAccess = true;
                    Thread.Sleep(30);
                }
            }
        }
        public String DefaultFolder
        {
            get
            {
                return m_defaultFolder;
            }
        }
        #endregion



        //public void replace(TrackInfoItunes native, TrackInfoItunes local)
        //{
        //    local.ID = native.ID;
        //    if (m_htPieces.ContainsKey(native.ID))
        //    {
        //        m_htPieces.Remove(native.ID);
        //    }
        //    native.synchroLegacy(local);
        //    m_htPieces[native.ID] = local;
        //}

        #region chargement



        public TrackInfoItunes getInfo(int trackDataBaseId)
        {
            return m_htPieces[trackDataBaseId];
        }

        public void loadTracks(List<ITrackInfoItunes> list)
        {
            lock (this)
            {
                erreurTrackList = false;
                this.list = list;

                //   m_htPieces = new Dictionary<int, TrackInfoItunes>();
                m_htTracks = new BgDict<int, IITFileOrCDTrack>();
                // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();
                // m_htPiecesInAList = new Dictionary<int, TrackInList>();
                m_htPlayLists = new BgDict<int, PlayListComposite>();
                persistentIDs = new BgDictString<PlayList>();
                // m_htLegacyPLayList.load("loadTracks"); //  = new Dictionary<int, IITUserPlaylist>();


                /// <summary>
                /// dictionnaire asynchrone
                /// </summary>
                //dictTracks = new BgDict<int, IITFileOrCDTrack>();
                //locationTrack = new BgDict<string, IITFileOrCDTrack>();
                //dictTrackList = new BgDict<int, IITFileOrCDTrack>();
                dictTrackInList = new BgDictString<TrackInList>();

                log.log("DEBUT loadTracks");
                if (!modeXml)
                {
                    loadTracksNative();
                    return;
                }


                //XmlDocument test = new XmlDocument();
                //test.Load(@"C:\Users\bd\Music\iTunes\test.xml");
                //var trackTest = new TrackInfoItunes(test.DocumentElement); 
                //  list = new List<TrackInfoItunes>();

                //recherche du noeud contenant les données Track
                XmlNode xtracks = null;
                for (int i = 0; i < contentXml.ChildNodes.Count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Tracks")
                    {
                        xtracks = contentXml.ChildNodes[i + 1];
                        break;
                    }
                }

                //   int nb = 0;
                int count = xtracks.ChildNodes.Count;
                bool impair = false;
                foreach (XmlNode xTrack in xtracks.ChildNodes)

                // for (int i = 0; i < count; i += 2)
                {
                    impair = !impair;
                    if (impair)
                        continue;

                    //  var xTrack = xtracks.ChildNodes[i + 1];
                    //int ID = TrackInfoItunes.getID(xTrack);
                    string loc = TrackInfoItunes.getLocation(xTrack);
                    //TrackInfoItunes track = trackBuilder.create(xTrack);


                    TrackInfoItunes track = null;
                    if (m_htLoc.ContainsKey(loc))
                    {
                        track = m_htLoc[loc];
                        track.build(xTrack);

                    }
                    //  log.log("add track {0}", track);

                    else
                    {
                        track = create(loc);
                        track.build(xTrack);
                        if (track.Strange)
                            continue;



                        m_htPieces.Add(track.ID, track);
                        m_htLoc.Add(loc, track);
                    }

                    string location = track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        log.log("phase load :: suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    else if (!FileRegister.ExistNow(location)) // conf.CheckFileExist && !File.Exists(location))
                    {
                        log.log("phase load :: suppression du track absent " + track.Album + "/" + track.Name + " " + location);
                        track.Delete();
                        continue;
                    }




                    list.Add(track);
                    //  track.Index = nb;
                    //   nb++;

#if VERIF
                track.verif();
#endif
                }
                log.log("FIN loadTracks");
            }

        }

        //private void buildIndexesTracks()
        //{
        //    int count = list.Count;
        //    for (int i = 0; i < count; i++)
        //    {
        //        list[i].Index = i;
        //    }
        //}

        private void bgLoadTracksNative()
        {

            try
            {



                IITTrackCollection tracks = null;
                int count = 0;
                IEnumerator enumerator = null;
                try
                {
                    enter(); tracks = app.LibraryPlaylist.Tracks;
                    count = tracks.Count;
                    enumerator = tracks.GetEnumerator();
                }
                finally { release(); }

                int i = 0;
                while (true)
                //int count  = tracks.Count; 
                //for (int i= 1; i<=count; i++)
                {
                    while (BackGroundTaskMgr.PauseKeyBoard)
                        Thread.Sleep(100);
                    bool _cont = false;

                    try
                    { enter(); _cont = enumerator.MoveNext(); }
                    finally { release(); }
                    if (!_cont)
                        break;
                    i++;

                    try
                    {
                        IITFileOrCDTrack track = null;
                        try
                        {
                            enter();
                            //   var t = tracks[i];
                            track = TrackWrapper.create(enumerator.Current as IITFileOrCDTrack);
                        }
                        finally
                        {
                            release();
                        }
                        if (track == null)
                            continue;

                        //if (t.Kind == ITTrackKind.ITTrackKindFile)
                        //{
                        //lock (this)
                        //{
                        // IITFileOrCDTrack track = t as IITFileOrCDTrack;
                        int l_id = 0;
                        string location = "";
                        try
                        {
                            enter();
                            l_id = track.TrackDatabaseID;
                        }
                        finally
                        {
                            release();
                        }
                        try
                        {
                            enter();
                            location = track.Location;
                        }
                        finally
                        {
                            release();
                        }
                        if (i % 1000 == 0)
                            log.log("scan {0}/{1} id:{2} {3}", i, count, l_id, location);


                        if (location == null)
                        {
                            log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                            try
                            {
                                enter(); track.Delete();
                            }
                            finally
                            {
                                release();
                            }
                            continue;
                        }
                        else
                        {

                            //  log.log("bg Add track " + location);
                            dictTracks[l_id] = track;
                            dictTrackList[l_id] = track;
                            this.persist.recordTrack(location, track);


                        }

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                }
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!!!!!!!!!!!!!!!>>>>>>!!!!!!!!!!!!!!!!!!>>>>FIN bgLoadTracksNative ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
            }
            finally
            {
                lock (this)
                    scanLoaded = false;

                //list = new CListPieceWithoutPodcast(m_htPieces.Values);
            }
        }

        public void loadTracksNative()
        {

            IITTrackCollection tracks = app.LibraryPlaylist.Tracks;

            foreach (IITTrack t in tracks)
            {
                if (t.Kind == ITTrackKind.ITTrackKindFile)
                {
                    IITFileOrCDTrack track = TrackWrapper.create(t);
                    string location = "";
                    try
                    {
                        location = track.Location;
                    }
                    catch
                    {
                    }
                    log.log("add track " + location);

                    if (location.isNullorEmpty())
                    {
                        log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    if (false == FileRegister.Exist(location)) //  File.Exists(location))
                    {
                        log.log("Suppression du track absent " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }



                    //if (persist.containsTrack(location))
                    //{
                    //    log.log("suppression du track doublon " + track.Album + "/" + track.Name + " " + track.Location);
                    ////    track.Delete();
                    //    continue;
                    //}

                    persist.recordTrack(location, track);
                    //              String l_strFile = track.Location.Replace(m_defaultFolder, "");
                    int l_id = track.TrackDatabaseID;

                    //string l_Artist = track.Artist.TrimSafe();
                    //string l_Album = track.Album.TrimSafe();
                    //string l_Name = track.Name.TrimSafe();
                    //int l_trackNumber = -1;
                    //if (track.TrackNumber > 100) track.TrackNumber = 0;
                    //if (track.TrackNumber > 0)
                    //{
                    //    l_trackNumber = track.TrackNumber;
                    //}

                    //CPieceReference l_details = new CPieceReference(l_Artist, l_Album, l_Name, l_trackNumber);

                    //int l_year = -1; if (track.Year > 0) l_year = track.Year;
                    //CPieceInfo l_infos = new CPieceInfo(l_year);

                    //int l_rating = 0; if (track.Rating > 0) l_rating = track.Rating;


                    //DateTime l_date = DateTime.MinValue; if (track.PlayedDate > DateTime.MinValue) l_date = track.PlayedDate;

                    //int l_duration = track.Duration;
                    //bool l_enabled = track.Enabled;


                    //CPiece l_piece = new CPiece(l_details, l_strFile, l_infos, l_rating, l_date, l_duration, l_enabled);
                    TrackInfoItunes l_piece = create(location);
                    l_piece.build(track);
                    //new TrackInfoItunes(track);
                    l_piece.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                    m_htTracks[l_id] = track;
                    m_htPieces[l_id] = l_piece;
                    //l_piece.ID = l_id;
                    //   buildArt(track); 
                    list.Add(l_piece);
                    //  log.log("add track {0}", l_piece);

                }
            }

            log.log("FIN LoadTracksNative ");
            //list = new CListPieceWithoutPodcast(m_htPieces.Values);
        }

        ///// <summary>
        ///// Récupération d'un track  Itunes en fonction de son index
        ///// </summary>
        ///// <param name="id"></param>
        ///// <returns></returns>
        //public IITFileOrCDTrack getTrack(string location)
        //{
        //    if (m_htFileTracks.ContainsKey(location))
        //        return m_htFileTracks[location];

        //    foreach (IITTrack t in app.LibraryPlaylist.Tracks)
        //    {
        //        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //        {
        //            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //            string _loc = track.Location;
        //            if (!m_htFileTracks.ContainsKey(_loc))
        //            {
        //                m_htFileTracks.Add(_loc, track);
        //                if (location.Equals(_loc))
        //                    return track;
        //            }
        //        }
        //    }

        //    return null;



        //}
        /// <summary>
        /// Récupération d'un track en vue de le supprimmer
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public TrackId getTrackTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;

            _track = dictTracks[ID].check(trackInfoItunes.Location);
            TrackPersistantId _id = null;
            TrackId trackId = persist.getTrackTrack(trackInfoItunes.Location);

            if (trackId != null)
            {
                _id = trackId.Id;
                _track = trackId.Track.check(trackInfoItunes.Location);
            }
            #region complique
            if (conf.ComplexSearch)
            {
                if (_track == null)
                {
                    try
                    {
                        enter();
                        int index = list.IndexOf(trackInfoItunes);
                        if (index >= 0)
                            _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);


                        if (_track == null)
                        {
                            loadScan("recherche TrackTrack " + trackInfoItunes.Location);
                            return null;
                        }

                        string attendu = trackInfoItunes.Location;
                        string mesure = _track.Location;
                        persist.recordTrack(mesure, _track); // [mesure] = _track;
                        dictTracks[_track.TrackDatabaseID] = _track;

                        if (attendu.Equals(mesure))
                        {
                            //    log.log("-->bg Add track via getTrack: " + _track.Location);
                            // dictTracks[ID] = _track;
                        }
                        else
                        {

                            //   log.log("-->bg Add BAD track via getTrack attendu :{0}, mesuré {1}", attendu, mesure);
                            loadScan("TrackTrack attendu " + attendu + " <> mesuré " + mesure);
                            return null;
                        }
                    }
                    finally { release(); }
                }
            }
            #endregion
            if (_track == null)
                loadScan("?");

            return new TrackId(_id, _track);
        }



        /// <summary>
        /// Récupération d'un track en vue de le modifier
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public IITFileOrCDTrack getTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;
            //  TrackPersistantId _id = null;
            int IDFound = -1;
            try
            {

                _track = dictTracks[ID];

                if (_track == null)
                {
                    var _t = persist.getTrack(trackInfoItunes.Location);
                    if (_t != null && _t.Track != null)
                    {
                        _track = _t.Track;
                        //_id = _t.Id;
                    }
                }
                BgTask.chrono.bip("getT");
                #region complique
                if (conf.ComplexSearch)
                {
                    if (_track == null)
                    {
                        try
                        {
                            enter();
                            //loadScan("recherche track " + trackInfoItunes);
                            int index = list.IndexOf(trackInfoItunes);
                            if (index >= 0)
                                _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);

                            if (_track != null)
                            {
                                IDFound = _track.TrackDatabaseID;
                                dictTracks[IDFound] = _track;
                                dictTrackList[IDFound] = _track;
                                persist.recordTrack(_track); // [_track.Location] = _track;


                                if (IDFound == ID)
                                { //    log.log("getTrack by ID: " + trackInfoItunes.Location);
                                }
                                else if (_track.Location == trackInfoItunes.Location)
                                    log.log("getTrack by location: " + trackInfoItunes.Location);
                                else
                                {
                                    _track = null;
                                }
                            }
                        }
                        finally { release(); }

                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 2 " + trackInfoItunes);
                        _track = dictTrackList[ID];
                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 4 " + trackInfoItunes);
                        _track = null;
                    }
                }

                #endregion



            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
                loadScan("recherche track Exception " + trackInfoItunes);
            }

            #region complique
            if (conf.ComplexSearch)
            {
                if (_track != null)
                {
                    IDFound = _track.TrackDatabaseID;
                    dictTracks[IDFound] = _track;
                    dictTrackList[IDFound] = _track;
                    persist.recordTrack(_track);
                }
            }
            #endregion

            // return new TrackId(_id, _track);
            return _track;
        }

        void Track_classNameChanged(object sender, TrackInfoItunes.TrackClassNameEventArgs e)
        {
            TrackInfoItunes track = sender as TrackInfoItunes;
            updateClassList(track);
        }

        private void updateClassList(TrackInfoItunes piece)
        {

            List<CPlayList> copy = new List<CPlayList>();
            foreach (CPlayList list in piece.ClassPlayLists)
            {
                PieceInAList pieceInList = list.getPieceInList(piece);
                if (pieceInList != null)
                {

                    // deleteTrackInList(pieceInList);
                    pieceInList.Delete();
                    //    list.remove(pieceInList);
                    copy.Add(list); //  piece.removePlayList(list);
                }
            }

            String plName = piece.ClassName;
            setClassPlayList(piece, plName);

            foreach (CPlayList list in copy)
            {
                piece.removePlayList(list);
            }


        }

        public IEnumerable<ITrackInfoItunes> ListAllTracks { get { return list; } }
        public IEnumerable<ITrackInfoItunes> ListTracks { get { return list.FindAll(t => !t.isPodcast); } }
        public IEnumerable<ITrackInfoItunes> ListPodCast { get { return list.FindAll(t => t.isPodcast); } }
        public void loadListsNative()
        {
            IITSourceCollection sources = app.Sources;

            for (int i = 1; i <= sources.Count; i++)
            {
                loadPlayListsNative(sources[i]);
            }
            //   Console.WriteLine(root.ToString());
        }

        private bool scanLoaded;
        public void loadScan(string raison)
        {
            if (scanLoaded)
                return;

            lock (this)
            {
                if (scanLoaded)
                    return;
                scanLoaded = true;

                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!>>>>DEBUT bgLoadTracksNative ( " + raison + " ) ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");


                var loopbgLoadTracksNative = new ThreadUtil(bgLoadTracksNative, "BgT");
                // loopbgLoadTracksNative.Name = "BgT";
                loopbgLoadTracksNative.Start();
            }
        }
        public void loadLists()
        {
            lock (this)
            {
                log.log("Début load list");
                DateTime begin = DateTime.Now;
                // persistentIDs = new Dictionary<string, PlayList>();
                if (listLoaded)
                {
                    foreach (PlayList logical in logicals)
                    {
                        logical.DeleteBase();
                    }
                }
                root.DeleteChilds(); // = new PlayList("root", null);
                gcCollect();
                if (!modeXml)
                {
                    loadListsNative();
                    return;
                }
                // IITSourceCollection sources = app.Sources;


                //for (int i = 1; i <= sources.Count; i++)
                //{
                //    IITSource source = sources[i];
                //    var playlists = source.Playlists;

                //    foreach (IITPlaylist pl in playlists)
                //    {
                //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                //        {
                //            var upl = pl as IITUserPlaylist;
                //            recordlegacyPlayList(upl);
                //        }
                //        checkDetect(begin);
                //    }
                //}


                //if (bParsingNativeAsync)
                //{
                //    Thread loopbgLoadTracksNative = new Thread(bgLoadTracksNative);
                //    loopbgLoadTracksNative.Name = "BgT";
                //    loopbgLoadTracksNative.Start();
                //}



                XmlNode xPlaylists = null;
                int count = contentXml.ChildNodes.Count;
                for (int i = 0; i < count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Playlists")
                    {
                        xPlaylists = contentXml.ChildNodes[i + 1];
                        break;
                    }
                    continue;
                }


                foreach (XmlNode xDist in xPlaylists.ChildNodes)
                {
                    string KEY = "key";
                    int ID = -1;
                    string persistentID = null;
                    string parentPersistentID = null;
                    bool forgetIt = false;
                    bool folder = false;
                    string name = null;
                    XmlNode contentList = null;
                    int count2 = xDist.ChildNodes.Count;
                    for (int i = 0; i < count2; i += 2)
                    {
                        XmlNode meta = xDist.ChildNodes[i];
                        string value = xDist.ChildNodes[i + 1].InnerText;
                        if (meta.Name == KEY)
                        {
                            switch (meta.InnerText)
                            {
                                case "Master": forgetIt = true; break;
                                case "Distinguished Kind": forgetIt = true; break;
                                case "Name": name = value; break;
                                case "Playlist ID": ID = Convert.ToInt32(value); break;
                                case "Playlist Persistent ID": persistentID = value; break;
                                case "Folder": folder = true; break;
                                case "Parent Persistent ID": parentPersistentID = value; break;
                                case "Playlist Items": contentList = xDist.ChildNodes[i + 1]; break;

                            }

                        }
                    }

                    if (forgetIt)
                        continue;
                    PlayList parent = null;


                    if (parentPersistentID == null)
                        parent = root;
                    else parent = persistentIDs[parentPersistentID];

                    IITUserPlaylist upl = null;
                    try
                    {
                        upl = m_htLegacyPLayList.getItPl(ID, name);
                    }
                    catch
                    {
                        log.log("impossible de charger la liste " + ID + " " + name);
                        throw;
                    }
                    PlayList current = addChildPlayList2(upl, parent, name, ID, persistentID);
                    log.log("add pl {0}", current);

                    if (folder)
                        continue;
                    if (contentList == null)
                        continue;
                    bool _blogic = false;
                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (current.isSubList(logical))
                            {
                                _blogic = true;
                                break;
                            }
                        }
                        if (_blogic)
                            continue;
                    }


                    bool go = filterPlaylist.consider(current);
                    if (!go) continue;

                    ////    if (current.isSubList("gen")) continue;
                    //    if (current.isSubList("auto")) continue;
                    //    if (current.isSubList("d")) continue;
                    //    if (current.isSubList("c")) continue;




                    int countList = contentList.ChildNodes.Count;
                    int ii = 0;
                    foreach (XmlNode xdictTrack in contentList.ChildNodes)
                    {
                        int id = Convert.ToInt32(xdictTrack.ChildNodes[1].InnerText);

                        TrackInfoItunes piece = m_htPieces[id];
                        if (piece == null)
                            continue;

                        TrackInList plPiece = new TrackInList(current, piece, id);
                        plPiece.ID = ID * 1000 * 1000 + ii;
                        current.add(plPiece);
                        //current.addPiece(piece);
                        ii++;
                        afterCreate(current, piece, id);
                    }



                    //   current.scanTracks();



#if VERIF
                current.verif();
#endif
                    log.log("{0} elts", current.ChildsCount);
                }

                if (listLoaded)
                    reintegrateLogical();



                contentXml = null;
                gcCollect();

                checkDetect(begin);
                listLoaded = true;
                log.log("Fin de load Lists");
            }






        }

        private void reintegrateLogical()
        {
            foreach (PlayList pl in logicals)
                pl.reintegrate();
        }

        protected virtual void afterCreate(PlayList playlist, TrackInfoItunes track, int id)
        {
        }

        //private void loadPlayLists(IITSource source)
        //{
        //    log.log("Loader:loadPlayLists source");
        //    IITPlaylist pl;
        //    IITUserPlaylist upl;

        //    for (int index = 1; index <= source.Playlists.Count; index++)
        //    {
        //        pl = source.Playlists[index];
        //        log.log("Loader:loadPlayLists check {0}", pl.Name);
        //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
        //        {
        //            upl = pl as IITUserPlaylist;
        //            recordlegacyPlayList(upl);


        //            if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
        //                upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
        //            {

        //                PlayListComposite parent = null;
        //                IITUserPlaylist iparent = upl.get_Parent();
        //                if (iparent != null)
        //                {
        //                    parent = m_htPlayLists[iparent.playlistID];
        //                }
        //                else
        //                {
        //                    parent = root;
        //                }


        //                CPlayList current = addChildPlayList(parent, upl);

        //                if (current.isSubList("gen")) continue;
        //                if (current.isSubList("auto")) continue;
        //                if (current.isSubList("d")) continue;
        //                if (current.isSubList("c")) continue;

        //                log.log("add pl {0}", current);




        //                //current.ID = upl.playlistID;
        //                //m_htPlayLists.Add(upl.playlistID, current);

        //                //parent.add(current);


        //                if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
        //                {
        //                    foreach (IITTrack t in upl.Tracks)
        //                    {
        //                        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //                        {
        //                            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //                            if (!track.Podcast)
        //                            {
        //                                TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
        //                                TrackInList plPiece = new TrackInList(piece, track);
        //                                plPiece.ID = track.trackID;
        //                                m_htPiecesInAList.Add(plPiece.ID, plPiece);
        //                                current.add(plPiece);
        //                                current.addPiece(piece);
        //                            }
        //                        }
        //                    }
        //                    log.log("{0} elts", current.ChildsCount);
        //                }


        //            }

        //        }
        //    }

        //}

        private void loadPlayListsNative(IITSource source)
        {
            log.log("Loader:loadPlayLists source");
            IITPlaylist pl;
            IITUserPlaylist upl;

            for (int index = 1; index <= source.Playlists.Count; index++)
            {
                pl = source.Playlists[index];
                log.log("Loader:loadPlayLists check {0}", pl.Name);
                if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                {
                    upl = pl as IITUserPlaylist;
                    recordlegacyPlayList(upl);


                    if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
                        upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    {

                        PlayListComposite parent = null;
                        IITUserPlaylist iparent = upl.get_Parent();
                        if (iparent != null)
                        {
                            parent = m_htPlayLists[iparent.playlistID];
                        }
                        else
                        {
                            parent = root;
                        }


                        CPlayList current = addChildPlayList(parent, upl);

                        // if (current.isSubList("gen")) continue;
                        if (current.isSubList("auto")) continue;
                        if (current.isSubList("d")) continue;
                        if (current.isSubList("c")) continue;

                        log.log("add pl {0}", current);




                        //current.ID = upl.playlistID;
                        //m_htPlayLists.Add(upl.playlistID, current);

                        //parent.add(current);


                        if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                        {
                            foreach (IITTrack t in upl.Tracks)
                            {
                                if (t.Kind == ITTrackKind.ITTrackKindFile)
                                {
                                    IITFileOrCDTrack track = TrackWrapper.create(t); // as IITFileOrCDTrack;
                                    if (!track.Podcast)
                                    {
                                        TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
                                        TrackInList plPiece = new TrackInList(piece, track);
                                        plPiece.ID = track.trackID;
                                        // m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                        current.add(plPiece);
                                        // current.addPiece(piece);
                                    }
                                }
                            }
                            log.log("{0} elts", current.ChildsCount);
                        }


                    }

                }
            }

        }

        private CPlayList addChildPlayList(PlayListComposite parent, IITPlaylist iSubList)
        {
            CPlayList subList = new CPlayList(iSubList.Name);
            subList.ID = iSubList.playlistID;
            //  if (m_htPlayLists.ContainsKey(subList.ID))
            m_htPlayLists.Add(subList.ID, subList);
            m_htLegacyPLayList.recordlegacyPlayList(iSubList as IITUserPlaylist);

            parent.add(subList);
            return subList;
        }

        private PlayList addChildPlayList2(IITUserPlaylist upl, PlayList parent, string name, int ID, string persistentID)
        {
            try
            {
                enter();
                if (!m_htPlayLists.ContainsKey(ID))
                {
                    PlayList subList = null;
                    //bool subListIsGenerated = false; // listLoaded && parent.isSubList(gen);
                    //bool subListIsGen = false; // = parent == root && name == "gen";


                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (logical.Parent != null && parent != null)
                            {
                                if (parent.isSubList(logical))
                                {
                                    subList = parent.getComposite(ID) as PlayList;
                                    break;
                                }
                            }
                        }
                    }

                    if (subList == null)
                    {

                        var strLists = conf.LogicalLists;
                        for (int l = 0; l < strLists.Count; l++)
                        {
                            if (subList != null)
                                break;
                            string strList = strLists[l];
                            string path = strList; // "root" + strList;
                            string[] parts = path.Split('\\');
                            int count = parts.GetLength(0);
                            PlayListComposite current = root;
                            for (int i = 0; i < count; i++)
                            {
                                string part = parts[i];
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                var plPart = current.getComposite(part) as PlayList;
                                //if (plPart == null)
                                //{
                                //    if (listLoaded)
                                //        break;
                                //}
                                if (i == count - 1)
                                {
                                    if (name == part)
                                    {
                                        if (listLoaded)
                                        {
                                            PlayList pl = logicals.Find(lo => lo.Name == name);
                                            if (pl.Parent == null)
                                            {
                                                current.add(pl);
                                                subList = pl;
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            subList = PlayList.create(name, parent, upl);
                                            if (!logicals.Contains(subList))
                                                logicals.Add(subList);
                                            break;

                                        }
                                    }
                                }

                                current = plPart;
                                if (current == null)
                                    break;
                            }

                        }
                    }

                    //if (listLoaded)
                    //{
                    //    foreach (PlayList logical in logicals)
                    //    {
                    //        if (parent.isSubList(logical))
                    //        {
                    //            subList = parent.getComposite(name) as PlayList;
                    //        }
                    //    }
                    //}



                    //if (subListIsGenerated)
                    //    subList = parent.getComposite(name) as PlayList;
                    //else if (subListIsGen && listLoaded)
                    //{
                    //    subList = gen;
                    //    root.add(gen);
                    //}

                    if (subList == null)
                        subList = PlayList.create(name, parent, upl);
                    //if (subListIsGen)
                    //    gen = subList;

                    if (m_htPlayLists.ContainsKey(ID))
                    {
                        var str = string.Format("zarb:ID{0} subList.ID {1} clé existante {2} {3}", ID, subList.ID, subList.getPath(), m_htPlayLists[ID].getPath());

                    }
                    else
                    {

                        subList.ID = ID;

                        m_htPlayLists.Add(subList.ID, subList);
                        persistentIDs.Add(persistentID, subList);
                    }

                }




            }
            finally { release(); }




            return persistentIDs[persistentID]; // subList;
        }




        private void recordlegacyPlayList(IITUserPlaylist upl)
        {
            //  log.log(upl.playlistID + " " + upl.Name);
            //  m_htLegacyPLayList.Add(upl.playlistID, upl);
        }

        //private void recordlegacyPlayList(IITUserPlaylist upl, int index)
        //{
        //    log.log(upl.playlistID + " " + upl.Name);
        //    m_htLegacyPLayList.Add(index, upl);
        //}

        #endregion

        #region manip
        public PlayListComposite getOrCreateFolder(String folder)
        {
            PlayListComposite plFolder = root.getComposite(folder);
            if (plFolder == null)
            {
                IITPlaylist itFolder = app.createFolder(folder);
                recordlegacyPlayList(itFolder as IITUserPlaylist);
                plFolder = addChildPlayList(root, itFolder);
            }
            return plFolder;
        }

        public PlayListComposite getOrCreateFolder(PlayListComposite folder, String name, bool buildIf)
        {
            PlayListComposite pSub = folder.getComposite(name);
            if (pSub == null && buildIf)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITPlaylist itSub = itFolder.createFolder(name);

                pSub = addChildPlayList(folder, itSub);
            }
            return pSub;
        }

        public CPlayList getList(PlayListComposite folder, String name)
        {
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    var itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist);
                    plist = addChildPlayList(folder, itPlist);
                }
                return plist as CPlayList;
            }

        }

        public PlayList GetPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            if (folder == null)
                return null;
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null && buildIf)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    IITPlaylist itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist as IITUserPlaylist);
                    plist = addChildPlayList(folder, itPlist);

                    return PlayList.create(name, folder as CPlayList, itPlist as IITUserPlaylist);
                }

                return plist as PlayList;
            }


        }

        public void mergeList(CPlayList playlist, ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task)
        {
            PlayList pl = playlist as PlayList;
            if (pl == null)
            {
                log.log("pas un PLayList {0}", playlist);
                return;
            }

            withOrder = !pl.VerifyDoublon;
            if (withOrder)
                pl.mergeListWithOrder(newElements_, writer, task); 
            else
                pl.mergeList(newElements_, writer, writeOnlyEnabled, writeOnlyUnRead);
        }




        public void removeList(PlayListComposite folder, String name)
        {
            PlayListComposite plist = folder.getComposite(name);
            if (plist != null)
            {
                IITPlaylist itPlist = m_htLegacyPLayList.getItPl(plist.ID, plist.Name);
                itPlist.Delete();
                m_htLegacyPLayList.Remove(plist.ID, plist.Name);
                m_htPlayLists.Remove(plist.ID);
                folder.remove(plist);
            }
        }

        public void SynchronizePodcast()
        {
            log.log("UpdateIPod");
            app.UpdateIPod();
        }

        public void addList(PlayListComposite folder, String name, ICollection<IFile> list)
        {
            lock (this)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITUserPlaylist itPlist = itFolder.createPlaylist(name);
                recordlegacyPlayList(itPlist as IITUserPlaylist);

                if (list.Count == 0) return;

                //   String[] paths = new String[list.Count+1];

                //for(int i=0; i<list.Count; i++)
                //{
                //    paths[i+1] = list[i].Path ; 
                //}
                //   object objPath = (object)paths;
                //   itPlist.AddFiles(ref objPath); 



                foreach (IFile piece in list)
                {
                    itPlist.AddFile(piece.Location);
                }
            }
        }
        #endregion

        /// <summary>
        /// Rangement de la classList
        /// </summary>
        /// <param name="track"></param>
        /// <param name="orgClassName"></param>
        /// <param name="newClassName"></param>
        public void setClassPlayList(TrackInfoItunes track, string orgClassName, string newClassName)
        {
            lock (this)
            {

                //1. Suppression
                var list = new List<CPlayList>(track.ClassPlayLists);
                foreach (CPlayList pl in list)
                {
                    if (pl.Name.Equals(newClassName))
                        continue;
                    var trackInList = pl.getPieceInList(track);
                    if (trackInList != null)
                        trackInList.Delete();
                }

                //2. vérif que la liste cible ne contient pas déjà le track
                foreach (CPlayList pl in list)
                {
                    if (!pl.Name.Equals(newClassName))
                        continue;
                    var trackInList = pl.getPieceInList(track);
                    if (trackInList != null)
                        return;
                }

                //3. ajout
                PlayList newpl = getClassPlayList(newClassName);
                newpl.Add(track.Location, "setClassPlayList", true);

            }


        }

        public PlayList getFolderOrList(PlayList root, string name, bool findFolder)
        {
            if (root == null)
                root = this.root;
            var current = root;

            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {
                    var plComposite = plComponent as PlayListComposite;
                    if (plComposite.Name == name)
                    {
                        var playList = plComposite as PlayList;
                        var specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone;
                        if (findFolder)
                            specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder;
                        if (playList.ItPlayList.SpecialKind == specialKind)
                        {
                            return playList;

                        }
                    }

                }
            }

            return null;

        }

        private PlayList searchClassList(PlayList current, string listName)
        {
            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {

                    var plComposite = plComponent as PlayListComposite;
                    var name = plComposite.Name;

                    bool sameBase = true;

                    for (int i = 0; i < listName.Length && i < name.Length; i++)
                    {
                        if (!listName[i].Equals(name[i]))
                        {
                            sameBase = false;
                            break;
                        }
                    }

                    if (!sameBase)
                        continue;

                    var playList = plComposite as PlayList;
                    var subSearch = searchClassList(playList, listName);

                    if (subSearch != null)
                        return subSearch;

                    if (name.Equals(listName))
                    {
                        if (playList.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            return playList;
                    }

                }
            }
            return null;
        }


        private PlayList getClassPlayList(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;

                var search = searchClassList(classement, listName);
                if (search != null)
                    return search;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false);
                if (last == null)
                {

                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);


                }

                return last as PlayList;
            }

        }


        private PlayList getClassPlayList__OLD(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false); // current.getComposite(listName);
                if (last == null)
                {
                    //if (current.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    //{
                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);
                    //}

                }

                return last as PlayList;
            }

        }


        public PlayList getOrCreatePlayList(PlayList root, string listName, bool isFolder)
        {
            if (_aborted)
                return null;
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;

                if (root == null)
                    root = this.root;


                var pl = getFolderOrList(root, listName, isFolder);

                if (pl == null)
                {
                    if (_aborted)
                        return null;
                    IITUserPlaylist itPlayList = null;
                    if (isFolder)
                    {
                        if (root == this.root)
                            itPlayList = app.createFolder(listName);
                        else
                            itPlayList = root.ItPlayList.createFolder(listName);

                    }
                    else
                    {
                        if (root == this.root)
                            itPlayList = app.createPlaylist(listName);
                        else
                            itPlayList = root.ItPlayList.createPlaylist(listName);
                    }

                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    pl = PlayList.create(listName, root, itPlayList);
                }

                return pl;
            }
        }

        //public PlayList getOrCreatePlayList(string listName, bool isFolder)
        //{
        //    return getOrCreatePlayList(this.root, listName, isFolder);
        //}



        public void setClassPlayList(ITrackMetaData piece, String listName)
        {
            lock (this)
            {
                if (String.IsNullOrEmpty(listName)) return;
                //String listName = piece.ClassList;
                IITUserPlaylist itCurrent;
                PlayListComposite classement = getOrCreateFolder(CPlayList.CLASSEMENT);

                PlayListComposite current = classement;


                if (listName.isInteger())
                {

                    for (int i = 0; i < listName.Length; i++)
                    {
                        String FolderOrList = listName.Substring(0, i + 1);

                        PlayListComposite subList = current.getComposite(FolderOrList);
                        //  PlayListComposite parent = current.Parent; 
                        IITUserPlaylist itSubList;
                        // IITUserPlaylist itParent = m_htLegacyPLayList[parent.ID]; 
                        if (subList == null)
                        {
                            itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);

                            if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            {

                                var currentName = itCurrent.Name;
                                // suppression et mémorisation des pistes
                                var listAux = new List<ITrackMetaData>();
                                foreach (IITFileOrCDTrack track in itCurrent.Tracks)
                                {
                                    ITrackMetaData pieceToMove = m_htPieces[track.TrackDatabaseID];
                                    listAux.Add(pieceToMove);
                                    // m_htPiecesInAList.Remove(track.trackID);
                                    track.Delete();
                                }

                                // suppression de la liste
                                PlayListComposite parent = current.Parent;
                                IITUserPlaylist itParent = m_htLegacyPLayList.getItPl(parent.ID, parent.Name);

                                itCurrent.Delete();
                                parent.remove(current);
                                m_htPlayLists.Remove(current.ID);

                                // création durépertoire                                                       
                                itCurrent = itParent.createFolder(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itCurrent);
                                current = addChildPlayList(parent, itCurrent);

                                //remplacement de la liste supprimée
                                IITUserPlaylist itRempl = itCurrent.createPlaylist(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itRempl);
                                PlayListComposite rempl = addChildPlayList(current, itRempl);

                                // ajout des morceaux
                                foreach (ITrackMetaData pieceToMove in listAux)
                                {
                                    IITOperationStatus status = itRempl.AddFile(pieceToMove.Location);
                                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                                    TrackInList plPiece = new TrackInList(pieceToMove, track);
                                    plPiece.ID = track.trackID;
                                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                    rempl.add(plPiece);
                                }

                            }
                            itSubList = i < listName.Length - 1 ? itCurrent.createFolder(FolderOrList) as IITUserPlaylist : itCurrent.createPlaylist(FolderOrList) as IITUserPlaylist;
                            recordlegacyPlayList(itSubList as IITUserPlaylist);
                            subList = addChildPlayList(current, itSubList);
                        }
                        current = subList;
                    }

                }
                else
                {
                    PlayListComposite subList = current.getComposite(listName);
                    if (subList == null)
                    {
                        itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); // [current.ID];
                        IITPlaylist itSubList = itCurrent.createPlaylist(listName);
                        recordlegacyPlayList(itSubList as IITUserPlaylist);
                        subList = addChildPlayList(current, itSubList);
                    }
                    current = subList;
                }

                itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); //  [current.ID];
                if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                {
                    PlayListComposite sub = current.getComposite(itCurrent.Name);
                    if (sub == null)
                    {
                        IITUserPlaylist itSubList = itCurrent.createPlaylist(itCurrent.Name) as IITUserPlaylist;
                        recordlegacyPlayList(itSubList);
                        sub = addChildPlayList(current, itSubList);
                    }
                    current = sub;
                    itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);
                }


                {
                    IITOperationStatus status = itCurrent.AddFile(piece.Location);
                    if (status == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                    if (track == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    TrackInList plPiece = new TrackInList(piece, track);
                    plPiece.ID = track.trackID;
                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                    current.add(plPiece);
                    TrackInfoItunes trackBib = m_htPieces[track.TrackDatabaseID];
                    CPlayList pl = current as CPlayList;
                    //if (pl != null)
                    //    pl.addPiece(trackBib);

                }
            }


        }
        //public ITrackMetaData getTrack(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes; 
        //    if (track == null || !exists(piece) )
        //        return new TrackInfoItunes(getNewTrack(piece));

        //    return track;
        //}


        //public IITFileOrCDTrack AddFile(IITUserPlaylist pl, string location)
        //{
        //    IITFileOrCDTrack track = null;
        //    IITOperationStatus status = pl.AddFile(location);
        //    if (status == null)
        //    {
        //        log.log("{0} : unable to AddFile {0}", pl.Name, location);
        //        return null;
        //    }
        //    while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
        //    {
        //        Thread.Sleep(30);
        //    }

        //    track = status.Tracks[1] as IITFileOrCDTrack;
        //    return track;
        //}

        public void discover(TrackInfoItunes t)
        {
            createTrack(t, true);
        }

        public virtual void createTrack(TrackInfoItunes piece, bool podcast)
        {

            try
            {
                log.log(String.Format("create track for {0}", piece.Location));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);

                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    piece.TrackTrack = new NoTrack(piece);
                    return;
                }

                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                m_htTracks.Add(track.TrackDatabaseID, track);

                if (m_htPieces.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);


                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, piece);
                m_htLoc.Add(piece.Location, piece);
                piece.TrackTrack = track;

                if (podcast && track.Genre != "Podcast")
                {
                    try { track.Genre = "Podcast"; }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }


                var album = track.Album;
                if (string.IsNullOrEmpty(album))
                {
                    var f = new FileInfo(piece.Location);
                    album = f.Directory.Name; 
                }

                if (piece.TrackAlbum == null)
                {
                    piece.setAlbum(album); 
                }
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }

        }

        public TrackInfoItunes getNewTrack(IFile piece)
        {

            TrackInfoItunes intern = null;
            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return null;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);
                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    return m_htPieces[track.TrackDatabaseID]; // m_htTracks[track.TrackDatabaseID];
                }
                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    return null;
                }

                intern = create(track.Location);
                intern.build(track);
                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                m_htTracks.Add(track.TrackDatabaseID, track);
                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, intern);
                m_htLoc.Add(track.Location, intern);
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }
            return intern;
        }



        private TrackInfoItunes getNewTrack(ITrackNative piece)
        {

            //PlayListComposite plNew = root.getComposite("news");
            //IITUserPlaylist itNews;
            //if (plNew == null)
            //{
            //    itNews = app.CreatePlaylist("news") as IITUserPlaylist;
            //    recordlegacyPlayList(itNews);
            //    plNew = addChildPlayList(root, itNews);
            //}

            //itNews = m_htLegacyPLayList[plNew.ID];

            //// String[] path = new String[] { piece.Path };
            //IITOperationStatus status = itNews.AddFile(piece.Path);
            //track = status.Tracks[1] as IITFileOrCDTrack;
            //piece.ID = track.TrackDatabaseID;
            //m_htTracks.Add(track.TrackDatabaseID, track);
            //m_htPieces.Add(track.TrackDatabaseID, piece);
            //return track;

            TrackInfoItunes intern = getNewTrack(piece as IFile);

            try
            {
                intern.Artist = piece.Artist;
            }
            catch { log.log("unable to change artist {0}  {1}", piece.Artist, piece); }
            try
            {
                intern.Album = piece.Album;
            }
            catch { log.log("unable to change album  {0}  {1}", piece.Album, piece); }
            try
            {
                intern.Name = piece.Name;
            }
            catch { log.log("unable to change name  {0}  {1}", piece.Name, piece); }
            try
            {
                if (piece.TrackNumber > 100000) intern.TrackNumber = 0;
                if (piece.TrackNumber > 0)
                {
                    intern.TrackNumber = piece.TrackNumber;
                }
                else
                {
                    intern.TrackNumber = 0;
                }
            }
            catch { log.log("unable to change number  {0} {1}", piece.TrackNumber, piece); }
            if (piece.Year > 0) try { intern.Year = piece.Year; }
                catch { log.log("unable to change year  {0} {1}", piece.Year, piece); }

            if (piece.Rating >= 0) try { intern.Rating = piece.Rating; }
                catch { log.log("unable to change rating  {0} {1}", piece.Rating, piece); }

            //try
            //{
            //    if (!string.IsNullOrEmpty(piece.ClassName))
            //    {
            //        setClassPlayList(intern, "", piece.ClassName);
            //    }
            //}
            //catch
            //{
            //    log.log("unable to change className  {0} {1}", intern.ClassName, piece);
            //}

            try { intern.Enabled = piece.Enabled; }
            catch { log.log("unable to change check  {0} {1}", piece.Enabled, piece); }

            return intern;


        }


        //private bool exists(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes;
        //    if (track == null) return false;
        //    return m_htTracks.ContainsKey(track.ID);
        //}

        public ITrackInfoItunes createLegacyTrack(ITrackNative piece)
        {
            return getNewTrack(piece);
        }

        //public IITTrackCollection Tracks
        //{
        //    get { return app.LibraryPlaylist.Tracks; }
        //}

        public void Disconnect()
        {
            app = null;
            gcCollect();
        }
        private void gcCollect()
        {
            if (conf.GcCollect)
                misc.gcCollect("Loader");
        }
        public String DbPath { get { return _dBLegacyPath; } }
        public string DbDir { get { return _dBLegacyDir; } }

        public void deleteTrack(String location)
        {
            if (location.isNullorEmpty())
            {
                log.log("Loader: unable to delete track, location empty!");
                return;
            }
            location = location.ToLower();
            //     private Dictionary<int, TrackInfoItunes> m_htPieces = new Dictionary<int, TrackInfoItunes>();
            //private Dictionary<int, IITFileOrCDTrack> m_htTracks = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, IITFileOrCDTrack> m_htPiecesInAList = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, PlayListComposite> m_htPlayLists = new Dictionary<int, PlayListComposite>();
            // private Dictionary<int, IITUserPlaylist> m_htLegacyPLayList = new Dictionary<int, IITUserPlaylist>();
            TrackInfoItunes info = null;
            foreach (TrackInfoItunes _info in m_htPieces.Values)
            {
                if (_info.Location.isNullorEmpty()) continue;
                if (_info.Location.ToLower() == location)
                {
                    info = _info;
                    break;
                }

            }
            if (info == null)
            {
                log.log("Loader:deleteTrack '{0}' non trouvé", location);
                return;
            }

            try
            {
                log.log("Loader:deleteTrack: delete'{0}'", location);
                int ID = info.ID;
                // IITFileOrCDTrack track = info.Track;

                List<TrackInList> listToDelete = new List<TrackInList>();
                //foreach (TrackInList trackInList in info.ClassPlayLists
                //{
                //    if (trackInList.ID == ID)
                //    {
                //        listToDelete.Add(trackInList);
                //    }
                //}

                //foreach (TrackInList trackInList in listToDelete)
                //{
                //    m_htPiecesInAList.Remove(trackInList.ID);
                //    trackInList.Delete();
                //}


                info.Delete();
                list.Remove(info);
                //buildIndexesTracks();
            }
            catch
            {

                log.log("Loader:unable to deleteTrack: '{0}'", location);
            }
        }



        public ITrackInfoItunes createTrack(int id, String location)
        {
            if (!location.isMusic())
                return null;
            //if (location.ToLower().EndsWith(".m3u")) return null;
            //if (location.ToLower().EndsWith(".pls")) return null;
            //if (location.ToLower().EndsWith(".jpg")) return null;
            //if (location.ToLower().EndsWith(".png")) return null;
            return getNewTrack(new FileLocation(location, id));
        }
        private class FileLocation : IFile
        {
            String file;
            int id;
            public FileLocation(String file, int id) { this.file = file; this.id = id; }
            public string Location { get { return file; } }

            public override string ToString()
            {
                return file;
            }



            public int PieceId
            {
                get { return id; }
            }


            public string getLocation()
            {
                return file;
            }
        }


        public PlayListComposite TreePlayList
        {
            get { return root; }
        }



        #region ITrackBuilder Members



        #endregion

        public virtual TrackInfoItunes create(string location)
        {
            return new TrackInfoItunes() { Location = location };
        }

        # region lecture
        private AutoPlayer player;
        public List<TrackInList> NextTracks { set { player.NextTracks = value; } }
        public TrackInList CurrentTrackInList { get { return player.CurrentTrack; } }
        public void PlayComputedTrack()
        {
            player.PlayComputedTrack();
        }
        //private TrackInList nextTrack;
        //private TrackInList currentTrack; 
        //public TrackInList NextTrack
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("NextTrack:: old : {0}, new {1}", nextTrack, value);
        //        nextTrack = value;
        //    }
        //    get
        //    {
        //        return nextTrack;
        //    }
        //}

        //public TrackInList CurrentTrackInList
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("CurrentTrack:: old : {0}, new {1}", currentTrack, value);
        //        currentTrack = value;
        //    }
        //    get
        //    {
        //        return currentTrack;
        //    }
        //}

        //public void PlayComputedTrack()
        //{
        //    if (conf == null || !conf.AutoPlay)
        //        return;
        //    try
        //    {
        //        if (app.PlayerState != ITPlayerState.ITPlayerStatePlaying)
        //            return;
        //        var usualTrack = CurrentTrackLocation;
        //        if (nextTrack == null)
        //            return;
        //        if (currentTrack == null)
        //            return;
        //        if (usualTrack.Equals(currentTrack.Location))
        //            return;
        //        if (usualTrack.Equals(nextTrack.Location))
        //            return;
        //        log.log("PlayComputedTrack::usualTrack:{0} nextTrack:{1}", usualTrack, nextTrack.Location);
        //        nextTrack.play();
        //        currentReading = nextTrack.Location;
        //        nextTrack = null;


        //    }
        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }


        //}
        #endregion

        private bool _aborted;
        public bool Aborted
        {
            get
            {
                return _aborted;
            }
            set
            {
                _aborted = value;
            }
        }
    }

    public static class TrackUtil
    {

    }
}


]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        protected static IAlbumMgr albumMgr;
        public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        //private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        //private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        // private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        //private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }

        public virtual void setAlbum(string album)
        {
            albumMgr.setAlbum(this, album);
        }

        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            albumMgr.setAlbum(this, track.Album);
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;

            fillDesc(track); 




        }

        public bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;
            _isPodCast = false; 


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        break;
                    case "Artist": artist = value; break;
                    case "Album": albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                fillDesc(tracktrack); 
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        private string description;
        private string longDescription;

        public string Description { get { return description; } protected set { description = value; } }
        public string LongDescription { get { return longDescription; } protected set { longDescription = value; } }


        public void fillDesc(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription; 
        }
        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;

                fillDesc(track); 
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                bgArtist.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }
        protected IAlbum _album;
        public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album; } }
        public string Album
        {
            get
            {
                return _album.Album;
            }
            set
            {
                if (value == null || value.Equals(_album.Album)) return;
                bgAlbum.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    albumMgr.setAlbum(this, value);
                }, this,
                "change album from '{0}' to'{1}' {2}", Album, value, this
                ));

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                int lengh = 0;
                if (name != null)
                    lengh = name.Length;

                if (value.Length < lengh)
                {
                    log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                    // return; 
                }


                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgName.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        //private bool firstClass;
        //public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                // firstClass = false;
                if (comment != value)
                {
                    //try
                    //{
                    //    var tab0 = comment.Split(' ');
                    //    var tab1 = value.Split(' ');

                    //    var count0 = tab0.GetLength(0);
                    //    var count1 = tab1.GetLength(0);

                    //    if (count0 != count1)
                    //        firstClass = true;

                    //    else if (comment.Length > 3)
                    //    {
                    //        string org = tab0[count0 - 1];
                    //        string fin = tab1[count1 - 1];

                    //        firstClass = !org.Equals(fin);
                    //    }
                    //}

                    //catch
                    //{
                    //    firstClass = true;
                    //}

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    //if (firstClass)
                    //    bgFirstClass.add(task);
                    //else
                    bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        protected bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }

            set
            {
                if (!present)
                {
                    grouping = value;
                    return;
                }
                if (grouping != value)
                {
                    var task = new BgTaskGrouping(this, string.Format("change grouping from '{0}' to'{1}' {2}", grouping, value, this), value);
                    bgg.add(task);
                }
            }


        }

        //public void setGrouping(string value, bool prior)
        //{
        //    if (!present)
        //    {
        //        grouping = value;
        //        return;
        //    }
        //    if (grouping != value)
        //    {
        //        bool _delta = false;
        //        // bool _deltaRank = false; 
        //        string rankAlbum = "";
        //        string equivAlbum = "";
        //        if (value != null)
        //        {
        //            string[] org = grouping.Split(' ');
        //            string[] _new = value.Split(' ');

        //            int count = org.GetLength(0);
        //            if (_new.GetLength(0) != count || count < 3)
        //                _delta = true;
        //            else
        //            {
        //                rankAlbum = _new[1];
        //                equivAlbum = _new[2];
        //                if (!org[1].Equals(_new[1]))
        //                {
        //                    _delta = true;
        //                }
        //            }
        //        }

        //        var sb = new StringBuilder();
        //        sb.Append(rankAlbum);
        //        sb.Append(" ");
        //        sb.Append(equivAlbum);
        //        sb.Append(" ");
        //        sb.Append(Album);
        //        //sb.Append(ClassName);
        //        //sb.Append(".");
        //        //sb.Append((Rating / 20).ToString());

        //        var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

        //        if (firstClass)
        //        {
        //            bgSeconClass.add(task);
        //            return;
        //        }

        //        //if (prior)
        //        //{
        //        //    bgGroupPrior.add(task);
        //        //    return;
        //        //}



        //        if (_delta)
        //        {
        //            if (prior)
        //                bgGroupPrior.add(task);
        //            else
        //                bgGroup2nd.add(task);
        //            return;
        //        }

        //        bgg.add(task);

        //        //if (_delta)
        //        //    bgGroupDelta.add(task);
        //        //else
        //        //{
        //        //    bgg.add(task);
        //        //}
        //        //  grouping = value;
        //    }
        //}



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location;
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }



        public string strClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement DeepClassement
        {
            get { throw new NotImplementedException(); }
        }


        public Classement MaxClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement Classement
        {
            get
            {
                throw new NotImplementedException();
            }
        }
    }
}



]]></content>
  </file>
  <file path="\PieceDb.obj\Classement.cs">
    <content><![CDATA[using System;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.obj
{
    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }


    /// <summary>
    /// type de base de la donnée classement : 
    /// paire : liste / rating 
    /// 
    /// </summary>
    /// <remarks>utilisé comme une valeur simple (entier - string)</remarks>
    public class Classement : IComparable<Classement>
    {
        private static Dict<string, Classement> dict = new Dict<string, Classement>();
        public static Regex regClassement = new Regex(@"([0-5]+)\.([0-5])");
        public static Regex regClassement2 = new Regex(@"([0-5]+)");
        private static bool isClassement(string input) { return string.IsNullOrEmpty(input) || regClassement.IsMatch(input); }
        private static Classement _NULL = new Classement("", 0);
        private static Classement _ZERO = new Classement("0", 0);
        public static Classement NULL { get { return _NULL; } }
        public static Classement ZERO { get { return _ZERO; } }
        public static bool canBeClassement(string input)
        {
            if (string.IsNullOrEmpty(input))
                return true;
            if (regClassement2.IsMatch(input))
                return true;
            if (regClassement.IsMatch(input))
                return true;
            return false;

        }
        public static Classement create(string input)
        {
            if (input != null)
                input = input.Replace(" ", "");
            if (input == "0")
                return new Classement("0", 0);

            if (string.IsNullOrEmpty(input))
                return _NULL;
            if ("0.0".Equals(input))
                return ZERO;

            if (!isClassement(input))
                return null;
            if (dict.ContainsKey(input))
            {
                return dict[input];
            }
            var groups = regClassement.Match(input).Groups;
            var cl = new Classement(groups[1].Value, (Convert.ToInt32(groups[2].Value)));
            dict[input] = cl;
            return cl;
        }

        public static Classement create(string className, int rating)
        {
            if (rating < 0)
                return _NULL;
            var input = string.Format("{0}.{1}", className, rating);
            return create(input);

        }






        public decimal RapportClassement
        {
            get
            {
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }
        private string m_class = "";
        private int m_rating = -1;
        private Classement(string a_class, int a_rating)
        {
            m_class = a_class;
            m_rating = a_rating;
        }

        private Classement(Classement o)
        {
            m_class = o.m_class;
            m_rating = o.m_rating;

        }
        public string ClassList
        {
            get { return m_class; }
            // set { m_class = value; }
        }
        public int Rating
        {
            get { return m_rating; }
            //   set { m_rating = value; }
        }
        public override bool Equals(object obj)
        {
            if (obj is Classement)
            {
                Classement l_obj = (Classement)obj;
                return m_class.Equals(l_obj.m_class) && m_rating == l_obj.m_rating;
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_class.GetHashCode() + m_rating.GetHashCode();
        }

        #region rang
        private Bool m_numericClassList;
        //private String m_classNameAndRating = "";
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                if (m_numericClassList == Bool.not_defined)
                {
                    if (String.IsNullOrEmpty(m_class)) return false;
                    bool res = m_class.isInteger();  //CUtil.isInteger(m_class);
                    m_numericClassList = res ? Bool.True : Bool.False;
                    return res;
                }
                else
                {
                    return m_numericClassList == Bool.True ? true : false;
                }
            }
        }
        public String ClassNameAndRating
        {
            get
            {
                if (!isClassListNumeric) return "." + m_rating;
                return m_class + m_rating;
            }
        }

        public String ClassNameAndRatingWithPt
        {
            get
            {
                if (!isClassListNumeric) return "." + m_rating;
                return m_class + "." + m_rating;
            }
        }
        /// <summary>
        /// Donne la valeur du classement. Pratique pour la comparaison
        /// </summary>
        /// <returns></returns>
        public double getNormValue()
        {
            if (!isClassListNumeric)
                return -1;
            string classNameAndRating = ClassNameAndRating;
            string strDouble = classNameAndRating.Insert(1, ",");
            return Convert.ToDouble(strDouble);
        }

        //private String getNbStars() { return (m_rating / 20).ToString(); }
        public override string ToString()
        {
            if (!isClassListNumeric) return m_class;
            return String.Format("{0}.{1}", m_class, m_rating);
        }




        public decimal ClassementValueDecimal
        {
            get
            {
                if (!isClassListNumeric) return 0;
                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                return Convert.ToDecimal(classNameAndRating);
            }
        }

        public bool isNull()
        { return this == _NULL; }

        public bool isClassed()
        {
            return this != _NULL; 
        }

        public bool isPositive()
        {
            return isClassed() && this != _ZERO; 
        }

        //public static bool operator ==(Classement c1, Classement c2)
        //{
        //    if ( Object.ReferenceEquals(c1,c2))
        //        return true;
        //    if (Object.ReferenceEquals(c1,null))
        //        return false;
        //    return c1.CompareTo(c2) == 0;
        //}
        //public static bool operator !=(Classement c1, Classement c2)
        //{
        //   return !(c1 == c2); 
        //}


        public static bool operator >(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return false;
            return c1.CompareTo(c2) > 0;
        }
        public static bool operator >=(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return false;
            return c1.CompareTo(c2) >= 0;
        }
        public static bool operator <(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return false;
            return c1.CompareTo(c2) < 0;
        }
        public static bool operator <=(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return false;
            return c1.CompareTo(c2) <= 0;
        }

        #endregion


        public int CompareTo(Classement other)
        {
            if (other == this)
                return 0; 
            if (other == null)
                return 1;
            if (m_class.isNullorEmpty())
            {
                if (other.m_class.isNullorEmpty())
                    return 0;
                return -1;
            }
            if (other.m_class.isNullorEmpty())
                return 1;
            int cmp = 0;
            int count = m_class.Length;
            int ocount = other.m_class.Length;
            for (int i = 0; i < count && i < ocount; i++)
            {
                var c = m_class[i];
                var oc = other.m_class[i];
                cmp = c.CompareTo(oc);
                if (cmp != 0)
                    return cmp;
            }
            if (count < ocount)
            {

                var otherC = Convert.ToInt32(other.m_class[count].ToString());
                cmp = m_rating.CompareTo(otherC);
                if (cmp != 0)
                    return cmp;
                return -1;
            }
            else if (count > ocount)
            {
                var rating = other.m_rating;
                var value = Convert.ToInt32(m_class[ocount].ToString());
                cmp = value.CompareTo(rating);
                if (cmp != 0)
                    return cmp;
                return 1;
            }
            else
            {
                var rating = this.m_rating;
                var orating = other.m_rating;
                cmp = rating.CompareTo(orating);
                return cmp;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        string getLocation();
        int PieceId { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; set; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
     //   String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        DateTime Added { get; }
        TimeSpan Duration { get; set; }
        bool Played { get; }
      //  string ArtWork { get; set; }
     //   string Grouping { get; }
      //  void setGrouping(string value,bool prior);
       // bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif 
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    public interface ITrackPlayedDates
    {
        List<DateTime> Dates { get; }
        List<DateTime> DatesClassement { get; }
        List<DateTime> DatesClassementBrut { get; }
        String ClassEvol { get; }
    }

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    public interface ITrackNative : ITrackMetaData, ITrackPlayListReport
    {       
        Classement Classement { get; }
        Classement DeepClassement { get; }       
        Classement MaxClassement { get; }

      //  void registerDependency(ITrackNative local);
     //   void releaseDependency();
    }

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    {
        void setClassement(string className, int rating);
        void setClassement(string classement);
        List<string> RelativesPath { get; }
        exportState ExportStatus { get; set;}
        
    }

    /// <summary>
    /// Enregistrement des playlists associées au morceau
    /// </summary>
    public interface ITrackPlayListRecorder
    {
        void AddPlayList(CPlayList a_playList);
        void removePlayList(CPlayList list);
    }

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    public interface ITrackPlayListReport
    {
       // List<CPlayList> PLayLists { get; }
        List<CPlayList> ClassPlayLists { get; }
    }

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    public interface ITrackInfoItunes : ITrackNative, ITrackPlayListRecorder
    {
       
       
    }

    public class NullTrack : ITrackNative
    {

        #region ITrackNative Members

        public string ClassName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void registerDependency(ITrackNative local) { }
       public void releaseDependency() { }

        #endregion

        #region ITrackMetaData Members

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        public TimeSpan Duration
        {
            get { return new TimeSpan();  }
            set { }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            
        }
            
      //  public void setGrouping(string value, bool prior) { }


        public int Volume { get { return 0; } set { } }

        #endregion

        #region IFile Members

        public string Location
        {
            get { return ""; }
        }

        public string getLocation()
        {
            return "";
        }

        #endregion

        #region ITrackReference Members

        public string Artist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Album
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Name
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        #endregion

        #region ITrackPlayListReport Members

        public List<CPlayList> PLayLists
        {
            get { return new List<CPlayList>(); }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return new List<CPlayList>(); }
        }

        #endregion

        public bool FirstClass { get { return false; } set {  } }

        public int PieceId
        {
            get { return -1;  }
        }

        public int PieceParentId
        {
            get { return -1; }
            set { }
        }



        public TrackIdentity Key
        {
            get { return new TrackIdentity(this);  }
        }


        public DateTime Added
        {
            get { return DateTime.MinValue; }
        }


        public bool Played
        {
            get { return false; }
        }


        public string strClassement
        {
            get { return ""; }
        }

        public Classement Classement
        {
            get { return Classement.NULL; }
        }


        public Classement DeepClassement
        {
            get { return Classement.NULL; }
        }


        public Classement MaxClassement
        {
            get { return Classement.create("0.0");  }
        }
    }





}


]]></content>
  </file>
</db>
