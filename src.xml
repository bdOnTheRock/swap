<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.AXVLC, Version=1.0.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>False</EmbedInteropTypes>
      <HintPath>bin\Interop.AXVLC.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="policy.2.0.taglib-sharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\policy.2.0.taglib-sharp.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="taglib-sharp, Version=2.1.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\taglib-sharp.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="Xceed.Wpf.Toolkit">
      <HintPath>libs\Extended WPF Toolkit Binaries\Xceed.Wpf.Toolkit.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\ArtWorkManager.cs" />
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\Colors\ColorViewModel.cs" />
    <Compile Include="ViewModel\Colors\Couleurs.cs" />
    <Compile Include="ViewModel\Colors\MementoColor.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CoulHistoryBack.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\Explorer.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastClassement.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastRead.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PieceViewModel.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfFilterW.xaml.cs">
      <DependentUpon>ConfFilterW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfMedianneW.xaml.cs">
      <DependentUpon>ConfMedianneW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfVirt.xaml.cs">
      <DependentUpon>ConfVirt.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfCouleurs.xaml.cs">
      <DependentUpon>ConfCouleurs.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Debug.xaml.cs">
      <DependentUpon>Debug.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\EnhancedDataGrid.cs" />
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Memento.cs" />
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\GradiantBuilder.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfFilterW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfMedianneW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfVirt.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfCouleurs.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Debug.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }


        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return piece.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return piece.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Loaded="Window_Loaded"  xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" >
    <Grid  IsSharedSizeScope="True" >

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0" Name="gfirst" IsSharedSizeScope="True"/>

        <Grid Grid.Row="1" Name="gsecond"  IsSharedSizeScope="True"/>
        <!--<Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="236*" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="9" Name="tb_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5" KeyUp="tb_coeffT_KeyUp" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="11" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="12" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="14" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="15" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="22" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="23" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="24" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />

            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="0" Grid.Column="25" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="0" Grid.Column="26" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="9" Name="tb2_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5"  />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="11" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="12" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="14" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="15" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="22" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="23" Name="cb2_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="24" Name="cb2_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="1" Grid.Column="25" Name="cbx2_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="1" Grid.Column="26" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>-->
        <Grid Grid.Row="2" Height="137" Margin="0,0,34,-102">
            <StackPanel Orientation="Horizontal"  HorizontalAlignment="Left"  Margin="0,5" >
                <CheckBox Name="cb_createCourant" ToolTip="générer stats en cours (désactivés)"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createInter" ToolTip="générer stats en cours + provisoire"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createAll" ToolTip="générer stats de tout"  Margin="5" Padding="2"></CheckBox>
                <DatePicker Name="dp_date" ToolTip="Date seuil pour considérer un classement provisoire" />
            </StackPanel>
            <StackPanel Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5,-80,5"  Width="430">
                <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="20" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="2"/>
                <TextBox Grid.Row="2" Name="tb_stackBefore" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="nb d'éléments devant la pile d'exclusion" Margin="5" Padding="2"/>
                <CheckBox Grid.Row="2" Name="cb_stackEnabled" Width="30"  VerticalAlignment="Center" ToolTip="Utiliser la pile d'exclusion" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_checkStack" Width="30"  VerticalAlignment="Center" ToolTip="Ne pas prendre en compte les albums retardés dans la file d'attente pour la cinématique" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_idem" Width="30"  VerticalAlignment="Center" ToolTip="Lier les items" Margin="5" Padding="2" Click="cb_idem_Click" />

                <Button Grid.Row="2" Name="bt_cancel" IsCancel="true" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_coul" Height="25" HorizontalAlignment="Right" Content="Couleurs" Click="bt_coul_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_debug" Height="25" HorizontalAlignment="Right" Content="Debug" Click="bt_debug_Click"   Margin="5" Padding="2"/>
            </StackPanel>
        </Grid>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;
using pdb.gen;
using pdb.db.piece.type;
using pdb.player.Vue.Conf;
using System.Windows.Controls;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window, IConfSort
    {
        private ConfAlbumSort conf;
        private ConfMedianneW first;
        private ConfMedianneW second;
        private static bool _idem;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            bt_ok.IsDefault = true;

            display();
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
            first = new ConfMedianneW(conf.Composants[0], this);
            gfirst.Children.Add(first);
            if (conf.Composants.Count > 1)
            {
                second = new ConfMedianneW(conf.Composants[1], this);
                gsecond.Children.Add(second);
            }

            InitializeComponent();
        }

        void display()
        {
          
            tb_stackSize.Text = conf.stackSize.ToString();
            tb_stackBefore.Text = conf.stackBefore.ToString();
            cb_createAll.IsChecked = conf.createAll;
            cb_createInter.IsChecked = conf.createInter;
            cb_createCourant.IsChecked = conf.createCourant;
            dp_date.SelectedDate = conf.lastModif;
            cb_idem.IsChecked = _idem;
            cb_checkStack.IsChecked = conf.checkStack;
            cb_stackEnabled.IsChecked = conf.stackEnabled; 
         

            first.display();
            if (second != null)
                second.display();


            //var list = conf.Composants;
            //var item1 = list[0];
            //cb_enabled.IsChecked = item1.enabled;
            //cbxSort.SelectedIndex = (int)item1.type;
            //tb_medianne.Text = item1.medianne.ToString();
            //cb_quasi.IsChecked = item1.quasi;
            //cb_lissage.IsChecked = item1.lissage;
            //cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            //cb_reSort.IsChecked = item1.reSort;
            //cb_removeFirst.IsChecked = item1.removeFirst;
            //cb_deleteFirst.IsChecked = item1.deleteFirst;
            //cbx1_removeLast.SelectedIndex = (int)item1.removeLast;
            //cb_cumul.IsChecked = item1.cumul;
            //cb_noAdd.IsChecked = item1.noAdd;
            //tb_safe.Text = item1.safe.ToString();
            //tb_coeff.Text = item1.coeffVirt.ToString();
            //tb_exp.Text = item1.expEnabled.ToString();
            //tb_zero.Text = Piece.getClassementEquiv(item1.zero);
            //cb_removeEnabled.IsChecked = item1.removeEnabled;
            //cb_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            //cb_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            //cb_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            //cb_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            //cb_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            //cb_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            //cbx_cmpMinn.SelectedIndex = (int)item1.cmpMin;
            //cb_noaddEnd.IsChecked = item1.noAddEnd;
            //cb_noaddAll.IsChecked = item1.noAddAll; 





            //if (list.Count > 1)
            //{
            //    item1 = list[1];
            //    cb2_enabled.IsChecked = item1.enabled;
            //    cbx2Sort.SelectedIndex = (int)item1.type;
            //    tb2_medianne.Text = item1.medianne.ToString();
            //    cb2_quasi.IsChecked = item1.quasi;
            //    cb2_lissage.IsChecked = item1.lissage;
            //    cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
            //    cb2_reSort.IsChecked = item1.reSort;
            //    cb2_removeFirst.IsChecked = item1.removeFirst;
            //    cb2_deleteFirst.IsChecked = item1.deleteFirst;
            //    cbx2_removeLast.SelectedIndex = (int)item1.removeLast;
            //    cb2_cumul.IsChecked = item1.cumul;
            //    cb2_noAdd.IsChecked = item1.noAdd;
            //    tb2_safe.Text = item1.safe.ToString();
            //    tb2_coeff.Text = item1.coeffVirt.ToString();
            //    tb2_exp.Text = item1.expEnabled.ToString();
            //    tb2_zero.Text = Piece.getClassementEquiv(item1.zero);
            //    cb2_removeEnabled.IsChecked = item1.removeEnabled;
            //    cb2_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            //    cb2_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            //    cb2_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            //    cb2_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            //    cb2_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            //    cb2_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            //    cbx2_cmpMinn.SelectedIndex = (int)item1.cmpMin;
            //    cb2_noaddEnd.IsChecked = item1.noAddEnd;
            //    cb2_noaddAll.IsChecked = item1.noAddAll; 
            //}
        }
        void record()
        {
          
            conf.stackSize = Convert.ToInt32(tb_stackSize.Text);
            conf.stackBefore = Convert.ToInt32(tb_stackBefore.Text);
            conf.createCourant = cb_createCourant.IsChecked.Value;
            conf.createInter = cb_createInter.IsChecked.Value;
            conf.createAll = cb_createAll.IsChecked.Value;
            conf.lastModif = dp_date.SelectedDate.Value;
            conf.checkStack = cb_checkStack.IsChecked.Value;
            conf.stackEnabled = cb_stackEnabled.IsChecked.Value; 
          

            first.record();
            if (second != null)
                second.record();

           


            //var list = conf.Composants;
            //var item1 = list[0];
            //item1.enabled = cb_enabled.IsChecked.Value;
            //item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            //item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            //item1.quasi = cb_quasi.IsChecked.Value;
            //item1.lissage = cb_lissage.IsChecked.Value;
            //item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            //item1.reSort = cb_reSort.IsChecked.Value;
            //item1.removeFirst = cb_removeFirst.IsChecked.Value;
            //item1.deleteFirst = cb_deleteFirst.IsChecked.Value;
            //item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex;
            //item1.cumul = cb_cumul.IsChecked.Value;
            //item1.noAdd = cb_noAdd.IsChecked.Value;
            //item1.safe = Convert.ToInt32(tb_safe.Text);
            //item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);
            //item1.expEnabled = Convert.ToDecimal(tb_exp.Text);
            //var cl = Classement.create(tb_zero.Text);
            //item1.zero = cl.RapportClassement;
            //item1.removeEnabled = cb_removeEnabled.IsChecked.Value;
            //item1.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            //item1.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            //item1.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            //item1.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            //item1.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            //item1.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;
            //item1.cmpMin = (util.modeMin)cbx_cmpMinn.SelectedIndex;
            //item1.noAddEnd = cb_noaddEnd.IsChecked.Value;
            //item1.noAddAll = cb_noaddAll.IsChecked.Value; 

            //if (list.Count > 1)
            //{
            //    if (cbx2Sort.SelectedIndex == 0)
            //    {
            //        list.RemoveAt(1);
            //        return;
            //    }
            //}
            //else
            //{
            //    if (cbx2Sort.SelectedIndex > 0)
            //    {
            //        item1 = new util.ConfMedianne();
            //        list.Add(item1);
            //    }
            //}

            //if (list.Count > 1)
            //{
            //    item1 = list[1];

            //    item1.enabled = cb2_enabled.IsChecked.Value;
            //    item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
            //    item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
            //    item1.quasi = cb2_quasi.IsChecked.Value;
            //    item1.lissage = cb2_lissage.IsChecked.Value;
            //    item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
            //    item1.reSort = cb2_reSort.IsChecked.Value;
            //    item1.removeFirst = cb2_removeFirst.IsChecked.Value;
            //    item1.deleteFirst = cb2_deleteFirst.IsChecked.Value;
            //    item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex;
            //    item1.cumul = cb2_cumul.IsChecked.Value;
            //    item1.noAdd = cb2_noAdd.IsChecked.Value;
            //    item1.safe = Convert.ToInt32(tb2_safe.Text);
            //    item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
            //    item1.expEnabled = Convert.ToDecimal(tb2_exp.Text);
            //    item1.zero = Convert.ToDecimal(tb2_zero.Text);

            //    cl = Classement.create(tb2_zero.Text);
            //    item1.zero = cl.RapportClassement;
            //    item1.removeEnabled = cb2_removeEnabled.IsChecked.Value;
            //    item1.virtOnlyDisabled = cb2_virtOnlyDisabled.IsChecked.Value;
            //    item1.forceCoeffVirt = cb2_forceCoeffVirt.IsChecked.Value;
            //    item1.virtAlignPrec = cb2_virtAlignPrec.IsChecked.Value;
            //    item1.virtAlignSelected = cb2_virtAlignSelected.IsChecked.Value;
            //    item1.coeffVirtAuto = cb2_coeffVirtAuto.IsChecked.Value;
            //    item1.coeffVirtAdjust = cb2_coeffVirtAdjust.IsChecked.Value;
            //    item1.cmpMin = (util.modeMin)cbx2_cmpMinn.SelectedIndex;
            //    item1.noAddEnd = cb2_noaddEnd.IsChecked.Value;
            //    item1.noAddAll = cb2_noaddAll.IsChecked.Value; 
            //}
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul();
            App.go();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }




        //public string CoeffEnabled
        //{
        //    get { return tb_coeffEnabled.Text; }
        //}

        public bool DuplicateItem
        {
            get
            {
                bool ret = cb_idem.IsChecked.Value;
                _idem = ret;
                return ret;
            }
        }
        private void tb_safe_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            first.onchange();

            if (second != null)
                second.onchange();
        }

        private void bt_coul_Click(object sender, RoutedEventArgs e)
        {
            new ConfCouleurs().Show();
        }

        private void cb_idem_Click(object sender, RoutedEventArgs e)
        {
            first.checkIdem();
            if (second != null)
                second.checkIdem();
        }

        private void bt_debug_Click(object sender, RoutedEventArgs e)
        {
            var w = new Debug(conf);
            w.Show(); 
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfVirt.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.util;
using Math = System.Math; 
namespace pdb.player.Vue.Conf
{
    public interface IConfSort
    {
     //   string CoeffEnabled { get; }
        bool DuplicateItem { get; }
    }
    /// <summary>
    /// Interaction logic for ConfVirt.xaml
    /// </summary>
    public partial class ConfVirt : UserControl
    {
        private ConfMedianneVirt conf;
        private IConfSort parent;
    


        decimal coeffp;
        decimal prod;
        decimal conv; 
        

        public ConfVirt()
        {
            InitializeComponent();
        }

        public ConfVirt(ConfMedianneVirt conf, IConfSort parent)
            : this()
        {
            this.conf = conf;
            this.parent = parent;
            //display();
            //onchange();
        }

        public ConfMedianneVirt Conf
        {
            set
            {
                this.conf = value; 
            }
        }


        public void display()
        {

           
            cb_lissage.IsChecked = conf.lissage;
            cb_removeEpsilon.IsChecked = conf.removeEpsilon;
            cb_reSort.IsChecked = conf.reSort;


            cb_cumul.IsChecked = conf.cumul;
            cb_noAdd.IsChecked = conf.noAdd;
            tb_safe.Text = conf.safe.ToString();
            tb_coeff.Text = conf.coeffVirt.ToString();


            cb_virtOnlyDisabled.IsChecked = conf.virtOnlyDisabled;
            cb_forceCoeffVirt.IsChecked = conf.forceCoeffVirt;
            cb_virtAlignPrec.IsChecked = conf.virtAlignPrec;
            cb_virtAlignSelected.IsChecked = conf.virtAlignSelected;
            cb_coeffVirtAdjust.IsChecked = conf.coeffVirtAdjust;
            cb_coeffVirtAuto.IsChecked = conf.coeffVirtAuto;


            cb_noaddEnd.IsChecked = conf.noAddEnd;
            cb_noaddAll.IsChecked = conf.noAddAll;

            cb_auto.IsChecked = conf.auto;
            coeffp = conf.dcoeffp;
            tb_dcoeffp.Text = coeffp.ToString(); //"0.#####");
            tb_dcoeffm.Text = conf.dcoeffm.ToString(); //  ("0.#####");
            conv = conf.dconvergence;
            tb_convergence.Text = conv.ToString(); //  ("0.######");
            tb_dconvdeltap.Text = conf.dconvdeltap.ToString(); //  ("0.######");
            tb_dconvdeltam.Text = conf.dconvdeltam.ToString(); //  ("0.######");

            tb_anti.Text = conf.danticonvergence.ToString(); //  ("0.#####");
            tb_antideltap.Text = conf.danticonvdeltap.ToString(); //  ("0.######");
            tb_antideltam.Text = conf.danticonvdeltam.ToString(); //  ("0.######");

            cb_link.IsChecked = conf.linkconv;

            prod = conf.LinkProduct;
            tb_prod.Text = prod.ToString("0.######");
            tb_prod.Visibility = conf.linkconv ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed; 
            l_prod.Text = conf.calcProduct(conf.dcoeffp, conf.dconvergence).ToString("0.######");
            tb_prod.IsEnabled = conf.linkconv;

            tb_serialp.Text = conf.serialp.ToString();
            tb_serialm.Text = conf.serialm.ToString();
            tb_serial.Text = conf.Serial.ToString();

            cb_oldAsZero.IsChecked = conf.oldAsZero;
            cb_coeffOldAuto.IsChecked = conf.CoeffOldAuto;
            tb_coeffOld.Text = conf.CoeffOld.ToString("0.######");
            tb_coeffAutoLevel.Text = conf.coeffOldAutoLevel.ToString(); 


           
          

        }

       

        public void record()
        {


            conf.lissage = cb_lissage.IsChecked.Value;
            conf.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            conf.reSort = cb_reSort.IsChecked.Value;

            conf.cumul = cb_cumul.IsChecked.Value;
            conf.noAdd = cb_noAdd.IsChecked.Value;
            conf.safe = Convert.ToInt32(tb_safe.Text);
            conf.coeffVirt = Convert.ToDecimal(tb_coeff.Text);

            conf.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            conf.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            conf.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            conf.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            conf.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            conf.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;

            conf.noAddEnd = cb_noaddEnd.IsChecked.Value;
            conf.noAddAll = cb_noaddAll.IsChecked.Value;

            conf.auto = cb_auto.IsChecked.Value;
            conf.dcoeffp = coeffp; // Convert.ToDecimal(tb_dcoeffp.Text);
            conf.dcoeffm = Convert.ToDecimal(tb_dcoeffm.Text);
            conf.dconvergence = conv; // Convert.ToDecimal(tb_convergence.Text);
            conf.dconvdeltap = Convert.ToDecimal(tb_dconvdeltap.Text);
            conf.dconvdeltam = Convert.ToDecimal(tb_dconvdeltam.Text);

            conf.danticonvergence = Convert.ToDecimal(tb_anti.Text);
            conf.danticonvdeltap = Convert.ToDecimal(tb_antideltap.Text);
            conf.danticonvdeltam = Convert.ToDecimal(tb_antideltam.Text);


            conf.linkconv = cb_link.IsChecked.Value;

            conf.serialp = Convert.ToInt32(tb_serialp.Text);
            conf.serialm = Convert.ToInt32(tb_serialm.Text);
            conf.Serial = Convert.ToInt32(tb_serial.Text);

            conf.oldAsZero = cb_oldAsZero.IsChecked.Value;
            conf.CoeffOldAuto = cb_coeffOldAuto.IsChecked.Value;

            conf.CoeffOld = Convert.ToDecimal(tb_coeffOld.Text);
            conf.coeffOldAutoLevel = Convert.ToInt32(tb_coeffAutoLevel.Text);

        }



        private void onchange2()
        {
            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeffT = Convert.ToDouble(tb_coeffT.Text);
                var coeff = Math.Pow(coeffT, (1.0 / (double)safe));
                tb_coeff.Text = coeff.ToString();
            }
            catch
            {
            }
        }

        private void tb_safe_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange();
        }

        private void tb_coeffT_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange2();
        }

        public void onchange()
        {



            //if (true == cb_coeffVirtAdjust.IsChecked)
            //{
            //    try
            //    {
            //        var safe = Convert.ToInt32(tb_safe.Text);
            //        var coeffEnabled = Convert.ToDecimal(parent.CoeffEnabled);
            //        var coeffVirt = Math.Pow((double)coeffEnabled, 1.0 / (safe + 1.0));
            //        tb_coeff.Text = coeffVirt.ToString();
            //    }
            //    catch
            //    {
            //    }
            //}

            //try
            //{
            //    var safe = Convert.ToInt32(tb_safe.Text);
            //    var coeff = Convert.ToDouble(tb_coeff.Text);
            //    var coeffT = Math.Pow(coeff, (double)safe);
            //    tb_coeffT.Text = coeffT.ToString("0.#####");
            //}
            //catch
            //{
            //}

        }

        private void cb_link_Click(object sender, RoutedEventArgs e)
        {
            tb_prod.IsEnabled = cb_link.IsChecked.Value;
            tb_prod.Visibility = cb_link.IsChecked.Value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed; 
          
        }


       
        private void tb_prod_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                prod = Convert.ToDecimal(tb_prod.Text);
                conv = conf.calcConv(coeffp, prod); 
                tb_convergence.Text = conv.ToString("0.######");
            }
            catch 
            {
                
                
            }
        }

        private void tb_dcoeffp_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                coeffp = Convert.ToDecimal(tb_dcoeffp.Text);
                prod = conf.calcProduct(coeffp, conv);
                tb_prod.Text = prod.ToString("0.######");


            }
            catch
            {
            }
            
        }

        private void tb_convergence_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                conv = Convert.ToDecimal(tb_convergence.Text);
                prod = conf.calcProduct(coeffp, conv);
                tb_prod.Text = prod.ToString("0.######");
            }
            catch
            {
            }
        }

        //private void calcProduct()
        //{
        //    try
        //    {
        //        var coeffp = Convert.ToDecimal(tb_dcoeffp.Text);
        //        var convergence = Convert.ToDecimal(tb_convergence.Text);
        //        tb_prod.Text = conf.calcProduct(coeffp, convergence).ToString("0.###");
        //    }
        //    catch
        //    {
        //    }
        //}

    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\Debug.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.Conf.Debug"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Debug" Height="300" Width="300">
    <Grid>
        <StackPanel Orientation ="Horizontal"  HorizontalAlignment="Center">
            <CheckBox Name="cb_rank" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Rang" Margin="5" Padding="2" />
            <CheckBox Name="cb_coeff" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Coeff" Margin="5" Padding="2" />
            <CheckBox Name="cb_zero" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Zero" Margin="5" Padding="2" />
            <Button Name="bt_apply"  Width="60"  VerticalAlignment="Center" Content="Appliquer" Click="bt_apply_Click"/>
            <CheckBox Name="cb_reset" Width="30"  VerticalAlignment="Center" ToolTip="Remise à 1 du coeff" Margin="5" Padding="2" />
        </StackPanel>
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\Debug.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.gen.Tuning;

namespace pdb.player.Vue.Conf
{
    /// <summary>
    /// Interaction logic for Debug.xaml
    /// </summary>
    public partial class Debug : Window
    {
        ConfAlbumSort conf; 
        public Debug()
        {
            InitializeComponent();            
        }

        public Debug(ConfAlbumSort conf) : this()
        {
            this.conf = conf;
            Loaded += new RoutedEventHandler(Debug_Loaded);
        }

        void Debug_Loaded(object sender, RoutedEventArgs e)
        {
            cb_coeff.IsChecked = conf.correcMainCoeff;
            cb_rank.IsChecked = conf.correcMainRank;
            cb_zero.IsChecked = conf.correcMainZero;
            cb_reset.IsChecked = conf.reset; 
        }

        private void bt_apply_Click(object sender, RoutedEventArgs e)
        {
            conf.correcMainCoeff = cb_coeff.IsChecked.Value;
            conf.correcMainRank = cb_rank.IsChecked.Value;
            conf.correcMainZero = cb_zero.IsChecked.Value;
            conf.reset = cb_reset.IsChecked.Value; 

            App.go(); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.IO;

namespace pdb.util
{
    public class HistoValue
    {
        char SEP = '|';
        public decimal coeff;
        public decimal delta;
        public decimal accel;
        public decimal conv;
        //private HistoValue(string line)
        //{
        //    var tab = line.Split(SEP);
        //    int count = tab.GetLength(0);
        //    if (count >= 1 && !string.IsNullOrEmpty(tab[0]))
        //        coeff = Convert.ToDecimal(tab[0]);
        //    if (count >= 2 && !string.IsNullOrEmpty(tab[1]))
        //        delta = Convert.ToDecimal(tab[1]) / 1000m;
        //    if (count >= 3 && !string.IsNullOrEmpty(tab[2]))
        //        conv = Convert.ToDecimal(tab[2]) / 1000m;
        //}

        public HistoValue(string line, HistoValue last)
        {
            var tab = line.Split(SEP);
            int count = tab.GetLength(0);
            string str = "";
            if (count >= 1)
            {
                str = tab[0];
                if (!string.IsNullOrEmpty(str))
                    coeff = Convert.ToDecimal(str);
                else if (last != null)
                    coeff = last.coeff;
            }
            if (count >= 2)
            {
                str = tab[1];
                if (!string.IsNullOrEmpty(str))
                    delta = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    delta = last.delta;
            }
            if (count >= 3)
            {
                str = tab[2];
                if (!string.IsNullOrEmpty(str))
                    accel = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    accel = last.accel;
            }

            if (count >= 4)
            {
                str = tab[3];
                if (!string.IsNullOrEmpty(str))
                    conv = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    conv = last.conv;
            }
        }

        public HistoValue(decimal coeff, decimal delta, decimal accel, decimal conv)
        {
            this.coeff = coeff;
            this.delta = delta;
            this.accel = accel;
            this.conv = conv;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            write(sb);
            return sb.ToString();
        }

        public void write(ITextWriter sb)
        {
            var v = Math.Round(coeff, 12);
            var sc = v.ToString();
            var v2 = Math.Round(1000m * delta, 10);
            var sc2 = v2.ToString();

            var v3 = Math.Round(1000m * accel, 10);
            var sc3 = v3.ToString();

            var v4 = Math.Round(1000m * conv, 10);
            var sc4 = v4.ToString();

            sb.Append(sc);
            sb.Append(SEP);
            sb.Append(sc2);
            sb.Append(SEP);
            sb.Append(sc3);
            sb.Append(SEP);
            sb.AppendLine(sc4);
        }

        private static decimal getTruncate(decimal v)
        {
            return Math.Round(1000m * v, 10);
        }

        public void writeDiff(ITextWriter sb, HistoValue last)
        {


            var v = Math.Round(coeff, 12);
            var sc = v.ToString();
            sb.Append(sc);

            sb.Append(SEP);
            var v2 = getTruncate(delta);
            if (last == null || v2 != getTruncate(last.delta))
            {
                var sc2 = v2.ToString();
                sb.Append(sc2);
            }

            sb.Append(SEP);
            var v3 = getTruncate(accel);
            if (last == null || v3 != getTruncate(last.accel))
            {
                var sc3 = v3.ToString();
                sb.Append(sc3);
            }
            sb.Append(SEP);
            var v4 = getTruncate(conv);
            if (last == null || v4 != getTruncate(last.conv))
            {
                var sc4 = v4.ToString();
                sb.Append(sc4);
            }
            sb.AppendLine();

        }
    }
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }

    //public class HistoStat
    //{
    //    public HistoStatItem min;
    //    public HistoStatItem max;

    //    public HistoStat()
    //    {
    //        min = new HistoStatItem(int.MaxValue);
    //        max = new HistoStatItem(-1);
    //    }
    //    public HistoStat(decimal val)
    //    {
    //        min = new HistoStatItem(val);
    //        max = new HistoStatItem(val);
    //    }

    //    //private string desc(decimal d)
    //    //{
    //    //    if (d < 0)
    //    //        return "";
    //    //    if (d >= int.MaxValue)
    //    //        return "";
    //    //    return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
    //    //}

    //    public override string ToString()
    //    {
    //        //return string.Format("{0}({1}) {2}({3})", desc(min.absolute), desc(min.relative), desc(max.absolute), desc(max.relative)); 
    //        return string.Format("{0} {1}", min, max);
    //    }
    //}

    //public class HistoStatItem
    //{
    //    public decimal relative;
    //    public decimal absolute;
    //    public HistoStatItem()
    //    {
    //        relative = -1;
    //        absolute = -1;
    //    }
    //    public HistoStatItem(decimal val)
    //    {
    //        relative = val;
    //        absolute = val;
    //    }

    //    public static string desc(decimal d)
    //    {
    //        if (d < 0)
    //            return "";
    //        if (d >= int.MaxValue)
    //            return "";
    //        return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
    //    }

    //    public override string ToString()
    //    {
    //        var sb = new StringBuilder();
    //        sb.Append(desc(absolute));
    //        if (absolute != relative)
    //        {
    //            sb.Append("(");
    //            sb.Append(desc(relative));
    //            sb.Append(")");
    //        }
    //        return sb.ToString();
    //    }


    //}

    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }

        public ConfMedianne(ConfMedianne o, bool raz)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main, raz);
            _min = new ConfMedianneVirt(o._min, raz);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            buildb("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt == 1m)
            {
                _main.calcAuto(coeffPrisEncompte);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true);
                }
                else
                {
                    _main.calcAuto(false);
                    _min.calcAuto(false);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";

        // const decimal EPSILON = 0.000001m;// 0.001m;
        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;

        //private bool firstSave = true;
        //private static bool modeDiff;
        //public static bool ModeDiff
        //{
        //    get { return modeDiff; }
        //    set
        //    {
        //        modeDiff = value;
        //    }
        //}

        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;
        public decimal dcoeffp;
        public decimal dcoeffm;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;
        public decimal coeffElastique1 = 1m;
        public decimal coeffElastique2 = 1m;
        /// <summary>
        /// atténuation progressive des coeffs
        /// </summary>
        public decimal dconvergence;
        public decimal dconvergence0;
        public decimal dconvergence01;

        public decimal dconvdeltap = 1m;
        public decimal dconvdeltam = 1m;

        /// <summary>
        /// anti atténuation
        /// </summary>
        public decimal danticonvergence = 1m;
        public decimal danticonvergence0;
        public decimal danticonvergence01;

        public decimal danticonvdeltap = 1m;
        public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public int coeffOldAutoLevel;

        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.dcoeffp, this.dconvergence);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.dconvergence = calcConv(this.dcoeffp, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.dconvergence;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }


        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        private decimal epsilon = 0.001m;

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            dcoeffp = o.dcoeffp;
            dcoeffm = o.dcoeffm;
            dconvergence = o.dconvergence;
            dconvdeltap = o.dconvdeltap;
            dconvdeltam = o.dconvdeltam;
            danticonvergence = o.danticonvergence;
            danticonvdeltap = o.danticonvdeltap;
            danticonvdeltam = o.danticonvdeltam;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;
            serialElastique = o.serialElastique;
            coeffElastique1 = o.coeffElastique1;
            coeffElastique2 = o.coeffElastique2;

            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            dconvergence0 = o.dconvergence0;
            dconvergence01 = o.dconvergence01;
            danticonvergence0 = o.danticonvergence0;
            danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);
            builddec("dcoeffp", v => dcoeffp = v);
            builddec("dcoeffm", v => dcoeffm = v);
            builddec("dconvergence", v => dconvergence = v);
            builddec("dconvergence0", v => dconvergence0 = v);
            builddec("dconvergence01", v => dconvergence01 = v);
            builddec("dconvdeltap", v => dconvdeltap = v);
            builddec("dconvdeltam", v => dconvdeltam = v);

            builddec("danticonvergence", v => danticonvergence = v);
            builddec("danticonvergence0", v => danticonvergence0 = v);
            builddec("danticonvergence01", v => danticonvergence01 = v);
            builddec("danticonvdeltap", v => danticonvdeltap = v);
            builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);
            builddec("coeffElastique1", v => coeffElastique1 = v);
            builddec("coeffElastique2", v => coeffElastique2 = v);
            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    foreach (var line in File.ReadAllLines(Path))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        var _nevw = new HistoValue(line, last);
                        histo.Add(_nevw);
                        last = _nevw;
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();

                    foreach (var line in File.ReadAllLines(PathDiff))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;

                        var _nevw = new HistoValue(line, last);
                        histoDiff.Add(_nevw);
                        last = _nevw;

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 0m;
                    if (dcoeffp > 0)
                        rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }

        public void checkCoeffOld()
        {
            if (coeffOldAuto)
            {
                coeffOld = (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("serial", _nbSameDirection);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);
            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);
            write("coeffElastique1", coeffElastique1);
            write("coeffElastique2", coeffElastique2);
            write("fdata", fdata);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);

            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);
            write("dcoeffp", dcoeffp);
            write("dcoeffm", dcoeffm);
            write("dconvergence", dconvergence);
            write("dconvergence0", dconvergence0);
            write("dconvergence01", dconvergence01);
            write("dconvdeltap", dconvdeltap);
            write("dconvdeltam", dconvdeltam);

            write("danticonvergence", danticonvergence);
            write("danticonvergence0", danticonvergence0);
            write("danticonvergence01", danticonvergence01);
            write("danticonvdeltap", danticonvdeltap);
            write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);



            write("coeffOld", coeffOld);
            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                //var v = Math.Round(histo[i].coeff, 10);
                //var sc = v.ToString();
                //var v2 = Math.Round(1000m * histo[i].delta, 10);
                //var sc2 = v2.ToString();

                //var v3 = Math.Round(1000m * histo[i].conv, 10);
                //var sc3 = v3.ToString();

                //sb.Append(sc);
                //sb.Append("|");
                //sb.Append(sc2);
                //sb.Append("|");
                //sb.AppendLine(sc3);

                if (i >= indexDiff)
                {
                    histo[i].writeDiff(sbDiff, last);
                    //sbDiff.Append(sc);
                    //sbDiff.Append("|");
                    //sbDiff.Append(sc2);
                    //sbDiff.Append("|");
                    //sbDiff.AppendLine(sc3);
                }
                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal acceleration = 0;
        public decimal danticonvergenceMin
        {
            get
            {
                // return danticonvergence01;
                return epsilon;
                decimal ret = 1;
                try
                {
                    var aux = epsilon / dcoeffp;
                    if (aux < ret)
                        ret = aux;
                }
                catch
                {
                }
                return ret;
            }
        }

        public void calcAuto(bool selectedByCoeff)
        {


            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;

            var ecart0 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));

            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta;
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff)
                {
                    _nbSameDirection = 0;
                    _nbAlt++;
                    _nbAltHisto++;
                    _nbElastique--;
                    _nbElastique2 -= coeffElastique2;
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;
                    _nbElastique += coeffElastique1;
                    _nbElastique2++;
                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                    }
                    else
                    {
                        _nbSameDirectionBox++;
                    }
                }

                if (selectedByCoeff)
                {
                    _nbSameDirection--;
                }
                else
                {
                    _nbSameDirection++;
                }
            }

            if (!auto)
                return;

            var lastProduct = linkProduct;
            var rr = 1m;
            if (dcoeffp > 0)
                rr = dcoeffm / dcoeffp;

            var c0 = dcoeffp;
            var rrc = 1m;
            if (danticonvergence0 > 0)
                rrc = dconvergence0 / danticonvergence0;

            acceleration = dcoeffp * danticonvergence;
            if (dcoeffp > 0 && acceleration < epsilon)
            {
                //danticonvergence = epsilon / dcoeffp;
                //dconvergence = rrc * danticonvergence;
                acceleration = epsilon;
            }

            // si le delta ne bouge pas on diminue la convergence 

            /// au debut dconvergence à effet  fort 0.9 doit arriver à 0.999
            /// // quand j'applique la convergence, je fait baisser son effet

            if (last.HasValue)
            {
                var aux = dconvergence;
                //if (last != selectedByCoeff)
                if (_nbAlt > serialAlt || _nbElastique < -serialElastique || _nbElastique2 < -serialElastique)
                {
                    lastDelta = false;
                    //if (selectedByCoeff)
                    //{

                    //dcoeffp *= dconvergence;
                    //dcoeffm *= dconvergence;
                    //if (dcoeffp < EPSILON) dcoeffp = EPSILON;
                    //if (dcoeffm < EPSILON) dcoeffm = EPSILON;

                    // la convergence est maintenant directement le % de baisse
                    //0.1 -> 0.9  ==> 1.1

                    var limit = dcoeffp - epsilon * rrc;

                    if (limit < 0 && dcoeffp >= 0)
                        limit = dcoeffp;
                    var r = 1 + dconvergence;
                    dcoeffp /= r;
                    dcoeffm /= r;

                    if (limit < dcoeffp)
                    {
                        dcoeffp = limit;
                        //  dconvergence = epsilon / (c0 - epsilon); 
                        if (rr > 0m) dcoeffm = rr * dcoeffp;
                    }

                    if (dcoeffp < epsilon)
                    { dcoeffp = epsilon; if (rr > 0m) dcoeffm = rr * dcoeffp; }
                    if (dcoeffm < epsilon)
                    { dcoeffm = epsilon; if (rr > 0m) dcoeffp = dcoeffm / rr; }



                    //   _nbSameDirection = 0;
                    //  lastAutoDirection = null;



                    if (_linkconv)
                        calcConv();
                    else
                    {

                        //  var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        // dconvergence /= (1 + dconvdeltam); // 0.09 // 0.81
                        //  dconvergence = 1 - delta; // 0.9 -> 0.91 // 0.1-> 0.19
                    }


                    // danticonvergence /= (1 + danticonvdeltam);
                    //var delta = 1 - danticonvergence; 
                    //delta *= (1- danticonvdeltam) ;
                    //danticonvergence = delta - 1; 
                    // if (danticonvergence < 1m) danticonvergence = 1;

                    //delta = danticonvergence - 1; // 0.1
                    //delta *= danticonvdeltam;  //0.09; 
                    //    danticonvergence = 1+delta; // 1.1 -> 1.09
                    // }



                }
                else
                {
                    bool applyanti = false;
                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    else if (_nbElastique > serialElastique)
                        applyanti = true;
                    else if (_nbElastique2 > serialElastique)
                        applyanti = true;
                    if (applyanti)
                    {
                        lastDelta = true;
                        var limit = dcoeffp + epsilon;
                        //if (dcoeffp * danticonvergence < epsilon)
                        //{
                        //    danticonvergence = epsilon / dcoeffp; 
                        //}
                        dcoeffp *= (1 + danticonvergence);
                        dcoeffm *= (1 + danticonvergence);
                        //   danticonvergence *= (1 + danticonvdeltap);



                        if (danticonvergence > 0 && limit > dcoeffp)
                        {
                            dcoeffp = limit;
                        }

                        if (rr > 0)
                            dcoeffm = rr * dcoeffp;

                    }
                    else
                        lastDelta = null;
                    if (_linkconv)
                        calcConv();
                    else if (applyanti)
                    {
                        //   dconvergence *= (1 + dconvdeltap);
                        //   var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        //var delta = 1 - dconvergence; //0.1 -> 0.9  0.5->0.5
                        //delta /= (1+ dconvdeltap); // 0.81 0.25
                        //dconvergence = 1 - delta;  // 0.18 0.75
                        // dconvergence *= dconvdeltap; // 0.11 // 0.99
                        //    dconvergence = 1 - delta; // 0.9 -> 0.89 // 0.01
                        if (dconvergence > 1 - epsilon)
                            dconvergence = 1 - epsilon;
                        if (dconvergence < epsilon)
                            dconvergence = epsilon;
                    }

                }

                bool onAugmente = lastDelta.HasValue && (lastDelta_ == null || lastDelta_ == lastDelta);


                if (c0 == dcoeffp || !onAugmente)
                {

                    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                    if (ecart1 < ecart0)
                    {

                        danticonvergence /= (1 + danticonvdeltam);
                        if (danticonvergence < danticonvergence01)
                            danticonvergence = danticonvergence01;
                        dconvergence /= (1 + dconvdeltam);
                        if (dconvergence < dconvergence01)
                            dconvergence = dconvergence01;
                    }
                }
                else
                {
                    dconvergence *= (1 + dconvdeltap);
                    if (dconvergence > dconvergence0)
                        dconvergence = dconvergence0;
                    danticonvergence *= (1 + danticonvdeltap);
                    if (danticonvergence > danticonvergence0)
                        danticonvergence = danticonvergence0;
                }


                //if (dcoeffp > 0 && dcoeffp * danticonvergence < epsilon)
                //{
                //    danticonvergence = epsilon / dcoeffp;
                //    dconvergence = rrc * danticonvergence;
                //}

                acceleration = dcoeffp * danticonvergence;
                if (dcoeffp > 0 && acceleration < epsilon)
                {
                    //danticonvergence = epsilon / dcoeffp;
                    //dconvergence = rrc * danticonvergence;
                    acceleration = epsilon;
                }

                misc.log("convergence {0:0.##}->{1:0.######}", c0, dcoeffp);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, dconvergence);
            }

            if (selectedByCoeff)
            {
                ///
                // 1.01 -0.2
                if (coeffVirt - dcoeffm < 1)
                {
                    dcoeffm = coeffVirt - 1; // ==0.01
                    if (rr != 0)
                        dcoeffp = dcoeffm / rr;
                }
                makeDelta(false, dcoeffm);
            }
            else
                makeDelta(true, dcoeffp);








        }

        public decimal CoeffT { get { return (decimal)Math.Pow(coeffVirt, safe); } }
        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }

        private void makeDelta(bool sens, decimal delta)
        {

            try
            {
                decimal coeffT = coeffVirt; // CoeffT;
                while (histo.Count >= NB_HISTO)
                    histo.RemoveAt(0);


                string montee = sens ? "up" : "down";
                var c0 = coeffT;
                if (sens)
                {
                    coeffT += delta;
                }
                else
                {
                    coeffT -= delta;
                }
                if (coeffT < 1)
                {
                    coeffT = 1;
                }

                // var coeff = getCoeff(coeffT); // (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

                misc.log("{0} {1:0.######} {2:0.######}->{3:0.######}", montee, delta, c0, coeffT);

                coeffVirt = coeffT; // coeff;

                checkCoeffOld();
                histo.Add(new HistoValue(coeffVirt, delta, acceleration, danticonvergence));
            }
            catch
            {
            }



        }

        //public HistoStat calcStat(selectedCoeff motif, int nb)
        //{
        //    var stat = new HistoStat();
        //    int _nb = 0;
        //    int count = histo.Count;
        //    for (int i = count - 1; i >= 0; i--)
        //    {
        //        var h = histo[i];

        //        // min 
        //        if (h < stat.min.absolute)
        //            stat.min.absolute = h;
        //        // calcul du plus faible qui n'a pas fonctionné

        //        if (h < stat.min.relative)
        //        {
        //            if (i + 1 < count)
        //            {
        //                var suivant = histo[i + 1];
        //                if (suivant < h)
        //                    stat.min.relative = h;
        //            }
        //            else
        //            {
        //                if (motif > selectedCoeff.noCoeff || motif == selectedCoeff.none)
        //                    stat.min.relative = h;
        //            }
        //        }

        //        //max
        //        if (h > stat.max.absolute)
        //            stat.max.absolute = h;
        //        // calcul du max qui fonctionne
        //        if (h > stat.max.relative)
        //        {
        //            if (i + 1 < count)
        //            {
        //                var suivant = histo[i + 1];
        //                if (suivant > h)
        //                    stat.max.relative = h;
        //            }
        //            else
        //            {
        //                if (motif <= selectedCoeff.noCoeff)
        //                    stat.max.relative = h;
        //            }
        //        }

        //        _nb++;
        //        if (_nb >= nb)
        //            break;
        //    }

        //    return stat;
        //}

        //private decimal calcMin(int nb, bool sens)
        //{
        //    decimal min = CoeffT;
        //    int _nb = 0;
        //    int count = histo.Count;
        //    for (int i = count - 1; i >= 0; i--)
        //    {
        //        var h = histo[i];

        //        if ((sens && h > min) || (!sens && h < min))
        //        {
        //            // calcul du max qui fonctionne
        //            if (sens)
        //            {
        //                if (i + 1 < count)
        //                {
        //                    var suivant = histo[i + 1];
        //                    if (suivant > h)
        //                        min = h;
        //                }
        //            }
        //            // calcul du plus faible qui n'a pas fonctionné
        //            else
        //                if (i + 1 < count)
        //                {
        //                    var suivant = histo[i + 1];
        //                    if (suivant < h)
        //                        min = h;
        //                }
        //        }

        //        _nb++;
        //        if (_nb >= nb)
        //            break;
        //    }
        //    return min;
        //}

        //public decimal coeffTMin(int nb)
        //{
        //    return calcMin(nb, false);
        //}

        //public decimal coeffTMax(int nb)
        //{
        //    return calcMin(nb, true);
        //}



    }
    public class CalcMedianne
    {

        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }



        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }



        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10(rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var dx = medianne - index;


            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;


        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;
using pdb.obj;
using System.Text.RegularExpressions;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        const decimal EPSILON = 0.001m * 0.001m; 
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;

        public decimal getSt(decimal classementValueLight)
        {
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                //      1       10      50      99
                //      0.99    0.9     0.5     0.01
                //1.    0.01    0.1     0.5     0.99
                //2.    0.02    0.19    0.75    0.9999
                //10    0.095   0.65    0.999   0.99999999999
                //0.5   0.005   0.05    0.29    0.9
                var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                if (delta != 1)
                    delta = pdb.util.Math.Pow(delta, stackPower);
                delta = 1 - delta;

                if (delta < 0.001m)
                    delta = 0.001m;

                classementValueLightSt = classementValueLight / delta;
            }
            else
                classementValueLightSt = classementValueLight;

            return classementValueLightSt;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLight0St
        {
            get
            {
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero { get { return classementValueLightZero; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(classementValueLightZero); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                var status = "";
                if (_virtual)
                    status = "v";
                if (_virtualByArtist)
                    status = "va";
                logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {

            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceClassementComparer(false));
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }
        public void InvalidateMain()
        {
            if (selectedCoeff == util.selectedCoeff.main)
                selectedCoeff = util.selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        DecimalIndex _med0 = new DecimalIndex();
        DecimalIndex med = new DecimalIndex();


        private decimal makeSort(List<Piece> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
               
                #region calcul virtuel

                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, false, ref i0);

                var med = AlbumMedianne.getMedianneLight(new List<Piece>(list), mode, true);
                classementValueLight = med.d;

                #endregion


                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true));
                    Piece nextZero1 = null;
                    Piece nextZero2 = null;

                    Piece min1 = null;
                    Piece min2 = null;
                    Piece min = null;
                    decimal _min1 = int.MaxValue;
                    decimal _min2 = int.MaxValue;
                    decimal _minzero1 = int.MaxValue;
                    decimal _minzero2 = int.MaxValue;
                    bool realZero = false;
                    foreach (Piece p in list)
                    {
                        var v1 = p.VirtualClassement;
                        var v2 = p.VirtualClassement2;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v1 < _minzero1)
                                {
                                    _minzero1 = v1;
                                    nextZero1 = p;
                                    if (v1 == 0)
                                        realZero = true;
                                }
                            }

                            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v2 < _minzero2)
                                {
                                    _minzero2 = v2;
                                    nextZero2 = p;
                                    if (v2 == 0)
                                        realZero = true;
                                }

                            }



                            if (v1 > 0 && v1 < _min1)
                            {
                                _min1 = v1;
                                min1 = p;
                            }

                            if (v2 > 0 && v2 < _min2)
                            {
                                _min2 = v2;
                                min2 = p;
                            }
                        }
                    }
                    decimal _min = 0;
                    if (_min1 <= _min2)
                    {
                        min = min1;
                        _min = _min1;
                    }
                    else
                    {
                        min = min2;
                        _min = _min2;
                    }

                    Piece nextZero = null;
                    decimal _minzero = int.MaxValue;
                    if (_minzero1 <= _minzero2)
                    {
                        nextZero = nextZero1; _minzero = _minzero1;
                    }
                    else
                    {
                        nextZero = nextZero2; _minzero = _minzero2;
                    }

                    if (nextZero != null)
                    {

                        if (realZero)
                        {
                            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                            // j'applique le seuil que s'il est inférieur à la médiane
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    classementValueLight = _min;
                                    if (real)
                                    {
                                        Next = min;

                                        if (Next.CoeffVirtuel > 1 + EPSILON)
                                            selectedCoeff = selectedCoeff.main;
                                        if (_min < _min1 - EPSILON)
                                            selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                    }
                                }
                            }
                            else
                            {
                                if (real)
                                {

                                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                    Next = nextZero;

                                }
                            }
                        }
                        else
                        {
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    classementValueLight = _min;
                                    if (real)
                                    {
                                        Next = min;
                                        if (Next.CoeffVirtuel > 1 + EPSILON)
                                            selectedCoeff = selectedCoeff.main;
                                        if (_min < _min1 - EPSILON)
                                            selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                    }
                                }

                            }
                            else if (_minzero < classementValueLight)
                            {
                                if (real)
                                {
                                    Next = nextZero;
                                    classementValueLight = _minzero;

                                    if (Next.CoeffVirtuel > 1 + EPSILON)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_minzero < _minzero1 - EPSILON)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                            }

                            else
                            {
                                classementValueLight = _min;
                                if (real)
                                {
                                    Next = min;

                                    //  var p = list[med.index];
                                    if (Next.CoeffVirtuel > 1 + EPSILON)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                }

                            }
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        if (real)
                            Next = min;
                        if (min != null)
                        {
                            classementValueLight = _min;

                        }

                    }

                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;

          
            try
            {
           
                selectedCoeff = util.selectedCoeff.noCoeff;

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                for (int i = 0; i < count; i++)
                {
                    list[i].eraseInfoMedianne();
                }

                
                decimal offset = Album.conf.AlbumMoyOffset;
             


                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                classed = false;
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }
                //misc.log("make sort Duration {0}", name); 
                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;
                #region calcul brut
                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                this.med = AlbumMedianne.getMedianne(new List<Piece>(list), medianne);


                _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), mode0, false);
               

                classementValue = this.med.d;
                if (classementValue > 0m)
                    list[this.med.index].Medianne = true;

                #endregion




               






                #endregion
                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion

                classementValueLightZero = makeSort(list, mode0, false);
                classementValueLight = makeSort(list, mode, true);

                #endregion
                //return; 
                //int i0 = 0;
                //AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, false, ref i0);

                //var med = AlbumMedianne.getMedianneLight(new List<Piece>(list), mode, true);
                //classementValueLight = med.d;

                //#endregion

                ////equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                ////moyenne = Piece.getClassementEquiv(classMoy);
                //var modeMin = mode.cmpMin;


                //if (modeMin == util.modeMin.orphelin)
                //{
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;

                //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                //        {
                //            if (v < _min)
                //            {
                //                _min = v;
                //                min = p;
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        Next = min;
                //        _min = min.VirtualClassement2;
                //        if (_min > classementValueLight)
                //            classementValueLight = _min;
                //    }
                //}
                //else if (modeMin == util.modeMin.toujours)
                //{
                //    if (mode.Main.oldAsZero)
                //        list.Sort(new PieceClassementComparer(true));
                //    Piece nextZero1 = null;
                //    Piece nextZero2 = null;

                //    Piece min1 = null;
                //    Piece min2 = null;
                //    Piece min = null;
                //    decimal _min1 = int.MaxValue;
                //    decimal _min2 = int.MaxValue;
                //    decimal _minzero1 = int.MaxValue;
                //    decimal _minzero2 = int.MaxValue;
                //    bool realZero = false;
                //    foreach (Piece p in list)
                //    {
                //        var v1 = p.VirtualClassement;
                //        var v2 = p.VirtualClassement2;

                //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                //        {
                //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                //            {
                //                if (v1 < _minzero1)
                //                {
                //                    _minzero1 = v1;
                //                    nextZero1 = p;
                //                    if (v1 == 0)
                //                        realZero = true;
                //                }
                //            }

                //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                //            {
                //                if (v2 < _minzero2)
                //                {
                //                    _minzero2 = v2;
                //                    nextZero2 = p;
                //                    if (v2 == 0)
                //                        realZero = true;
                //                }

                //            }



                //            if (v1 > 0 && v1 < _min1)
                //            {
                //                _min1 = v1;
                //                min1 = p;
                //            }

                //            if (v2 > 0 && v2 < _min2)
                //            {
                //                _min2 = v2;
                //                min2 = p;
                //            }
                //        }
                //    }
                //    decimal _min = 0;
                //    if (_min1 <= _min2)
                //    {
                //        min = min1;
                //        _min = _min1;
                //    }
                //    else
                //    {
                //        min = min2;
                //        _min = _min2;
                //    }

                //    Piece nextZero = null;
                //    decimal _minzero = int.MaxValue;
                //    if (_minzero1 <= _minzero2)
                //    {
                //        nextZero = nextZero1; _minzero = _minzero1;
                //    }
                //    else
                //    {
                //        nextZero = nextZero2; _minzero = _minzero2;
                //    }

                //    if (nextZero != null)
                //    {

                //        if (realZero)
                //        {
                //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                //            // j'applique le seuil que s'il est inférieur à la médiane
                //            if (_min < classementValueLight)
                //            {
                //                if (min != null)
                //                {
                //                    Next = min;
                //                    classementValueLight = _min;
                //                    if (Next.CoeffVirtuel > 1)
                //                        selectedCoeff = selectedCoeff.main;
                //                    if (_min < _min1)
                //                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                //                }
                //            }
                //            else
                //            {
                //                //  var p = list[med.index];
                //                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                //                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                //                Next = nextZero;
                //                //if (Next.CoeffVirtuel > 1)
                //                //    selectedCoeff = selectedCoeff.main; 
                //                //if (_min < _min1)
                //                //    selectedCoeff = selectedCoeff.min; 
                //            }
                //        }
                //        else
                //        {
                //            if (_min < classementValueLight)
                //            {
                //                if (min != null)
                //                {
                //                    Next = min;
                //                    classementValueLight = _min;

                //                    if (Next.CoeffVirtuel > 1)
                //                        selectedCoeff = selectedCoeff.main;
                //                    if (_min < _min1)
                //                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                //                }

                //            }
                //            else if (_minzero < classementValueLight)
                //            {
                //                Next = nextZero;
                //                classementValueLight = _minzero;

                //                if (Next.CoeffVirtuel > 1)
                //                    selectedCoeff = selectedCoeff.main;
                //                if (_minzero < _minzero1)
                //                    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                //            }

                //            else
                //            {
                //                Next = min;
                //                classementValueLight = _min;
                //                //  var p = list[med.index];
                //                if (Next.CoeffVirtuel > 1)
                //                    selectedCoeff = selectedCoeff.main;
                //                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                //                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                //            }
                //        }
                //    }
                //    else
                //    {
                //        // tous notés => on prend le plus faible
                //        Next = min;
                //        if (min != null)
                //        {
                //            classementValueLight = _min;
                //            // if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                //            //if (Next.CoeffVirtuel > 1)
                //            //    selectedCoeff = selectedCoeff.main; 
                //            //if (_min < _min1)
                //            //    selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                //        }

                //    }

                //}

                ////if (modeMin > modeMin.non)
                ////{
                ////    int nb = 0;
                ////    Piece min = null;
                ////    decimal _min = int.MaxValue;
                ////    foreach (Piece p in list)
                ////    {
                ////        var v = p.RapportClassement;
                ////        if (v > 0 && !p.Enabled)
                ////            nb++;
                ////        if (modeMin == util.modeMin.orphelin || v > 0)
                ////        {
                ////            if (p.Enabled && FileRegister.Exist(p.Location))
                ////            {

                ////                if (v < _min)
                ////                {
                ////                    _min = v;
                ////                    min = p;
                ////                }
                ////            }
                ////        }
                ////    }

                ////    if (min != null)
                ////    {
                ////        _min = min.VirtualClassement;
                ////        if (nb > 0)
                ////            _min *= (decimal)nb / (decimal)count;
                ////        if (modeMin == modeMin.toujours || _min > classementValueLight)
                ////            classementValueLight = _min;
                ////    }


                ////}
                //// equivLight = Piece.getClassementEquiv(classementValueLight);

                ////  sortDone = true;


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }

        public void consolidSelectedCoeff()
        {
            if (selectedCoeff == selectedCoeff.main)
            {
                if (rankZero == RankSt)
                    selectedCoeff = selectedCoeff.noCoeff;
            }
        }

        public void mustRefresh()
        {
            build = false;
            //   sortDone = false;
           // selectionDone = false;
            atLeastOneEnabled = false;
            _tracksSortByClassement = null;

        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
      //  private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;
            //if (selectionDone)
            //    return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
           // selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;
using pdb.gen.Tuning;
using Math = pdb.util.Math; 

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IList<Piece> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        //{
        //    var _list = new List<decimal>();
        //    foreach (object o in list)
        //    {
        //        _list.Add(Convert.ToDecimal(o));
        //    }
        //    return getMedianne(_list, coeffMedianne);
        //}

        //public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        //{
        //    return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        //}

        //public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        //{
        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {


        //        var _zero = mode.zero;
        //        var medianne = getMedianne_(list, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;

        //        if (list.Count == 1)
        //            return ret0;

        //        if (mode.safe == 0)
        //        {
        //            return calcmedianneVirt(list, mode, 0, 0);
        //        }

        //        int indexV = 0;
        //        int nbAdd = 0;

        //        int count = list.Count;

        //        if (mode.safe > 0)
        //        {

        //            int i0 = count - 1;
        //            int _nbNoAdd = 0;

        //            for (int i = 0; i < count; i++)
        //            {
        //                if (list[i] <= _zero)
        //                {
        //                    i0 = i;
        //                    _nbNoAdd = count - i0;
        //                    break;
        //                }
        //            }
        //            if (i0 == 0)
        //                return ret0;

        //            //for (int i00 = 1; i00 <= i0; i00++)
        //            //{
        //            //    decimal coeff = (decimal)i00 / (decimal)i0;
        //            List<decimal> _list = new List<decimal>(list);
        //            //for (int i = i00; i < count; i++)
        //            //    _list[i] = 0m;
        //            //liste partielle originale
        //            //  List<decimal> _list0 = new List<decimal>(_list);
        //            int _count = System.Math.Min(count, i0 + mode.safe);
        //            decimal[] virt = new decimal[_count];
        //            _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
        //            if (mode.noAdd)
        //            {

        //                decimal _coeff = 1m;
        //                for (int j = _nbNoAdd - 1; j >= 0; j--)
        //                {
        //                    if (j < count)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        _list[j] = _list[j] * _coeff;
        //                    }
        //                }
        //            }
        //            else if (mode.lissage || mode.removeEpsilon || mode.cumul)
        //            {
        //                for (int i = 0; i < i0; i++)
        //                {
        //                    decimal _coeff = 1m;
        //                    decimal _base = _list[i];
        //                    for (int j = i + 1; j < _count; j++)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                    }
        //                }
        //            }
        //            else
        //            {
        //                decimal courant = _list[0];
        //                for (int i = 1; i < _count; i++)
        //                {
        //                    if (_list[i] <= _zero)
        //                    {
        //                        courant /= mode.coeffVirt;
        //                        virt[i] = courant;
        //                    }
        //                    else
        //                        courant = _list[i];
        //                }
        //            }

        //            decimal value = int.MaxValue;
        //            int ii = 0;
        //            if (mode.noAdd)
        //            {
        //                //for (ii = 1; ii < count && ii < _count; ii++)
        //                //{
        //                //    var calc = virt[ii];
        //                //    if (calc > 0m)
        //                //        list[ii] = calc;
        //                //}
        //            }
        //            else
        //            {
        //                for (ii = 1; ii < count && ii < _count; ii++)
        //                {
        //                    value = _list[ii];
        //                    var calc = virt[ii];
        //                    if (value < calc)
        //                    {
        //                        if (mode.lissage || value <= _zero)
        //                        {
        //                            if (value <= _zero)
        //                                nbAdd++;
        //                            value = calc;
        //                            _list[ii] = value;
        //                        }

        //                    }
        //                    else
        //                        indexV = ii;
        //                }
        //                if (mode.removeEpsilon)
        //                {
        //                    // j'ai 5 virtuel alors que j'ai deux safe
        //                    ///xx---
        //                    int nb = 0;
        //                    for (int i = indexV + 1; i < _count; i++)
        //                    {
        //                        nb++;
        //                        if (nb <= mode.safe)
        //                            continue;
        //                        _list[i] = 0m;
        //                    }

        //                }
        //                if (mode.removeFirst)
        //                {
        //                    for (int i = 0; i < nbAdd; i++)
        //                    {
        //                        _list[i] = 0m;
        //                    }
        //                }
        //            }

        //            for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //                pieces[i].setClassementVirtuel(_list[i]);

        //            if (mode.deleteFirst)
        //            {
        //                for (int i = 0; i < nbAdd; i++)
        //                {
        //                    _list.RemoveAt(0);
        //                }
        //            }

        //            if (mode.reSort || mode.removeFirst || mode.noAdd)
        //            {
        //                _list.Sort();
        //                _list.Reverse();
        //                pieces.Sort(new PieceCmp());
        //            }



        //            if (mode.noAdd)
        //                nbAdd = _nbNoAdd;

        //            ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
        //            if (mode.expEnabled != 0)
        //            {
        //                int _nb = pieces.Count<Piece>(p => !p.Enabled);
        //                decimal _c = (decimal)_nb / (decimal)count;
        //                _c = Math.Pow(_c, mode.expEnabled);
        //                ret.d *= _c;
        //            }


        //        }
        //        else
        //            ret = calcmedianneVirt(list, mode, 0, 0);

        //        //if (ret < ret0)
        //        //    ret = ret0; 



        //    }
        //    finally
        //    {
        //        if (signal)
        //        {
        //            try
        //            {
        //                pieces[ret.index].MedianneLight = true;
        //                pieces[ret.indexBorder].Border = true;
        //                pieces[ret.indexBorderEffect].BorderEffect = true;
        //                pieces[ret.indexBorderMin].BorderMin = true;

        //            }
        //            catch { }
        //        }
        //    }

        //    return ret;
        //}

        public static int buildVirtual(List<Piece> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, ref int i0)
        {
            var coeffEnabled = modeVirt.CoeffOld;
            int count = pieces.Count;
            pieces.Sort(new PieceClassementComparer(false));
            //if (coeffEnabled != 1)
            //{
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                    p.setClassementVirtuel2(rapportClassement);
                }
                pieces.Sort(new PieceClassementComparer(false));
           // }

            int indexV = 0;
            int nbAdd = 0;

           
            List<Piece> _pieces = pieces;
            var _zero = mode.zero;


            //if (modeVirt.safe > 0)
            //{
                i0 = count - 1;
                int _nbNoAdd = 0;


                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }

                if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
                { 
                    _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                    if (_nbNoAdd > 0)
                        _nbNoAdd--; 
                }
                if (modeVirt.noAddAll)
                    _nbNoAdd = pieces.Count;
                if (modeVirt.noAddEnd)
                {
                    // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                    // morceaux déjà notés
                    var nb2 = pieces.Count<Piece>(p => !p.Enabled && p.RapportClassement > 0);
                    _nbNoAdd = _nbNoAdd - nb2;
                    if (_nbNoAdd < 0)
                        _nbNoAdd = 0;
                }
                if (i0 == 0)
                    return 0;
                //}

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>();
                for (int i = 0; i < _pieces.Count; i++)
                    _list.Add(_pieces[i].VirtualClassement);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = System.Math.Min(count, i0 + modeVirt.safe);
                decimal[] virt = new decimal[_count];
                _nbNoAdd = System.Math.Min(modeVirt.safe, _nbNoAdd);
                if (modeVirt.noAdd)
                {
                   // var coeffEnabled = modeVirt.coeffOld; 
                    var _coeffVirt = modeVirt.coeffVirt;
                    if (count < modeVirt.safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)modeVirt.safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;
                    decimal prec = 0m;
                    if (modeVirt.virtAlignPrec)
                    {
                        if (_nbNoAdd < _list.Count)
                            prec = _list[_nbNoAdd];
                    }

                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < _pieces.Count)
                        {

                            if (!modeVirt.virtOnlyDisabled || !_pieces[j].Enabled)
                            {
                                _coeff /= _coeffVirt;
                                var cand = _list[j] * _coeff;
                                if (modeVirt.virtAlignPrec)
                                {
                                    if (cand < prec)
                                        cand = prec + EPSILON;
                                }

                                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                                {
                                    // quel serait le score s'il était coché
                                    var vu = _list[j] / coeffEnabled;
                                    // en plus une petite marge
                                    //  vu *= mode.coeffVirt; 
                                    if (cand < vu)
                                        cand = vu;
                                }
                                _list[j] = cand;
                            }
                            else if (modeVirt.forceCoeffVirt)
                                _coeff /= _coeffVirt;
                            prec = _list[j];
                        }
                    }

                }
                else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= modeVirt.coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
                else
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] <= _zero)
                        {
                            courant /= modeVirt.coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                if (modeVirt.noAdd)
                {
                    //for (ii = 1; ii < count && ii < _count; ii++)
                    //{
                    //    var calc = virt[ii];
                    //    if (calc > 0m)
                    //        list[ii] = calc;
                    //}
                }
                else
                {
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (modeVirt.lissage || value <= _zero)
                            {
                                if (value <= _zero)
                                    nbAdd++;
                                value = calc;
                                _list[ii] = value;
                            }

                        }
                        else
                            indexV = ii;
                    }
                    if (modeVirt.removeEpsilon)
                    {
                        // j'ai 5 virtuel alors que j'ai deux safe
                        ///xx---
                        int nb = 0;
                        for (int i = indexV + 1; i < _count; i++)
                        {
                            nb++;
                            if (nb <= modeVirt.safe)
                                continue;
                            _list[i] = 0m;
                        }

                    }
                    if (mode.removeFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            _list[i] = 0m;
                        }
                    }
                }

                for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                {
                    if (main)
                        _pieces[i].setClassementVirtuel(_list[i]);
                    else
                        _pieces[i].setClassementVirtuel2(_list[i]);
                }

                if (mode.deleteFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces.RemoveAt(0);
                    }
                }

                if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
                {
                    //_list.Sort();
                    //_list.Reverse();
                    if (main)
                        pieces.Sort(new PieceCmp());
                    else
                        pieces.Sort(new PieceCmp2());
                }



                if (modeVirt.noAdd)
                    nbAdd = _nbNoAdd;
            //}
            return nbAdd;
        }

        public static DecimalIndex getMedianneLight(List<Piece> pieces,  ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {
                var _zero = mode.zero;
                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;
                ret = ret0;
                if (pieces.Count == 1)
                    return ret0;

                #region old
                //if (mode.safe == 0)
                //{
                //    return calcmedianneVirt(pieces, mode, 0, 0);
                //}

                //int indexV = 0;
                //int nbAdd = 0;

                //int count = pieces.Count;
                //List<Piece> _pieces = pieces;
                ////if (mode.virtOnlyDisabled)
                ////{
                ////    _pieces = pieces.FindAll(p => !p.Enabled && p.VirtualClassement > 0m);
                ////    _pieces.Sort(new PieceCmp());
                ////}


                //if (mode.safe > 0)
                //{
                //    int i0 = count - 1;
                //    int _nbNoAdd = 0;
                //    //if (mode.virtOnlyDisabled)
                //    //{
                //    //    _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);
                //    //}
                //    //else
                //    //{

                //    for (int i = 0; i < count; i++)
                //    {
                //        var pp = pieces[i];
                //        if (pp.VirtualClassement == 0m)
                //        {
                //            i0 = i;
                //            _nbNoAdd = count - i0;
                //            break;
                //        }
                //    }

                //    if (mode.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
                //        _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);  // || p.VirtualClassement == 0m);
                //    if (mode.noAddAll)
                //        _nbNoAdd = pieces.Count;
                //    if (mode.noAddEnd)
                //    {
                //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                //        // morceaux déjà notés
                //        var nb2 = pieces.Count<Piece>(p => !p.Enabled && p.RapportClassement > 0);
                //        _nbNoAdd = _nbNoAdd - nb2;
                //        if (_nbNoAdd < 0)
                //            _nbNoAdd = 0;
                //    }
                //    if (i0 == 0)
                //        return ret0;
                //    //}

                //    //for (int i00 = 1; i00 <= i0; i00++)
                //    //{
                //    //    decimal coeff = (decimal)i00 / (decimal)i0;
                //    List<decimal> _list = new List<decimal>();
                //    for (int i = 0; i < _pieces.Count; i++)
                //        _list.Add(_pieces[i].VirtualClassement);
                //    //for (int i = i00; i < count; i++)
                //    //    _list[i] = 0m;
                //    //liste partielle originale
                //    //  List<decimal> _list0 = new List<decimal>(_list);
                //    int _count = System.Math.Min(count, i0 + mode.safe);
                //    decimal[] virt = new decimal[_count];
                //    _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                //    if (mode.noAdd)
                //    {
                //        var _coeffVirt = mode.coeffVirt;
                //        if (count < mode.safe && mode.coeffVirtAuto)
                //        {
                //            if (mode.coeffVirtAdjust)
                //                _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                //            else
                //            {
                //                // ex 2^10 = 1024
                //                // je veux obtenir 1024 avec 3
                //                _coeffVirt = Math.Pow(_coeffVirt, (decimal)mode.safe / (decimal)count);
                //            }
                //        }

                //        decimal _coeff = 1m;
                //        decimal prec = 0m;
                //        if (mode.virtAlignPrec)
                //        {
                //            if (_nbNoAdd < _list.Count)
                //                prec = _list[_nbNoAdd];
                //        }

                //        for (int j = _nbNoAdd - 1; j >= 0; j--)
                //        {
                //            if (j < _pieces.Count)
                //            {

                //                if (!mode.virtOnlyDisabled || !_pieces[j].Enabled)
                //                {
                //                    _coeff /= _coeffVirt;
                //                    var cand = _list[j] * _coeff;
                //                    if (mode.virtAlignPrec)
                //                    {
                //                        if (cand < prec)
                //                            cand = prec + EPSILON;
                //                    }

                //                    if (mode.virtAlignSelected && mode.virtOnlyDisabled)
                //                    {
                //                        // quel serait le score s'il était coché
                //                        var vu = _list[j] / coeffEnabled;
                //                        // en plus une petite marge
                //                        //  vu *= mode.coeffVirt; 
                //                        if (cand < vu)
                //                            cand = vu;
                //                    }
                //                    _list[j] = cand;
                //                }
                //                else if (mode.forceCoeffVirt)
                //                    _coeff /= _coeffVirt;
                //                prec = _list[j];
                //            }
                //        }

                //    }
                //    else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                //    {
                //        for (int i = 0; i < i0; i++)
                //        {
                //            decimal _coeff = 1m;
                //            decimal _base = _list[i];
                //            for (int j = i + 1; j < _count; j++)
                //            {
                //                _coeff /= mode.coeffVirt;
                //                virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                //            }
                //        }
                //    }
                //    else
                //    {
                //        decimal courant = _list[0];
                //        for (int i = 1; i < _count; i++)
                //        {
                //            if (_list[i] <= _zero)
                //            {
                //                courant /= mode.coeffVirt;
                //                virt[i] = courant;
                //            }
                //            else
                //                courant = _list[i];
                //        }
                //    }

                //    decimal value = int.MaxValue;
                //    int ii = 0;
                //    if (mode.noAdd)
                //    {
                //        //for (ii = 1; ii < count && ii < _count; ii++)
                //        //{
                //        //    var calc = virt[ii];
                //        //    if (calc > 0m)
                //        //        list[ii] = calc;
                //        //}
                //    }
                //    else
                //    {
                //        for (ii = 1; ii < count && ii < _count; ii++)
                //        {
                //            value = _list[ii];
                //            var calc = virt[ii];
                //            if (value < calc)
                //            {
                //                if (mode.lissage || value <= _zero)
                //                {
                //                    if (value <= _zero)
                //                        nbAdd++;
                //                    value = calc;
                //                    _list[ii] = value;
                //                }

                //            }
                //            else
                //                indexV = ii;
                //        }
                //        if (mode.removeEpsilon)
                //        {
                //            // j'ai 5 virtuel alors que j'ai deux safe
                //            ///xx---
                //            int nb = 0;
                //            for (int i = indexV + 1; i < _count; i++)
                //            {
                //                nb++;
                //                if (nb <= mode.safe)
                //                    continue;
                //                _list[i] = 0m;
                //            }

                //        }
                //        if (mode.removeFirst)
                //        {
                //            for (int i = 0; i < nbAdd; i++)
                //            {
                //                _list[i] = 0m;
                //            }
                //        }
                //    }

                //    for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                //        _pieces[i].setClassementVirtuel(_list[i]);

                //    if (mode.deleteFirst)
                //    {
                //        for (int i = 0; i < nbAdd; i++)
                //        {
                //            pieces.RemoveAt(0);
                //        }
                //    }

                //    if (mode.reSort || mode.removeFirst || mode.noAdd)
                //    {
                //        //_list.Sort();
                //        //_list.Reverse();
                //        pieces.Sort(new PieceCmp());
                //    }



                //    if (mode.noAdd)
                //        nbAdd = _nbNoAdd;

                #endregion
                int i0 = 0;
                int count = pieces.Count;
                int nbAdd = buildVirtual(pieces, mode, mode.Main, true, ref i0);
                ret = calcmedianneVirt(pieces, mode, mode.Main, nbAdd, System.Math.Min(i0, mode.Main.safe));
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<Piece>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }


                //}
                //else
                //    ret = calcmedianneVirt(pieces, mode, 0, 0);

                //if (ret < ret0)
                //    ret = ret0; 

            }
            finally
            {

                if (signal)
                {
                    try
                    {
                        pieces[ret.index].MedianneLight = true;
                        pieces[ret.indexBorder].Border = true;
                        pieces[ret.indexBorderEffect].BorderEffect = true;
                        pieces[ret.indexBorderMin].BorderMin = true;

                    }
                    catch { }
                }
            }

            return ret;
        }




        private class PieceCmp : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp2 : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        private static DecimalIndex calcmedianneVirt(IList<Piece> list,ConfMedianne conf, ConfMedianneVirt confc, int nbAdd, int nbDel)
        {
            var _list = new List<Piece>(list);
            var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

            if (confc.oldAsZero)
                classes = _list.FindAll(p => p.LastClassementRecent);
           
            int count = _list.Count;

            int nbEnabled = classes.Count<Piece>(p => p.Enabled);
            int nbDisabled = classes.Count<Piece>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            //int _nbSuppDisabled = 0;
            //int _nbSuppEnabled = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {
                    //var d = _list[count - i];
                    //if (d.Enabled)
                    //    nbEnabled--;
                    //else
                    //    nbDisabled--;

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                ret.indexBorderMin = count - i - 1;
                var p = _list[count - i - 1];

                if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }

                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                        // }


                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

        //public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        //{
        //    if (list.Count == 1)
        //        return getMedianne_(list, coeffMedianne);
        //    decimal ret = 0m;
        //    int count = list.Count;

        //    List<decimal> _list = new List<decimal>(list);
        //    // ret = getMedianne_(_list, coeffMedianne);
        //    decimal nb = 0m;
        //    for (int i = 0; i < count - 1; i++)
        //    {
        //        if (i > 0)
        //            _list.RemoveAt(count - i);
        //        var aux = getMedianne_(_list, coeffMedianne);
        //        decimal coeff = count - 1 - i;
        //        if (quasi)
        //            coeff *= coeff;
        //        ret += aux * coeff;
        //        nb += coeff;


        //    }
        //    ret /= nb;


        //    return ret;
        //}
        //private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        //{
        //    index = 0;
        //    if (list == null)
        //        throw new ArgumentException("liste nulle");
        //    int count = list.Count;
        //    if (count == 0)
        //        throw new ArgumentException("liste vide");
        //    if (coeffMedianne < 0 || coeffMedianne > 1)
        //        throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
        //    if (count == 1)
        //        return list[0];
        //    if (coeffMedianne == 0)
        //        return list[0];
        //    if (coeffMedianne == 1)
        //    {
        //        index = count - 1;
        //        return list[count - 1];
        //    }

        //    var medianne = coeffMedianne * (count - 1);

        //    index = (int)medianne;
        //    int i1 = index + 1;
        //    var val0 = list[index];
        //    var val1 = list[i1];
        //    if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
        //        return val0;
        //    if (Math.Abs(medianne - i1) < PRECISION)
        //    {
        //        index = i1;
        //        return val1;
        //    }

        //    var pente = (val1 - val0);
        //    var dx = medianne - index;
        //    var dy = pente * dx;
        //    return val0 + dy;

        //}

        private static decimal getMedianne_(IList<Piece> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0].VirtualClassement;
            if (coeffMedianne == 0)
                return list[0].VirtualClassement;
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1].VirtualClassement;
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].VirtualClassement;
            var val1 = list[i1].VirtualClassement;
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            if (val1 < PRECISION)
            {
                index = i1;
                return val1;
            }

            //         var pente = (val1 - val0);
            var dx = medianne - index;

            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;
          

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;
using System.Text.RegularExpressions;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object(); 
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict.Values)
                {
                    album.checkBuild();
                }
            }
        }

        private string getKey(string _album, bool artist)
        {
            return Album.getKey(_album, artist);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                foreach (Album album in new List<Album>(dict.Values))
                {
                    if (!album.buildDone())
                    {
                        misc.log("suppression album {0}", album.Name);
                        dict.Remove(getKey(album.Name, album.VirtualByArtist));
                    }
                }
            }
        }

        private bool check_(Piece piece, string albumOrg, bool virtualByArtist, IDictionary<string, Album> dict)
        {
            string __album = getKey(albumOrg, virtualByArtist);


            var album = dict[__album];
            if (album == null)
            {
                misc.log("creation album {0}", __album);
                album = new Album(albumOrg, __album);
                album.Virtual = piece.Virtual;
                album.VirtualByArtist = piece.VirtualByArtist;
                dict.Add(__album, album);
            }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualByArtist, dict);
        }

        public int Count { get { return dict.Count; } }





        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
                check_(piece, dict);

        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
        }

        public void makeSort()
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var coeffVirt = confMedianne.Main.coeffVirt;
                if (confSort.reset)
                {
                    confMedianne = conf0;
                }





                var list = new List<Album>(dict.Values);
                foreach (Album album in list)
                {
                    album.makeSort(confMedianne, conf0); //listRef, reference); 
                }



                list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                list.Reverse();
                for (int i = 0; i < list.Count; i++)
                {
                    list[i].Rank.Sort = i + 1;
                }

                var list2 = new List<Album>(list);

                list2.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                list2.Reverse();
                for (int i = 0; i < list.Count; i++)
                {
                    list2[i].RankSt = i + 1;
                }

                var list3 = new List<Album>(list);

                list3.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                list3.Reverse();
                for (int i = 0; i < list3.Count; i++)
                {
                    list3[i].RankZero = i + 1;
                }
                if (confSort.correcMainRank)
                {
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = list[i];
                        Album zero = list3[i];

                        if (un == zero)
                            un.InvalidateMain();
                    }
                }

                if (confSort.correcMainCoeff)
                {
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = list[i];
                        if (un.SelectedCoeff == selectedCoeff.main)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLight * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = list[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLight;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }

                }
                if (confSort.correcMainZero)
                {
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = list[i];
                        if (un.SelectedCoeff == selectedCoeff.main)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;

                            bool correc = true;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = list[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;


                                var cmp = o.ClassementValueLight;
                                if (o.ClassementValueLight > un.ClassementValueLight)
                                {
                                    if (o.ClassementValueLightZero < un.ClassementValueLightZero)
                                    {
                                        correc = false;
                                        break;
                                    }

                                    if (o.ClassementValueLight > un.ClassementValueLightZero)
                                        break;
                                }

                            }

                            if (correc)
                                un.InvalidateMain();

                        }



                    }
                }




                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }

        public void changeAlbum(Piece p, string newA)
        {
            var currentAlb = dict[getKey(p.Album, false)];
            if (currentAlb != null)
                currentAlb.mustRefresh();
            check_(p, newA, false, this.dict);
            var newAlb = dict[getKey(newA, false)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();
        }

        public void changeArtist(Piece p, string newA)
        {



            var currentAlb = dict[getKey(p.Artist, true)];
            if (currentAlb != null)
                currentAlb.mustRefresh();

            check_(p, newA, true, this.dict);
            var newAlb = dict[getKey(newA, true)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();
        }

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                bool found = false;
                foreach (Album album in dict.Values)
                {
                    if (album.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.Clear();
                }
                else
                {
                    // on le prend.
                    dict.Add(getKey(candidat.Name, candidat.VirtualByArtist), candidat);
                    foreach (Piece p in candidat)
                    {
                        p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(TrackList track)
        {
            track.Piece.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track.Piece);
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfAlbumSort.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.Xml;
using pdb.util;
using System;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    [Serializable]
    /// <summary>
    /// Configuration sort Albums
    /// </summary>
    public class ConfAlbumSort : TuningBase
    {

        private List<ConfMedianne> composants = new List<ConfMedianne>();
        private List<ConfMedianne> composantsUtiles = new List<ConfMedianne>();
        public List<ConfMedianne> Composants { get { return composants; } }
        public List<ConfMedianne> ComposantsUtiles { get { return composantsUtiles; } }
        // public decimal coeffEnabled = 1m;
        public int stackSize = 0;
        public int stackPeremption = 10;
        public decimal stackPower = 2.0m;
        public int stackBefore = 0;
        public bool checkStack = false;
        public bool stackEnabled = true;
        public DateTime lastModif;
        public DateTime newA;
        public bool createCourant = true;
        public bool createInter = true;
        public bool createAll;

        public bool reset;
        public bool correcMainRank, correcMainCoeff, correcMainZero; 

        // public bool oldAsZero; 
        public void Calcul()
        {
            composantsUtiles = new List<ConfMedianne>();
            foreach (var cmp in composants)
            {
                if (cmp.enabled)
                    composantsUtiles.Add(cmp);
            }
            if (composantsUtiles.Count == 0)
                composantsUtiles.Add(composants[0]);
        }
        public ConfAlbumSort()
        {
        }

        public ConfAlbumSort(XmlElement node)
            : base(node)
        {

            composants.Clear();
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    var cmp = new ConfMedianne(node, sub as XmlElement);
                    composants.Add(cmp);
                }
            }


            buildi("stackSize", v => stackSize = v);
            buildi("stackPeremption", v => stackPeremption = v);
            buildi("stackBefore", v => stackBefore = v);
            builddec("stackPower", v => stackPower = v);

            buildb("stackEnabled", v => stackEnabled = v);
            buildb("checkStack", v => checkStack = v);
            buildDate("lastModif", v => lastModif = v);
            buildDate("newA", v => newA = v);
            buildb("createCourant", v => createCourant = v);
            buildb("createInter", v => createInter = v);
            buildb("createAll", v => createAll = v);

            buildb("correcMainCoeff", v => correcMainCoeff = v);
            buildb("correcMainRank", v => correcMainRank = v);
            buildb("correcMainZero", v => correcMainZero = v); 



            Calcul();

        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("albumSort");

            write("stackSize", stackSize);
            write("stackPeremption", stackPeremption);
            write("stackBefore", stackBefore);
            write("stackPower", stackPower);

            write("stackEnabled", stackEnabled);
            write("checkStack", checkStack);
            write("lastModif", lastModif);
            write("newA", newA);
            write("createCourant", createCourant);
            write("createInter", createInter);
            write("createAll", createAll);

            write("correcMainCoeff", correcMainCoeff);
            write("correcMainRank", correcMainRank);
            write("correcMainZero", correcMainZero); 

            foreach (var cmp in composants)
                cmp.save(w);
            writeEnd();
        }
        public bool Enabled
        {
            get
            {
                foreach (var cmp in composants)
                {
                    if (cmp.enabled)
                        return true;
                }
                return false;
            }
        }

        public void auto(Piece p)
        {
            try
            {
                if (checkStack && p.PieceAlbum != null && p.PieceAlbum.Empeached)
                    return;
                if (p.Added > newA)
                    return;
                var motif = p.SelectedMotif;
                if (p.SelectedMotif == selectedCoeff.none)
                    return;
                foreach (var cmp in composants)
                {
                    cmp.auto(motif);
                }
            }
            finally
            {
                foreach (Piece pp in p.Master)
                {
                    pp.Empeached = false;
                    pp.Empeached1 = false;
                }
            }
        }
    }


}
]]></content>
  </file>
</db>
