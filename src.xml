<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\Vue\PlayerControler.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.PlayerControler"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
              xmlns:local="clr-namespace:pdb.player"
              xmlns:util="clr-namespace:pdb.player.Vue.Util"
             mc:Ignorable="d" 
             d:DesignHeight="167" d:DesignWidth="777">
    <UserControl.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <Style x:Key="EmptyButtonStyle" TargetType="{x:Type Button}">
            <Setter Property="Background" Value="#00000000"/>
            <Setter Property="BorderBrush" Value="#00000000"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
            <Setter Property="HorizontalContentAlignment" Value="Center"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter 
                        HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                        Margin="{TemplateBinding Margin}" 
                        RecognizesAccessKey="True" 
                        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
                        VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                           
                            />
                        
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid Margin="0" >
        <Grid.Background>
            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                <GradientStop Color="#fff" Offset="0" />
                <GradientStop Color="#dfdfdf" Offset="1" />
               
            </LinearGradientBrush>

        </Grid.Background>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Name="defNav" Width="Auto" />
            <ColumnDefinition Name="defInfo" Width="*" />
            <ColumnDefinition Name="defFilter" Width="Auto" />
        </Grid.ColumnDefinitions>
        <Grid Margin="10" Grid.Column="0" >
            <StackPanel Orientation="Horizontal" VerticalAlignment="Bottom">

                <Button Name="b_rewind" Height="40" Width="40" Command="{Binding BackWard}" Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Rewind-icon.png"  Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_play" Height="40" Width="40"  Command="{Binding Play,UpdateSourceTrigger=PropertyChanged}"  Style="{DynamicResource EmptyButtonStyle}">
                    <!--<Image Name="I_Play" Source="images\Toolbar-MP3-Play-icon.png"   Height="30" Width="30"></Image>-->
                    <Image Name="I_Play" Source="{Binding SrcPlayPause, UpdateSourceTrigger=PropertyChanged}"   Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_forward" Height="40" Width="40" Command="{Binding Forward}"  Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Forward-icon.png"    Height="30" Width="30" ></Image>
                </Button>
                <Grid Margin="10">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition />
                        <ColumnDefinition />
                        <ColumnDefinition />
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="&lt;)" Grid.Column="0"  VerticalAlignment="Center" Margin="0,0,5,0"/>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="SliderVolume" Width="150" VerticalAlignment="Center" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Volume, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <TextBlock Text="&lt;)))" Grid.Column="2"  VerticalAlignment="Center"  Margin="5,0,00,0"/>
                </Grid>
            </StackPanel>
        </Grid>
       
        <Grid Grid.Column="1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Name="defName" MaxHeight="50" Height="Auto" />
                    <RowDefinition Name="defPosition" Height="Auto" />
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,15,0,0">
                    <Label Name="l_TrackName"  HorizontalAlignment="Center" Content="{Binding Path=CurrentName,  UpdateSourceTrigger=PropertyChanged}"  FontWeight="Bold" Padding="0" Margin="0"></Label>
                    <Label Grid.Row="1" Name="l_trackAuthorAlbum" HorizontalAlignment="Center" Content="{Binding Path=CurrentAuthorAlbum,  UpdateSourceTrigger=PropertyChanged}"  Padding="0" Margin="0"/>
                </StackPanel>
                <Grid Grid.Row="2"  HorizontalAlignment="Stretch" Margin="5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="Auto" />
                    </Grid.ColumnDefinitions>
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <CheckBox Name="cbEnabled" DockPanel.Dock="Left" ToolTip="Jouer seulement les morceaux cochés" IsChecked="{Binding OnlyEnabled,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Name="cbSortAlbum" DockPanel.Dock="Left" ToolTip="Tri par album" IsChecked="{Binding SortByAlbum,UpdateSourceTrigger=PropertyChanged}" />
                        <ComboBox Name="cbxSort" Height="20" SelectedIndex="{Binding SortAlbumMode, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource sortAlbum} }"  >
                                  <ComboBox.ToolTip>
                                    <TextBlock  xml:space="preserve">
strict          = tri sur moyenne quand aucun des albums n'a défini sa médianne
mix             = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
mixLight        = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
mixLight2       = tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
medQuasi        = calcul médianne quasi strict, qq miettes pour éviter le zero
medLight        = calcul Médianne moins strict
medLightSafe   = calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
medLightSafe2   = calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse                                        
medLightSafe3   = calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse   ...                                     
light           = tri uniquement sur la moyenne
                                    </TextBlock>
                                  </ComboBox.ToolTip>
                            <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mix" >mix</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light" Name="mixLight" >mixLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mixLight2" >mixLight2</ComboBoxItem>
                            <ComboBoxItem ToolTip="Calcul médianne quasi strict, qq miettes pour éviter le zero" Name="medQuasi" >medQuasi</ComboBoxItem>                            
                            <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="medLight" >medLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse" Name="medLightSafe" >medLightSafe</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse" Name="medLightSafe2" >medLightSafe2</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse" Name="medLightSafe3" >medLightSafe3</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse" Name="medLightSafe4" >medLightSafe4</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse" Name="medLightSafe5" >medLightSafe5</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse" Name="medLightSafe6" >medLightSafe6</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse" Name="medLightSafe10" >medLightSafe10</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="light" >light</ComboBoxItem>
                        </ComboBox>
                        <CheckBox Name="cbAlbumVirtual" DockPanel.Dock="Left" ToolTip="albums virtuels" IsChecked="{Binding WithVirtualAlbum,UpdateSourceTrigger=PropertyChanged}" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}, Mode=OneTime}"/>
                        <Label Name="Duration" DockPanel.Dock="Left" VerticalAlignment="Bottom" Content="{Binding Path=ElapsedTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />

                    </StackPanel>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="PBar"  VerticalAlignment="Bottom" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Position, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal">
                        <Label Name="RemainingTime"   VerticalAlignment="Bottom" Content="{Binding Path=RemainingTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />
                        <Label Content="/" />
                        <Label Name="Length"  VerticalAlignment="Bottom" Content="{Binding Path=Length, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"/>
                    </StackPanel>
                </Grid>
            </Grid>

        </Grid>
        <DockPanel Grid.Column="2" HorizontalAlignment="Stretch" VerticalAlignment="Top" Margin="0,15,0,0">
            <GroupBox Header="Filtre" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <StackPanel Orientation="Horizontal" >
                    <TextBox x:Name="txtFilter" MinWidth="150"  KeyUp="txtFilter_KeyUp" />
                </StackPanel>
            </GroupBox>
        </DockPanel>


    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public enum albumSortMode
    {
        /// <summary>
        /// tri sur moyenne quand aucun des albums n'a défini sa médianne
        /// </summary>
        strict,
        /// <summary>
        /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
        /// </summary>
        mix,
        /// <summary>
        /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
        /// </summary>
        mixLight,
        /// <summary>
        /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
        /// </summary>
        mixLight2,
        /// <summary>
        /// Calcul médianne quasi strict, qq miettes pour éviter le zero
        /// </summary>
        medQuasi,
        /// <summary>
        /// Calcul Médianne moins strict
        /// </summary>
        medLight,
        /// <summary>
        /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
        /// </summary>
        medLightSafe,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe2,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe3,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe4,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe5,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe6,
        /// <summary>
        /// Calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse
        /// </summary>
        medLightSafe10,
        /// <summary>
        /// tri uniquement sur la moyenne
        /// </summary>
        light

    }
    class AlbumClassComparer : IComparer<Album>
    {
        private albumSortMode mode;
        public AlbumClassComparer(albumSortMode mode)
        {
            this.mode = mode;
        }
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            //if (x.Name == "Alien Lanes" || y.Name == "Alien Lanes")
            //{
            //    int toto = 0; 
            //}
            //si classement == 0 mais que l'autre est tellement nul que m�me ma moyenne est sup�rieure � sa moyenne
            int cmp = 0;

            if (mode == albumSortMode.light)
            {
                cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                if (cmp != 0)
                    return cmp;
            }
            else if (mode == albumSortMode.mix)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.mixLight)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.mixLight2)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
                else
                {
                    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                    if (cmp != 0)
                        return cmp;
                }
            }

            else if (mode == albumSortMode.medLight
                || mode == albumSortMode.medQuasi
                || mode == albumSortMode.medLightSafe
                || mode == albumSortMode.medLightSafe2
                || mode == albumSortMode.medLightSafe3
                || mode == albumSortMode.medLightSafe4
                || mode == albumSortMode.medLightSafe5
                || mode == albumSortMode.medLightSafe6
                || mode == albumSortMode.medLightSafe10
                )
            {
                cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
                if (cmp != 0)
                    return cmp;
            }



            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInVirtualAlbumComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Location.CompareTo(y.Location);
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.Location.CompareTo(y.Location);
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {
            int medianneVirt = 0;
            bool quasi = false;
            if (consolid.SortAlbumMode == albumSortMode.medQuasi)
                quasi = true;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe)
                medianneVirt = 1;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe2)
                medianneVirt = 2;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe3)
                medianneVirt = 3;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe4)
                medianneVirt = 4;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe5)
                medianneVirt = 5;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe6)
                medianneVirt = 6;
            else if (consolid.SortAlbumMode == albumSortMode.medLightSafe10)
                medianneVirt = 10;
            var listRef = new List<double>();
            //foreach (Piece piece in reference)
            //    listRef.Add(piece.RapportClassement); // piece.Rank.SortValue); 
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(quasi, medianneVirt); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }



    }
}
]]></content>
  </file>
</db>
