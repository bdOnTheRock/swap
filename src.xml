<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;
using pdb.gen.albums;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Input;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                gen.FilterNext = CConf.ConfGen.FilterNext;
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                //  Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    if (CConf.ResetOneCl)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Piece min = null;
                            //int nbnotes = 0;
                            foreach (Piece t in l)
                            {
                                //si on a au moins un noté on quitte

                                //var p = t.Track as CPiece;


                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                                if (cl.isPositive())// > zer0d)
                                {
                                    // nbnotes++;
                                    if (t.LastClassementRecent || !t.Enabled)
                                    {
                                        min = null;
                                        break;
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }

                            }

                            if (min != null)
                            {
                                var coeff = (decimal)1 / (l.Count * l.Count);

                                min.setKeep(coeff);
                            }
                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }



        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;




            if (CConf.ResetOneCl)
            {
                gen.ConsolidInit(Db.List.getList());
                client.log(" gen.ConsolidInit(Db.List.getList());");
                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, true, client);
            //  if (CConf.ConfGen.LimitList <= 0)
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        private static bool mustBuildCompleteAlbums(TrackListViewModel currentTrack)
        {
            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.RankAlbumReverse.CompareTo(y.RankAlbumReverse));
            int count = tracks.Count;
            int rank0 = currentTrack.RankAlbumReverse;

            int i = 0;
            // recherche trou avant ex rank0=3 pas de 1 ni de 2
            for (; i < count; i++)
            {
                var t = tracks[i];
                if (t.RankAlbumReverse >= rank0)
                    break;

                if (t.RankAlbumReverse > i + 1)
                    return true;
            }

            //if (i + 1 < count && tracks[i + 1].RankAlbumReverse > rank0 + 1)
            //{
            //    return true;
            //}

            return false;
        }

        private static void buildAffectedAlbumsWhenCurrentTrackChange(TrackListViewModel currentTrack, IDictionary<string, Album> dict, HashSet<Album> depot, bool navQuick)
        {
            if (currentTrack == null)
                return;
            TrackListViewModel item = currentTrack;
            var cl = item.PieceGen.getClassement(true);
            var _dict = dict;  // new Dictionary<string,Album>(); 

            //foreach (Album album in dict.Values)
            //{
            //    var current = album.PlusPetitEnabled; 
            //    if (current == null || cl<=current.getClassement(true))
            //        _dict.Add(album.Key, album); 
            //}

            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            int count = tracks.Count;

            //int index = -1;
            //for (int i = 0; i < count; i++)
            //{
            //    var t = tracks[i];
            //    if (t.PieceId == currentTrack.PieceId)
            //    {
            //        index = i;
            //        break;
            //    }
            //}

            //if (index < 0)
            //{
            //    foreach (Album a in dict.Values)
            //        depot.Add(a);
            //    return;
            //}

            var hs = new HashSet<int>();
            if (navQuick)
                hs.Add(item.MasterId);
            int index = -1;
            try
            {
                while (true)
                {
                    index++;
                    if (index >= count)
                        return;

                    var t = tracks[index];
                    if (!hs.Add(t.MasterId))
                        continue;
                    if (navQuick && t.album == item.album)
                        continue;
                    //if (t.album == item.album)
                    //    continue;

                    if (_dict.ContainsKey(t.album.Key))
                    {
                        depot.Add(t.album);
                        if (depot.Count >= _dict.Count)
                            return;
                    }
                    else
                        break;

                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            finally
            {

            }
        }

        private void automateNextTrack()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            else
            {
                PlayerViewModel.Instance.forwardAuto();
                App.go();
            }
        }

        static int nbGo = 0;
        static bool classementChange;
        private static SimpleClient client;
        private static void _go()
        {
            gen.Albums.endParallelSort();
            bool classementChange = App.classementChange;
            var _currentTrack = App._currentTrack;
            nbGo++;
            bool urgence = false;
            if (client != null)
            {
                client.log("FIN new step");
                client.cancel();
            }

            client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);

            try
            {

                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                if (detailClassementViewModel != null)
                    detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;

                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;

                urgence = gen.Urgence && TrackListViewModel.CurrentPlaying == _currentTrack;
                if (!urgence)
                {
                    Db.saveAsync();
                    Memento.Instance.save();
                }
                client.log(string.Format("debut classementChange={0} gen.ClassementChanged={1} gen.Urgence={2} _currentTrack={3}", classementChange, gen.ClassementChanged, gen.Urgence, _currentTrack));
                if (PlayerViewModel.Instance.CreateRot)
                {

                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                        App.classementChange = true;
                    }

                    if (!urgence && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        App.classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        int nbAlbums = 0;
                        // bool sortDone = false;
                        if (urgence)
                        {
                            var affectedAlbums = gen.Albums.GetAndInvalidateAlbums(_currentTrack.PieceGen);
                            bool mustComplete = mustBuildCompleteAlbums(_currentTrack);

                            if (!mustComplete)
                            {

                                //}

                                var depot = new HashSet<Album>();
                                buildAffectedAlbumsWhenCurrentTrackChange(_currentTrack, affectedAlbums, depot, CConf.ConfGen.NavQuick);
                                if (depot.Count == 0)
                                {
                                    if (_currentTrack == TrackListViewModel.CurrentPlaying)
                                    {
                                        log.log("pas de makeSort. on passe au suivant on verra après");
                                        _currentTrack = null;
                                        gen.Urgence = false;

                                        App.Instance.automateNextTrack();
                                        return;

                                    }
                                    else
                                    {
                                        log.log("trop naze c'est trop long");
                                        gen.Urgence = false;

                                    }


                                }
                                //}
                                //}
                                else
                                {
                                    log.log("depot:");
                                    nbAlbums = gen.Albums.makeSort(depot, log);
                                    //sortDone = true;
                                }

                            }
                            else
                            {
                                log.log("y a des trous dans la raquette on force le makesort");
                                gen.Urgence = false;
                            }
                            //if (!sortDone && gen.Urgence)
                            //{
                            //    log.log("affected albums");
                            //    nbAlbums = gen.Albums.makeSort(_currentTrack.PieceGen, log);
                            //}
                            client.log(string.Format("makeSort partial {0} elt", nbAlbums));
                            _currentTrack.refresh();
                            if (nbAlbums > 0)
                            {
                                if (refreshAlbum != null)
                                    refreshAlbum("", EventArgs.Empty);
                                client.log("refreshAlbum");
                            }
                        }
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 


                    gen.MakeConsolid(null, _updateStats, classementChange, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);
                    client.log("refresh après createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats && !urgence)
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => { if (detailClassementViewModel != null) detailClassementViewModel.IhmInDispo = ihmInDispo.none; });

                        }
                        else
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                        }
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats && !urgence)
                    {
                        _updateStats = false;
                    }
                }
                client.log("FIN _go()");
                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);

                if (classementChange && !urgence)
                    gen.Albums.parallelSort();


            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />
                    <MenuItem Header="Refresh Album"  Command="{Binding RefreshAlbum}" />
                    <MenuItem Header="Refresh All Album"  Command="{Binding RefreshAllAlbum}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="Exists" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MaxClassement" Binding="{Binding MaxClassement, Mode=OneWay,Converter={StaticResource cl} }">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DeepClassement" Binding="{Binding DeepClassement, Mode=OneWay,Converter={StaticResource cl} }">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Mode=OneWay,Converter={StaticResource cl} }">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum,Mode=OneWay}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="DeltaRank" Binding="{Binding DeltaRank, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="DelaiMasterAlbum"  Binding="{Binding MasterAlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Mode=OneWay,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="ClassementValueLight"  Binding="{Binding ClassementValueLight, Mode=OneWay}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalEl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>




                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Done"  Binding="{Binding NbDoneInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Current" Binding="{Binding PlusPetitEnabled, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>



            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" HorizontalAlignment="Left" Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackInfoItunes, IEnumerable<Piece>, IItem, IPiece, IPieceAlbum
    {
        private ITrackInfoItunes track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual virtualMode VirtualMode { get { return virtualMode.none; } }
        // public virtual bool Dirty { get { return false; } set { throw new ApplicationException();  } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } get { return gen; } }
        /// <summary>
        /// Permet d'utiliser le classement Compact. 
        /// </summary>
        private bool useCompact = Compact;
        // private bool useCompact0 = Compact;
        public static bool Compact;
        public static Classement compact(Classement cl)
        {
            if (!Compact)
                return Classement.NULL;
            if (!cl.isPositive())
                return Classement.NULL;
            //if (ClassementHash.ZERO_KEY == strClassement)
            //    return null;
            // var cl = classementHash.getCache(strClassement);
            var res = tradCompact[cl];
            if (res == null)
            {
            }

            if (res == null)
                return Classement.NULL;
            return res;
        }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackInfoItunes Track { get { return track; } }

        public bool UseCompact { get { return useCompact; } set { useCompact = value; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void resetMedianneCompact() { _infoMedianne = infoMedianne.none; useCompact = Compact; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        //public int LRank
        //{
        //    get { return Rank.Lenght; }
        //    set { Rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return Rank.Twice; }
        //    set { Rank.Twice = value; }
        //}

        //public int RankAllAlbum
        //{
        //    get { return m_rank.RankAllAlbum; }
        //    set { m_rank.RankAllAlbum = value; }
        //}

        public int RankAlbum { get { if (album == null) return 0; return album.Quality; } }
        public int RankAlbumZero { get { if (album == null) return 0; return Albums.RankZero - album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        // public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true;
                    default:
                        return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackInfoItunes track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        // public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.MasterPiece.setClassement(className, rating);
            invalidateCache(true);

        }

        public string ClassementCompact
        {
            get
            {

                return getClassement(true).ToString();
                //if (parent != null)
                //    return parent.ClassementCompact;
                //if (Compact)
                //{
                //    if (string.IsNullOrEmpty(_classementCompact))
                //        return ClassementCache.strClassement;
                //    return _classementCompact;
                //}
                //else
                //    return ClassementCache.strClassement;

            }
        }
        //  public static ClassementHash classementHash = new ClassementHash();
        //private ClassementCache _classementCache;
        //private ClassementCache ClassementCache
        //{
        //    get
        //    {


        //        if (_classementCache == null)
        //        {
        //            if (parent != null)
        //                _classementCache = parent.ClassementCache;
        //            if (_classementCache == null)
        //            {
        //                if (Compact)
        //                {
        //                    if (string.IsNullOrEmpty(_classementCompact))
        //                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
        //                    else
        //                        _classementCache = classementHash.getCache(_classementCompact);
        //                }
        //                else
        //                    _classementCache = classementHash.getCache(track.ClassName, track.Rating);

        //            }
        //        }
        //        return _classementCache;
        //    }
        //}

        // private bool keep;
        private static Dictionary<int, decimal> hsKeep = new Dictionary<int, decimal>();
        public bool Keep
        {
            get { return hsKeep.ContainsKey(PieceId); } //  .Contains(PieceId); }
            //set
            //{
            //    if (value)
            //        hsKeep.Add(PieceId);
            //    else
            //        hsKeep.Remove(PieceId);
            //}
        }

        public decimal KeepCoeff
        {
            get
            {
                if (!Keep)
                    return 0;
                return hsKeep[PieceId];
            }
        }

        public void setKeep(decimal coeff)
        {
            if (hsKeep.ContainsKey(PieceId))
            {
                if (coeff == 0m)
                    hsKeep.Remove(PieceId);
                else
                    hsKeep[PieceId] = coeff;
            }
            else
            {
                if (coeff > 0m)
                    hsKeep.Add(PieceId, coeff);
            }
        }

        private static HashSet<int> ksCompact = new HashSet<int>();
        private static Dict<Classement, Classement> tradCompact = new Dict<Classement, Classement>();
        // private static Dict<int, string> dictCompact = new Dict<int, string>();

        public static void resetCompact() { tradCompact.Clear(); }
        //private bool UseCompact0
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return useCompact0;
        //        return parent.useCompact0;
        //    }
        //}

        public Classement getClassement(bool _compact)
        {
            var cl = ClassementCoeff;
            if (_compact && useCompact && ClassementACompacter)
            {
                var __compact = compact(cl);
                if (__compact == null || !__compact.isPositive())
                {

                }
                else
                    return __compact;



            }
            return cl;
        }
        //private ClassementCache getClassementCache(bool _compact)
        //{
        //    //if (parent != null)
        //    //    return parent.getClassementCache(_compact);
        //    //  ClassementCache compactc = null;

        //    var cl = ClassementCoeff;
        //    if (_compact && useCompact && ClassementACompacter)
        //    {
        //        var strCompact = compact(str);
        //        if (str != ClassementHash.ZERO_KEY && string.IsNullOrEmpty(strCompact))
        //        {
        //        }
        //        else
        //            return classementHash.getCache(strCompact);

        //    }
        //    return classementHash.getCache(str);
        //    // return classementHash.getCache(strClassement);


        //}



        // private string _classementCompact;



        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache(true);

            // _classementCompact = classement;
            var _compact = Classement.create(classement);// classementHash.getCache(classement);
            var org = ClassementCoeff; //  classementHash.getCache(StrClassementCoeff);

            if (org <= _compact)
            {
                //  useCompact0 = false;
                //tradCompact.Remove(org.strClassement); 
                // dictCompact.Remove(MasterId);
                // _classementCache = org;
                return false;
            }
            else
            {
                // useCompact0 = true;
                tradCompact[org] = _compact;
                // dictCompact[MasterId] = classement;
                // _classementCache = _compact;
                return true;
            }
        }

        public bool ClassmentPositive() { return Classement.isPositive(); }

        public decimal ClassementValueDecimal(bool compact)
        {
            return getClassement(compact).ClassementValueDecimal;
        }



        public virtual void invalidateCache(bool razCompact)
        {
            //if (razCompact)
            //{
            //  //  useCompact0 = false;
            //  //  useCompact = false;

            //    //if (parent != null)
            //    //    parent.invalidateCache(razCompact);
            //}
            //  tradCompact.Remove(StrClassement); 
            //dictCompact.Remove(MasterId);

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //_classementProvisoireRecent = null;

            //if (parent != null)
            //    parent.invalidateCache(razCompact);
            //else
            //{
            //    // _classementCache = null;
            //    if (Compact)
            //    {
            //        if (razCompact)
            //            _classementCompact = null;
            //    }
            //    foreach (Piece p in childs)
            //    {
            //        if (Compact)
            //        {
            //            if (razCompact)
            //                p._classementCompact = null;
            //        }
            //        // p._classementCache = null;
            //    }
            //  }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité



        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return this.Classement.isClassed();
            }
        }

        // private string _classNameAndRating;
        //public String ClassNameAndRating
        //{
        //    get
        //    {
        //        return ClassementCache.ClassNameAndRating;
        //    }
        //}

        public String ClassNameAndRating(bool compact)
        {
            return getClassement(compact).ClassNameAndRating;

        }

        // private decimal _classementValueDecimal = -1;
        //public decimal ClassementValueDecimal
        //{
        //    get
        //    {
        //        return ClassementCache.ClassementValueDecimal;
        //    }
        //}
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        /// <summary>
        /// Convertit chaine de format 12345 en 0.17
        /// </summary>
        /// <param name="classNameAndRating"></param>
        /// <returns></returns>
        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }
        public decimal RapportClassement(bool compact)
        {
            return getClassement(compact).RapportClassement;
        }

        //  public string HrC { get { return getClassementEquiv(RapportClassement(true)); } }




        // private decimal _rapportClassement = -1;
        //public decimal RapportClassement
        //{
        //    get
        //    {
        //        return ClassementCache.RapportClassement;
        //        //if (parent != null)
        //        //    return parent.RapportClassement;
        //        //if (_rapportClassement != -1)
        //        //    return _rapportClassement;

        //        //decimal resultat = 0;
        //        //try
        //        //{
        //        //    return getRapport(ClassNameAndRating);
        //        //}
        //        //catch
        //        //{
        //        //}
        //        //_rapportClassement = resultat;
        //        //// _classementVirtuel = resultat; 
        //        //return _rapportClassement;
        //    }
        // }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        //private const int END_EQUIV = 13;
        //private const int NB_DEC_EQUIV = 8;
        public static string getStrClassement(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < Classement.END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + Classement.NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > Classement.NB_DEC_EQUIV)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return str;
        }
        public static string getClassementEquiv(decimal valRapport)
        {
            var str = getStrClassement(valRapport);
            return getReadableCl(str);
        }




        //public decimal RapportClassementDecimal
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return parent.RapportClassementDecimal;
        //        decimal resultat = 0;
        //        try
        //        {
        //            string str = ClassNameAndRating;
        //            char[] tab = str.ToCharArray();

        //            decimal K = 1m;
        //            int count = tab.GetLength(0);


        //            for (int i = 0; i < count; i++)
        //            {
        //                K = K * 6;
        //                int c = Convert.ToInt32(tab[i].ToString());
        //                resultat += (decimal)c / K;
        //            }
        //        }
        //        catch
        //        {
        //        }
        //        return resultat;
        //    }
        //}

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating(false);
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        misc.log("change artist from '{0}' to'{1}'", track.Artist, value);


                        gen.invalidateAlbums();
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        gen.invalidateAlbums();
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        gen.invalidateAlbums();
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.MasterPiece.Dates; }
        }
        //public string ArtWork
        //{
        //    get { return track.ArtWork; }
        //    set { track.ArtWork = value; }
        //}

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.MasterPiece.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {
                var list = DatesClassement;
                if (list.Count == 0)
                    return null;
                var dc = list[0];

                if (dc == DateTime.MinValue)
                    return null;
                if (dc == DateTime.MaxValue)
                    return null;

                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.MasterPiece.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }

        public bool ClassementRecentCompact
        {
            get
            {
                //  return !string.IsNullOrEmpty(compact(Classement.ToString())) && LastClassementRecent;
                return compact(Classement).isPositive() && LastClassementRecent;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? MasterAlbumUpdateClassement
        {
            get
            {
                var album = Master.album;
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }
        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public int NbRecentsInAlbum { get { if (album == null) return 0; return album.Recents; } }
        public int NbDoneInAlbum { get { if (album == null) return 0; return album.NbDone; } }
        public string PlusPetitEnabled
        {
            get
            {
                if (album == null || album.PlusPetitEnabled == null)
                    return "";
                return album.PlusPetitEnabled.Classement.ToString();
            }
        }

        public int MasterTrackNumber
        {
            get
            {
                if (parent == null)
                    return TrackNumber;
                return parent.TrackNumber;
            }
        }

        public int MasterTrackNumberForTri
        {
            get
            {
                var res = MasterTrackNumber;
                if (res <= 0)
                    return int.MaxValue;
                return res;
            }
        }

        public String ClassEvol { get { return track.MasterPiece.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            object o = PieceAlbum;
            if (o == null)
                o = VirtualMode;
            return string.Format("{0} {1}", o, track);
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }
        public string ClassementVirtuel { get { return Piece.getClassementEquiv(VirtualClassement); } }

#if GEN2

        private decimal _classementVirtuel;

       
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel2;
            }
        }
#else
        public decimal VirtualClassement { get { return RapportClassement(true); } }
        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(VirtualClassement); } }
        public decimal CoeffVirtuel
        {
            get
            {
                return 1;
            }
        }
        public decimal CoeffVirtuel2
        {
            get
            {
                return 1;
            }
        }

#endif

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        //private string getTimeValue(datesMode modeDates, timeMode modeTime)
        //{
        //    switch (modeTime)
        //    {
        //        case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
        //        case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
        //        case timeMode.last:
        //        case timeMode.equiv:
        //        case timeMode.equivNorm:
        //        var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //        if (modeTime == timeMode.equivNorm)
        //            return ts.FormatCustomTs(3, 2, 4);
        //        return ts.FormatCustomTs(2);

        //        case timeMode.delta:
        //        case timeMode.deltaNorm:

        //        var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //        var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
        //        var delta = tsf - ts0;
        //        delta = delta * 100;
        //        //if (modeTime == timeMode.deltaNorm)
        //        //    return delta.FormatCustom(3, 2, 4);
        //        return "(" + delta.FormatCustomTs(2) + ")";
        //        default:
        //        throw new NotImplementedException();

        //    }

        //    //if (modeTime == timeMode.complex)
        //    //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
        //    //else if (modeTime == Tuning.timeMode.simple)
        //    //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
        //    ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
        //    //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
        //    //{
        //    //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

        //    //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
        //    //        return ts.FormatCustom(3, 2, 4);
        //    //    return ts.FormatCustom(2);
        //    //}
        //    //else
        //    //{
        //    //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //    //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
        //    //    var delta = tsf - ts0;

        //    //    if (modeTime == timeMode.equivNorm)
        //    //        return delta.FormatCustom(3, 2, 4);
        //    //    return delta.FormatCustom(2);
        //    //}
        //}

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    return album.RankAlbumReverse;
                    //int rank = album.Quality;
                    //rank = Albums.RankZero - rank; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
                    //return rank;
                }
                return 0;
            }
        }

        public int DeltaRankAbs { get { return System.Math.Abs(RankAlbumReverse - RankAlbumZero); } }
        public int DeltaRank { get { return RankAlbumZero - RankAlbumReverse; } }

        //private string getGroup(List<DisplayGrouping> categories)
        //{
        //    StringBuilder sb = new StringBuilder();

        //    bool begin = false;

        //    displayCategory last = displayCategory.none;
        //    foreach (var category in categories)
        //    {
        //        try
        //        {
        //            if (begin //&& (int)category.category <= (int)displayCategory.pipe
        //                && last != displayCategory.croc1 && last != displayCategory.par1
        //                && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
        //                sb.Append(" ");
        //            begin = true;

        //            switch (category.category)
        //            {
        //                case displayCategory.rankSort:
        //                CTuning.format(sb, Rank.Sort); break;
        //                case displayCategory.rankDelta:
        //                CTuning.format(sb, Rank.RankDelta); break;
        //                case displayCategory.rankTime:
        //                CTuning.format(sb, Rank.RankRest); break;
        //                case displayCategory.rankAllAlbum:
        //                CTuning.format(sb, RankAllAlbum); break;
        //                case displayCategory.rankAlbum:
        //                if (album != null)
        //                    sb.Append(album.Rank.Sort); break;
        //                case displayCategory.rankAlbumReverse:
        //                sb.Append(RankAlbumReverse);
        //                break;
        //                case displayCategory.rankEquiv:
        //                if (album != null)
        //                    sb.Append(album.Equiv);
        //                break;
        //                case displayCategory.rankEquivLight:
        //                if (album != null)
        //                    sb.Append(album.EquivLight);
        //                break;
        //                case displayCategory.rankEquivLight0:
        //                if (album != null)
        //                    sb.Append(album.EquivLight0);
        //                break;
        //                case displayCategory.albumMoy:
        //                if (album != null)
        //                {
        //                    sb.Append(album.Moyenne);
        //                }
        //                break;
        //                case displayCategory.lenght:
        //                sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
        //                case displayCategory.sortValue:
        //                sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
        //                case displayCategory.tplay:
        //                sb.Append(getTimeValue(datesMode.play, category.mode)); break;
        //                case displayCategory.tclass:
        //                sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
        //                case displayCategory.tclassMin:
        //                sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
        //                case displayCategory.tmix:
        //                sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
        //                case displayCategory.tmixMin:
        //                sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
        //                case displayCategory.timeCoeff:
        //                sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
        //                case displayCategory.dplay:
        //                sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
        //                case displayCategory.dclass:
        //                sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
        //                break;
        //                case displayCategory.dclassMin:
        //                sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
        //                case displayCategory.dmix:
        //                sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
        //                break;
        //                case displayCategory.dmixMin:
        //                sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
        //                break;
        //                case displayCategory.pipe:
        //                sb.Append("|");
        //                break;
        //                case displayCategory.par1: sb.Append("("); break;
        //                case displayCategory.par2: sb.Append(")"); break;
        //                case displayCategory.croc1: sb.Append("["); break;
        //                case displayCategory.croc2: sb.Append("]"); break;

        //                default:
        //                break;
        //            }


        //            last = category.category;
        //        }

        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }
        //    }
        //    return sb.ToString();
        //}

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
            //gen.Albums.invalidate(Master); 
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }

        }

        public void setParent(Piece value)
        {

            if (value == parent)
                return;
            var old = parent;
            if (old != null)
            {
                old.albumMustRefresh();
                old.removeChild(this);
            }
            parent = value;
            if (parent == null)
            {
                if (old != null)
                {
                    this.PieceParentId = -1;
                }
            }
            else
            {
                parent = parent.Master;
                parent.addChild(this);
                this.PieceParentId = parent.MasterId;

            }
            if (album != null)
                this.album.mustRefresh();

        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private HashSet<Piece> childs = new HashSet<Piece>();
        public HashSet<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            if (childs.Contains(child))
                return;
            //throw new ApplicationException("enfant déjà enregistré " + this + " " + child); 


            childs.Add(child);

        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public void removeVirtualChilds()
        {
            List<Piece> list = null;
            foreach (var c in childs)
            {
                if (c.Virtual)
                {
                    // c.parent = null;
                    if (list == null)
                        list = new List<Piece>();
                    list.Add(c);
                }
            }
            if (list != null)
            {
                foreach (var c in list)
                {
                    childs.Remove(c);
                }
            }
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return MasterPiece.ExportStatus; // exportState;
            }
            set
            {
                MasterPiece.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return MasterPiece.RelativesPath; }
        }

        //public List<string> getIntermediaryPath()
        //{
        //    var list = new List<string>();
        //    foreach (var path in track.RelativesPath)
        //    {

        //        var tab = path.Split('\\');
        //        var sb = new StringBuilder();

        //        sb.Append(@"\");
        //        var count = tab.GetLength(0);
        //        for (int i = 0; i < count; i++)
        //        {
        //            var _s = tab[i];
        //            if (string.IsNullOrEmpty(_s))
        //                continue;

        //            var s = sb.ToString();
        //            if (!string.IsNullOrEmpty(s))
        //            {
        //                if (s.Length >= 2)
        //                {
        //                    list.Add(s);
        //                }
        //            }



        //            if (i > 0)
        //                sb.Append(@"\");
        //            sb.Append(_s);
        //        }
        //    }


        //    return list;


        //}

        const string ET = " et ";
        const string AND = " and ";
        const string WITH = " with ";
        const string AVEC = " avec ";
        const string EN_DUO_AVEC = " En Duo Avec ";


        public void buildVirtualAlbums(List<Piece> list)
        {
            HashSet<string> hs = new HashSet<string>();

         
            var reels = new List<Piece>();
            
            foreach (Piece p in this)
            {
                if (p.Virtual)
                {
                }
                else
                    reels.Add(p);

            }

            childs.Clear();
            foreach (Piece p in reels)
            {
                if (p == this)
                    continue;
                childs.Add(p);
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (!string.IsNullOrEmpty(p.Artist))
                    {
                        var virt = createVirtualAlbum(p.Artist, virtualMode.artist, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);


                        var artists = Regex.Replace(p.Artist, ET, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, AND, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, WITH, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, EN_DUO_AVEC, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, AVEC, "&", RegexOptions.IgnoreCase);
                        var tab = artists.Split(",;:&/\\".ToCharArray());
                        {
                            foreach (string part in tab)
                            {
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                if (part.Equals(p.Artist))
                                    continue;
                                var _part = part.Trim();
                                var virtp = createVirtualAlbum(_part, virtualMode.artist, hs);
                                if (virtp == null)
                                    continue;
                                list.Add(virtp);
                            }
                        }
                    }
                }

            }
            if (CConf.ConfGen.PathVirtual)
            {
                foreach (var path in MasterPiece.RelativesPath)
                {

                    var tab = path.Split('\\');
                    var sb = new StringBuilder();

                    sb.Append(@"\");
                    var count = tab.GetLength(0);
                    for (int i = 0; i < count; i++)
                    {
                        var _s = tab[i];
                        if (string.IsNullOrEmpty(_s))
                            continue;

                        var virt = createVirtualAlbum(sb.ToString(), virtualMode.path, hs);

                        if (virt != null)
                            list.Add(virt);



                        if (i > 0)
                        {
                            sb.Append(@"\");
                            if (i < count - 1)
                            {
                                var extended = createVirtualAlbum(_s, virtualMode.extended, hs);
                                if (extended != null)
                                    list.Add(extended);
                            }
                        }
                        sb.Append(_s);
                    }
                }
            }


            if (CConf.ConfGen.YearVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (p.Year > 0)
                    {
                        var strYear = p.Year.ToString();
                        if (strYear.Length == 4)
                        {
                            var decennie = strYear.Remove(3);
                            var virtDecennie = createVirtualAlbum(decennie, virtualMode.year, hs);
                            if (virtDecennie != null)
                                list.Add(virtDecennie);
                        }
                        var virt = createVirtualAlbum(strYear, virtualMode.year, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);
                    }
                }

            }

            if (CConf.ConfGen.AddedVirtual)
            {
                bool simu = CConf.ConfGen.AddedVirtualSimu;
                foreach (Piece p in reels)
                {
                    DateTime added = p.Added;
                    if (simu && added == DateTime.MinValue && album != null)
                        added = album.AlbumAdded;
                    if (added > DateTime.MinValue)
                    {
                        var strDate = added.ToString("dd/MM/yyyy");
                        var virt = createVirtualAlbum(strDate, virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.ToString("MM/yyyy"), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.Year.ToString(), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                    }
                }
            }
            if (CConf.ConfGen.WordVirtual)
            {
                foreach (Piece p in reels)
                {
                    buildAlbumWord(p.Name, list, hs);
                    buildAlbumWord(p.Album, list, hs);
                    buildAlbumWord(p.Artist, list, hs);
                    buildAlbumWord(p.Year.ToString(), list, hs);
                    buildAlbumWord(p.TrackNumber.ToString(), list, hs);
                }

                foreach (var path in MasterPiece.RelativesPath)
                {
                    buildAlbumWord(path, list, hs);
                }
            }

            //// supprimer les liaisons remontantes ? 
            //foreach (Piece p in childs)
            //{
            //    if (p.Virtual)
            //    {
            //        if (!childs.Contains(p))
            //        {
            //            p.parent = null; 
            //        }
            //    }
            //}


        }

        private void buildAlbumWord(string phr, List<Piece> list, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(phr))
                return;
            char[] sep = @"\/ ,;:.()_[]-{}".ToCharArray();
            var tab = phr.Split(sep);
            foreach (string str in tab)
            {
                if (!string.IsNullOrEmpty(str))
                {
                    var virt = createVirtualAlbum(str, virtualMode.word, hs);
                    if (virt != null)
                        list.Add(virt);
                }
            }
        }

        public Piece createVirtualAlbum(string path, virtualMode mode, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2 && (mode == virtualMode.path || mode == virtualMode.extended))
            {
                if (!CConf.ConfGen.VirtualRoot)
                    return null;
            }
            if (hs != null)
            {
                var key = pdb.gen.albums.Album.getKey(path, mode);
                if (!hs.Add(key))
                    return null;
            }
            VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track, Master, path, mode);
            //  virt.setParent(Master);
            return virt;
        }

        public void menageChilds()
        {
            if (parent != null)
                return;
            if (childs.Count == 0)
                return;
            var toDelete = new List<Piece>();

            HashSet<string> hs = new HashSet<string>();

            foreach (Piece p in childs)
            {
                if (p.Virtual)
                {
                    if (!hs.Add(p.PieceAlbum.Key))
                    {
                        toDelete.Add(p);
                    }
                }
            }
            foreach (Piece p in childs)
            {
                if (p.Parent != this)
                    toDelete.Add(p);
            }

            foreach (Piece p in toDelete)
            {
                //removeChild(p);
                p.setParent(null);
            }

        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        //  const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private static DateTime seuilCompact;
        public static DateTime SeuilCompact
        {
            get { return seuilCompact; }
            set
            {
                seuilCompact = value;
                if (seuilCompact > DateTime.Now)
                    seuilCompact = DateTime.MaxValue;
            }
        }
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in MasterPiece.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                if (!Enabled)
                    return false;
                if (seuilCompact == DateTime.MaxValue)
                    return true;
                foreach (DateTime dt in MasterPiece.DatesClassementBrut)
                {
                    if (dt > seuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        //public bool ClassementProvisoire
        //{
        //    get
        //    {
        //        if (RapportClassement(false) == 0)
        //            return false;
        //        var str = ClassName;
        //        int count = str.Length;
        //        if (count < 4)
        //            return true;
        //        if (count >= 8)
        //            return false;

        //        var tab = str.ToCharArray();
        //        int nb = 0;
        //        for (int i = 0; i < count; i++)
        //        {
        //            if (nb > 0)
        //                nb++;
        //            else
        //            {
        //                if (tab[i] != '0')
        //                {
        //                    nb++;
        //                }
        //            }
        //        }
        //        if (nb >= NB_CHAR_COMPLETE)
        //            return false;

        //        return true;

        //    }
        //}

        public bool Played { get { return track.Played; } }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return MasterPiece.DatesClassementBrut;
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public void setClassement(string classement)
        {
            MasterPiece.setClassement(classement);
        }

        void IPieceAlbum.setCoeff(decimal coeff, bool main)
        {

        }

        bool? IPieceAlbum.getSimpleCause()
        {
            return null;
        }



        public Classement Classement
        {
            get
            {
                var cl = Keep ? DeepClassement : MasterPiece.Classement;
                if (cl == null)
                    return Classement.NULL;
                return cl;
            }
        }

        //public string StrClassementCoeff
        //{
        //    get
        //    {
        //        if (!Keep)
        //            return Classement.ToString();
        //        var coeff = hsKeep[PieceId];
        //        if (coeff == 1m)
        //            return DeepClassement.ToString();
        //        var cl = classementHash.getCache(DeepClassement.ToString());

        //        var rapport = cl.RapportClassement;
        //        rapport *= coeff;
        //        var clReduit = getStrClassement(rapport);
        //        return clReduit;
        //        // return Keep ? DeepClassement : strClassement;
        //    }
        //}


        public Classement ClassementCoeff
        {
            get
            {
                if (!Keep)
                    return Classement;
                var coeff = hsKeep[PieceId];
                if (coeff == 1m)
                    return DeepClassement;
                var cl = DeepClassement;

                var rapport = cl.RapportClassement;
                rapport *= coeff;
                // var clReduit = getStrClassement(rapport);
                return Classement.create(rapport);
                // return Keep ? DeepClassement : strClassement;
            }
        }


        public Classement DeepClassement
        {
            get { return MasterPiece.DeepClassement; }
        }


        public Classement MaxClassement
        {
            get { return MasterPiece.MaxClassement; }
        }

        public IMasterPiece MasterPiece
        {
            get
            {
                return track.MasterPiece;
            }
        }

        bool IPieceAlbum.Enabled
        {
            get
            {
                return Enabled;
            }
        }



        Classement IPieceAlbum.Classement
        {
            get
            {
                return getClassement(true);
            }
        }

        decimal IPieceAlbum.Value
        {
            get
            {
                return RapportClassement(true);
            }

            set
            {

            }
        }

        bool IPieceAlbum.LastClassementRecent
        {
            get
            {
                return this.LastClassementRecent;
            }
        }

        Piece IPieceAlbum.Piece
        {
            get
            {
                return this;
            }
        }

        bool IPieceAlbum.Empty
        {
            get
            {
                return !this.Classement.isPositive();
            }
        }

        decimal IPieceAlbum.Coeff
        {
            set
            {

            }
        }

        bool IPieceAlbum.getCauseUp(bool? natureCause)
        {
            return false;
        }

        bool IPieceAlbum.UseCompact
        {
            get
            {
                return this.UseCompact;
            }

            set
            {
                this.UseCompact = value;
            }
        }
        void IPieceAlbum.Combine()
        { }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        added = 5,
        list = 6,
        word = 7
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        public int StackValue
        {
            get
            {

                return stackValue;
            }
            set
            {
                if (value > 0 && this.Name == "\\")
                {
                }
                else
                    stackValue = value;
            }
        }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstInAlbumEmpty = null;
            foreach (IPieceAlbum p in list)
            {
                if (p.Piece.Keep)
                {
                    firstInAlbumEmpty = p;
                    min= firstInAlbumEmpty; 
                    break;
                }
                var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1.isZero())
                                realZero = true;
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            if (firstInAlbumEmpty != null)
            {
                Next = firstInAlbumEmpty;
                cause.selectedMotifMin = cause.resultByFirstMin;
                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            }
            else
            {

                if (nextZero != null)
                {
                    decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                    decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                    if (realZero)
                    {
                        // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                        // j'applique le seuil que s'il est inférieur à la médiane

                        if (_minValue < classementValueLight)
                        {
                            if (min != null)
                            {
                                classementValueLight = _minValue;
                                if (real)
                                {
                                    Next = min;
                                    cause.selectedMotifMin = cause.resultByFirstMin;
                                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                    //if (mode.simple)
                                    //{
                                    //    cause.selectedMotifMin = !min.EffectMain;
                                    //}
                                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                    //    selectedCoeff = selectedCoeff.main;
                                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                    //    selectedCoeff = selectedCoeff.min;
                                    //if (_min < _min1 - EPSILON)
                                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                            }
                        }
                        else
                        {
                            if (real)
                            {
                                //if (_med0 == null)
                                //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                                if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                                {
                                    cause.selectedMotifMin = resultGlobalMin;
                                    cause.motifUp = true;
                                    cause.motifSure = true;

                                    //if (mode.simple)
                                    //{
                                    //    cause.selectedMotifMin = !median.EffectMain;
                                    //}
                                }
                                // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                Next = nextZero;

                            }
                        }
                    }
                    else
                    {
                        if (_minValue < classementValueLight)
                        {
                            if (min != null)
                            {
                                classementValueLight = _minValue;
                                if (real)
                                {
                                    Next = min;
                                    cause.selectedMotifMin = cause.resultByFirstMin;
                                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                    //    selectedCoeff = selectedCoeff.main;
                                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                    //    selectedCoeff = selectedCoeff.min;
                                    //if (_min < _min1 - EPSILON)
                                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                    //if (mode.simple)
                                    //{
                                    //    cause.selectedMotifMin = !min.EffectMain;
                                    //}
                                }
                            }

                        }
                        else if (_minZeroValue < classementValueLight)
                        {
                            classementValueLight = _minZeroValue;
                            if (real)
                            {
                                Next = nextZero;

                                cause.selectedMotifMin = cause.resultZeroMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    if (nextZero != null)
                                //        cause.selectedMotifMin = !nextZero.EffectMain;
                                //}
                            }
                        }

                        else
                        {

                            classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = resultGlobalMin;

                                cause.selectedMotifMin = Next.getSimpleCause();
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //    //  var p = list[med.index];
                                //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //        selectedCoeff = selectedCoeff.main;
                                //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //        selectedCoeff = selectedCoeff.min;
                                //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                                //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }

                        }
                    }
                }
                else
                {
                    // tous notés => on prend le plus faible
                    if (real)
                        Next = min;
                    if (min != null)
                    {
                        classementValueLight = _min.RapportClassement;
                        cause.selectedMotifMin = cause.resultByFirstMin;
                        if (Next != null)
                        {
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !Next.EffectMain;
                            //}
                        }
                    }

                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif
                    listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}|{1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, virtualMode mode)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using pdb.gen.medianne;
using pdb.gen.Tuning;

namespace pdb.gen.albums
{
    //public enum albumSortMode
    //{
    //    /// <summary>
    //    /// tri sur moyenne quand aucun des albums n'a défini sa médianne
    //    /// </summary>
    //    strict,
    //    /// <summary>
    //    /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mix,
    //    /// <summary>
    //    /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
    //    /// </summary>
    //    mixLight,
    //    /// <summary>
    //    /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mixLight2,
    //    /// <summary>
    //    /// Calcul médianne quasi strict, qq miettes pour éviter le zero
    //    /// </summary>
    //    medQuasi,
    //    /// <summary>
    //    /// Calcul Médianne moins strict
    //    /// </summary>
    //    medLight,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe2,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe3,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe4,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe5,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe6,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe10,
    //    /// <summary>
    //    /// tri uniquement sur la moyenne
    //    /// </summary>
    //    light

    //}
    class AlbumClassComparer : IComparer<Album>
    {
        private ConfAlbumSort mode;
        private ConfMedianne zero;
        private bool useSt;
        public AlbumClassComparer(ConfAlbumSort mode, bool useSt, ConfMedianne zero)
        {
            this.mode = mode;
            this.useSt = useSt;
            this.zero = zero;
        }
        private void calc(ref decimal xx, ref decimal yy, Album x, Album y, ConfMedianne cmpt)
        {
            switch (cmpt.type)
            {
                case medianneMode.none:
                break;
                case medianneMode.strict:
                xx = x.ClassementValue; yy = y.ClassementValue;
                break;
                case medianneMode.light:
                if (useSt)
                {
                    if (zero == null)
                    {
                        xx = x.ClassementValueLightSt;
                        yy = y.ClassementValueLightSt;
                    }
                    else
                    {
                        xx = x.ClassementValueLightZeroSt;
                        yy = y.ClassementValueLightZeroSt;
                    }
                }
                else
                {
                    if (zero == null)
                    {
                        xx = x.ClassementValueLight;
                        yy = y.ClassementValueLight;
                    }

                    else
                    {
                        xx = x.ClassementValueLightZero;
                        yy = y.ClassementValueLightZero;
                    }
                }
                break;
                case medianneMode.moy:
                throw new System.NotImplementedException(); // xx = x.ClassementMoy; yy = y.ClassementMoy;
                break;
                default:
                break;
            }
        }

        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;


            int cmp = 0;




            decimal xx = 0;
            decimal yy = 0;

            var composants = mode.ComposantsUtiles;
            if (composants.Count > 1)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    var cmpt2 = composants[1];
                    calc(ref xx, ref yy, x, y, cmpt2);
                    cmp = xx.CompareTo(yy);
                    if (cmp != 0)
                        return cmp;
                }

            }

            var cmpt = composants[0];
            if (zero != null)
                cmpt = zero;
            calc(ref xx, ref yy, x, y, cmpt);

            cmp = xx.CompareTo(yy);
            if (cmp != 0)
                return cmp;

            //if (mode == albumSortMode.light)
            //{
            //    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //    if (cmp != 0)
            //        return cmp;
            //}
            //else if (mode == albumSortMode.mix)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight2)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    else
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.medLight
            //    || mode == albumSortMode.medQuasi
            //    || mode == albumSortMode.medLightSafe
            //    || mode == albumSortMode.medLightSafe2
            //    || mode == albumSortMode.medLightSafe3
            //    || mode == albumSortMode.medLightSafe4
            //    || mode == albumSortMode.medLightSafe5
            //    || mode == albumSortMode.medLightSafe6
            //    || mode == albumSortMode.medLightSafe10
            //    )
            //{
            //    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //    if (cmp != 0)
            //        return cmp;
            //}

            if (xx > 0)
            {
                cmp = x.VirtualMode.CompareTo(y.VirtualMode);
                if (cmp != 0)
                    return cmp;
                cmp = x.Count.CompareTo(y.Count);
                if (cmp != 0)
                    return cmp;
            }
            else
            {
                cmp = x.Count.CompareTo(y.Count);
                if (cmp != 0)
                    return -cmp;
            }

            var xNext = x.Next;
            var yNext = y.Next;
            if (xNext == null && yNext == null)
            {

            }
            else
            {
                if (xNext == null)
                    return 1;

                if (yNext == null)
                    return -1;

                cmp = xNext.Duration.CompareTo(yNext.Duration);
                if (cmp != 0)
                    return cmp;
            }

            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            //cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //if (cmp != 0)
            //    return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;

            var lx = new List<Piece>(x);
            var ly = new List<Piece>(y);
            //while (true)
            //{
            //    t1 = x.getTrackSortValue(i, lx);
            //    t2 = y.getTrackSortValue(i, ly);

            //    cmp = t1.CompareTo(t2);
            //    if (cmp != 0)
            //        return cmp;



            //    if (t1 == 0)
            //        break;

            //    i++;

            //}
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    //class AlbumClassComparerStack : IComparer<Album>
    //{
    //    public int Compare(Album x, Album y)
    //    {
    //        //int cmp = x.StackIndex.CompareTo(y.StackIndex);
    //        //if (cmp != 0)
    //        //    return cmp;
    //        return x.Rank.Sort.CompareTo(y.Rank.Sort);
    //    }
    //}

    public class AlbumClassComparer2 : IComparer<Album>
    {
        public virtual int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Quality.CompareTo(y.Quality);
        }
    }

    public class AlbumClassComparer2Inv : AlbumClassComparer2
    {
        public override int Compare(Album x, Album y)
        {
            return -base.Compare(x, y);
        }
    }

    //class VirtualPieceComparer : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        // mode normal
    //        if (x.PieceId == y.PieceId)
    //            return 0;
    //        int cmp = x.Artist.CompareTo(y.Artist);
    //        if (cmp != 0)
    //            return cmp;
    //        cmp = x.Master.Album.CompareTo(y.Master.Album);
    //        if (cmp != 0)
    //            return cmp;
    //        var xt = x.MasterTrackNumber > 0 ? x.MasterTrackNumber : x.TrackNumber;
    //        var yt = y.MasterTrackNumber > 0 ? y.MasterTrackNumber : y.TrackNumber;

    //        cmp = xt.CompareTo(yt);
    //        if (cmp != 0)
    //            return cmp;
    //        //var xx = "";
    //        //var yy = "";

    //        var xpath = x.getLocation();
    //        var ypath = y.getLocation();
    //        if (xpath == ypath)
    //            return 0;

    //        return xpath.CompareTo(ypath);
    //        // mode inverse

    //    }
    //}


    //class AlbumSortComparer : IComparer<Album>
    //{
    //    public int Compare(Album x, Album y)
    //    {
    //        if (x == y)
    //            return 0;

    //        if (x == null)
    //            return 1;

    //        if (y == null)
    //            return -1;

    //        int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
    //        if (cmp != 0)
    //            return cmp;

    //        if (x.Rank.SortValue == 0)
    //        {

    //        }

    //        var xx = x.getFirstTrackSortValue();
    //        var yy = y.getFirstTrackSortValue();

    //        return xx.CompareTo(yy);

    //    }
    //}

    //class AlbumRestComparer : IComparer<Album>
    //{
    //    static IComparer<Album> subCmp = new AlbumClassComparer2();
    //    const decimal EPSILON = 0.00001m;
    //    public int Compare(Album x, Album y)
    //    {
    //        var xx = x.TimeRest;
    //        var yy = y.TimeRest;
    //        int cmp = 0;
    //        if (System.Math.Abs(xx - yy) >= EPSILON)
    //            cmp = xx.CompareTo(yy);
    //        if (cmp == 0)
    //            return subCmp.Compare(x, y);
    //        return cmp;
    //    }
    //}



    //class PieceInVirtualAlbumComparer : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        var xt = x.MasterTrackNumber > 0 ? x.MasterTrackNumber : x.TrackNumber;
    //        var yt = y.MasterTrackNumber > 0 ? y.MasterTrackNumber : y.TrackNumber;

    //        int cmp = xt.CompareTo(yt);
    //        if (cmp != 0)
    //            return cmp;
    //        //var xx = "";
    //        //var yy = "";

    //        var xpath = x.getLocation();
    //        var ypath = y.getLocation();
    //        if (xpath == ypath)
    //            return 0;
    //        //if (x.Master.TrackNumber <= 0)
    //        //{
    //        //    try
    //        //    { 
    //        //        cmp = x.TrackNumber.CompareTo(y.TrackNumber); 
    //        //        if (cmp !=0)
    //        //            return cmp; 

    //        //        var xf = Path.GetFileNameWithoutExtension(xpath);
    //        //        var yf = Path.GetFileNameWithoutExtension(xpath);
    //        //        cmp = xf.CompareTo(yf);
    //        //        if (cmp != 0)
    //        //            return cmp;
    //        //    }
    //        //    catch
    //        //    {
    //        //    }
    //        //}

    //        //if (x != null && x.getLocation() != null) xx = x.getLocation();
    //        //if (y != null && y.getLocation() != null) yy = y.getLocation();
    //        return xpath.CompareTo(ypath);
    //    }
    //}

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.getLocation());
                    var f2 = Path.GetFileName(y.getLocation());
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.getLocation().CompareTo(y.getLocation());
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public virtual int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparerInv : AllPieceComparer
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public override int Compare(Piece x, Piece y)
        {
            return -base.Compare(x, y);
        }
    }

    //class AllPieceComparer2 : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
    //    }
    //}

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }

    //class AlbumLastModifClassementComparer : IComparer<Album>
    //{
    //    public int Compare(Album x, Album y)
    //    {


    //        var dtx = x.UpdateClassement;
    //        var dty = y.UpdateClassement;
    //        int cmp =0;
    //        if (dtx == null)
    //        {
    //            if (dty == null)
    //            {
    //            }
    //            else
    //                cmp = -1;
    //        }
    //        else if (dty == null)
    //            cmp = 1;
    //        else
    //            cmp = dtx.Value.CompareTo(dty.Value); 


    //        if (cmp != 0)
    //            return cmp;
    //        return x.Name.CompareTo(y.Name);
    //    }
    //}

    class VirtualAlbumComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            var cmp = x.VirtualMode.CompareTo(y.VirtualMode);
            if (cmp != 0)
                return cmp;
            cmp = x.Name.Length.CompareTo(y.Name.Length);
            if (cmp != 0)
                return cmp;
            return x.Name.CompareTo(y.Name);
        }
    }


    class VirtualAlbumComparerForWrite : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            var cmp = x.Count.CompareTo(y.Count);
            if (cmp != 0)
                return cmp;
            cmp = x.VirtualMode.CompareTo(y.VirtualMode);
            if (cmp != 0)
                return cmp;
            cmp = x.Name.Length.CompareTo(y.Name.Length);
            if (cmp != 0)
                return cmp;
            return x.Name.CompareTo(y.Name);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;
using System.Xml;
using System.Text;
using System.IO;
using System.Threading;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public const string FILE_ALBUMS = @"..\conf\albums.xml";
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
            new Thread(loop) { Priority = ThreadPriority.Lowest, Name = "scan albums" }.Start();
        }

        Logger logScan = Logger.getLogger("scan albums", true);

        /// <summary>
        /// référence constante des albums
        /// </summary>
        //   private BgDictString<Album> dict0 = new BgDictString<Album>();
        /// <summary>
        /// Albums réels ou virtuels
        /// </summary>
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }
        private volatile object _lockSort2 = new object();
        private Album currentSorted;



        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                //foreach (Album album in dict0.Values)
                //{
                //    album.checkBuild();
                //}
                dict.Clear();
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.ArtistVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            //album.Clear(); 
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string key = getKey(albumOrg, mode);


            var album = dict[key];
            if (album == null)
            {
                //album = dict0[key];
                //if (album == null)
                //{
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, key);
                album.setVirtual(mode);
                dict.Add(key, album);
                // dict0.Add(key, album);

            }

            //  }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public static int RankZero { get; set; }



        const char SEP = ';';
        const char SEP_TRACK = ',';

        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }


            var listAlbums = new List<Album>(dict.Values);
            listAlbums.Sort(new VirtualAlbumComparerForWrite());

            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;

            //using (StreamWriter sw = new StreamWriter(FILE_ALBUMS + ".tmp"))
            //{
            //    foreach (Album album in listAlbums)
            //    {
            //        if (!album.Virtual)
            //            continue;

            //        sw.Write(album.VirtualMode);
            //        sw.Write(SEP);

            //        sw.Write(album.Name);
            //        sw.Write(SEP);

            //        var list = album.RawList;
            //        list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //        bool begin = false;
            //        foreach (Piece p in list)
            //        {
            //            if (begin)
            //                sw.Write(SEP_TRACK);
            //            else
            //                begin = true;
            //            sw.Write(p.MasterId);
            //        }
            //        sw.WriteLine();

            //    }

            //}

            using (XmlWriter writer = XmlWriter.Create(FILE_ALBUMS + ".tmp", settings))
            {
                writer.WriteStartElement("albums");
                foreach (Album album in listAlbums)
                {
                    if (!album.Virtual)
                        continue;
                    writer.WriteStartElement("a");
                    writer.WriteAttributeString("mode", album.VirtualMode.ToString());
                    writer.WriteAttributeString("name", album.Name);
                    writer.WriteAttributeString("nb", album.Count.ToString());
                    var list = album.RawList;
                    list.Sort((x, y) => x.MasterId.CompareTo(y.MasterId));
                    bool begin = false;
                    var sb = new System.Text.StringBuilder();
                    foreach (Piece p in list)
                    {
                        if (begin)
                            sb.Append(SEP_TRACK);
                        else
                            begin = true;
                        sb.Append(p.MasterId);
                    }

                    writer.WriteString(sb.ToString());

                    //foreach (Piece p in list)
                    //{
                    //    writer.WriteElementString("t", p.MasterId.ToString());
                    //}
                    writer.WriteEndElement();
                }


                writer.WriteEndDocument();
                writer.Flush();
            }

            System.IO.File.Copy(FILE_ALBUMS + ".tmp", FILE_ALBUMS, true);

        }

        public int load(IDictionary<int, Piece> dict)
        {

            //using (StreamReader sr = new StreamReader(FILE_ALBUMS))
            //{

            //    var line = sr.ReadLine();
            //    var tabs = line.Split(SEP);
            //    int count = tabs.GetLength(0); 

            //    var name = tabs[1];
            //    var mode = (virtualMode)Enum.Parse(typeof(virtualMode), tabs[0], true);
            //    Album current = new Album(name, mode);
            //    this.dict.Add(current.Key, current);
            //    int tn = 0;
            //    var tracks = tabs[2].Split(SEP_TRACK);
            //    foreach (string sid in tracks)
            //    {
            //        tn++;
            //        var id = Convert.ToInt32(sid);
            //        Piece track = dict[id];
            //        VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
            //        virt.TrackNumber = tn;
            //        current.add(virt);
            //    }


            //}
            int nbLoad = 0;
            using (XmlReader reader = XmlReader.Create(FILE_ALBUMS))
            {
                Album current = null;

                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {

                        if (reader.Name == "a")
                        {
                            var name = reader.GetAttribute("name");
                            var mode = (virtualMode)Enum.Parse(typeof(virtualMode), reader.GetAttribute("mode"), true);
                            current = new Album(name, mode);
                            int tn = 0;
                            this.dict.Add(current.Key, current);


                            var line = reader.ReadElementString();
                            foreach (string sid in line.Split(SEP_TRACK))
                            {
                                tn++;
                                var id = Convert.ToInt32(sid);
                                Piece track = dict[id];
                                var virt = new VirtualAlbumPieceLight(track.Track, track);
                                // VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                                virt.TrackNumber = tn;
                                current.add(virt);
                            }

                            nbLoad++;

                        }



                        //else if (reader.Name == "t")
                        //{
                        //    tn++;
                        //    var id = reader.ReadElementContentAsInt();
                        //    Piece track = dict[id];
                        //    VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                        //    virt.TrackNumber = tn;
                        //    current.add(virt);

                        //}

                    }
                }

            }
            return nbLoad;
        }

        //public void consolidChilds()
        //{
        //    misc.log("consolidChilds");
        //    foreach (Album album in dict.Values)
        //    {
        //        album.ConsolidChilds();
        //    }
        //}

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {
            if (piece.Virtual)
            {
                if (!check_(piece, dict))
                {
                }
                // piece.setParent(null);
            }

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }

        // private Dictionary<string, Album> invalidated;
        public IDictionary<string, Album> GetAndInvalidateAlbums(Piece piece)
        {
            var invalidated = new Dictionary<string, Album>();
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.refreshLight();
                invalidated.Add(album.Key, album);
            }
            return invalidated;
        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(Piece piece, ILogger logger)
        {
            if (piece == null)
                return 0;
            int nb = 0;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;
                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();
                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference);                
                    nb++;
                    //  album.mustRefresh();
                    // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                    album.refreshLight();
                }
            }

            return nb;

        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(IEnumerable<Album> _albums, ILogger logger)
        {
            int nb = 0;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;

                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();

                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference); 
                }

                nb++;
                //  album.mustRefresh();
                // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                // album.refreshLight();
            }

            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;
                album.refreshLight();
            }

            return nb;

        }

        // private int nbSort=1;
        //private bool urgence;
        //public void setUrgence() { urgence = true; }
        //public bool Urgence { get { return urgence; } } 
        public void makeSort(bool sortAll, IClient client, ILogger logger)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;

                bool partial = false;
#if GEN2
                partial = !sortAll && confSort.optimSize > 0 && consolid.Urgence;
#endif

                int step = 0;
                Album last = null;
                // int coeffSort = 1;

                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }
                    if (!consolid.Urgence)
                    {
                        int nbSorted = 0;
                        //if (invalidated != null && invalidated.Count > 0)
                        //{
                        //    listw = new List<Album>(invalidated.Values);
                        //    invalidated = null;
                        //}
                        listw.Sort((x, y) => x.Count.CompareTo(y.Count));
                        foreach (Album album in listw)
                        {
                            if (client.Cancel)
                                return;

                            goParallel = false;
                            while (currentSorted == album)
                                Thread.Sleep(30);

                            if (album.makeSort(confMedianne, conf0, logger, 100)) //listRef, reference); 
                                nbSorted++;

                        }

                        string infoAlbum = "";
                        if (last != null)
                        {
                            infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                        }
                        //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        client.log(string.Format("album.makeSort {0} elt", nbSorted));
                    }
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    misc.log("list.Sort(new AlbumClassComparer {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


                    list.Reverse();
                    misc.log("list.Reverse(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    client.log("AlbumClassComparer");

                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i + 2;
                        album.Quality = i + 1;
                    }
                    client.log("album.Quality");
                    misc.log("album.Quality {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                client.log("tri pour faire joli");
#if GEN2
                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }



                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }


                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

#endif


                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
                var limit = CConf.ConfGen.LimitAlbums;
                if (limit > 0)
                {
                    var l = new List<Album>();
                    list.Sort(new AlbumClassComparer2());
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (i < limit)
                        {
                            l.Add(album);
                            album.ConsolidChilds();
                            album.sortVirtual();
                        }
                        else
                        {
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }
                    }
                    list = l;

                }

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            //list.Sort(new AlbumRestComparer());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                //if (candidat.VirtualMode == virtualMode.added)
                //{
                //    if (candidat.Name=="09/1012")
                //    {

                //    }
                //    if (candidat.Name =="22/09/2012")
                //    {

                //    }
                //}
                bool found = false;

                foreach (Piece p in candidat)
                {
                    var master = p.Master.PieceAlbum;
                    if (master.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    foreach (Album album in dict.Values)
                    {
                        if (album.isSameOf(candidat))
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.ClearAndMenage();
                }
                else
                {
                    // on le prend.
                    string key = getKey(candidat.Name, candidat.VirtualMode);
                    //if (!dict0.ContainsKey(key))
                    //    dict0.Add(key, candidat);
                    dict.Add(key, candidat);
                    foreach (Piece p in candidat)
                    {
                        //   p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }


        public List<Album> RawList
        {
            get
            {
                return new List<Album>(dict.Values);
            }
        }

        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }


        private bool goParallel;
        public void parallelSort()
        {
            goParallel = true;
        }
        public void endParallelSort()
        {
            goParallel = false;
        }
        private void loop()
        {
            while (true)
            {

                currentSorted = null;
                Thread.Sleep(3000);
                if (!goParallel)
                    continue;
                var list = new List<Album>(dict.Values);
                if (!goParallel)
                {
                    logScan.log("arret list = new List<Album>(dict.Values) ");
                    continue;
                }
                list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));
                if (!goParallel)
                {
                    logScan.log("arret list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));");
                    continue;
                }
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }
                var conf0 = new ConfMedianne(confMedianne, true);
                if (!goParallel)
                {
                    logScan.log("arret confMedianne;");
                    continue;
                }


                foreach (Album album in list)
                {
                    if (!goParallel)
                    {
                        logScan.log("arret avant album " + album);
                        break;
                    }

                    lock (album)
                    {
                        if (!goParallel)
                        {
                            logScan.log("arret sur lock album " + album);
                            break;
                        }
                        currentSorted = album;
                        album.mustRefresh();
                        album.makeSort(confMedianne, conf0, logScan, 100);
                    }
                }
                if (goParallel)
                {
                    logScan.log("fin sans interruption");
                    goParallel = false;
                }
            }
        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion





    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Classement.cs">
    <content><![CDATA[using System;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.obj
{
    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }


    /// <summary>
    /// type de base de la donnée classement : 
    /// paire : liste / rating 
    /// 
    /// </summary>
    /// <remarks>utilisé comme une valeur simple (entier - string)</remarks>
    public class Classement : IComparable<Classement>, IComparable
    {
        private static Dict<string, Classement> dict = new Dict<string, Classement>();
        public static Regex regClassement = new Regex(@"([0-5]+)\.([0-5])");
        public static Regex regClassement2 = new Regex(@"([0-5]+)");
        //  private static bool isClassement(string input) { return string.IsNullOrEmpty(input) || regClassement.IsMatch(input) || ; }
        private static Classement _NULL = new Classement("");
        private static Classement _ZERO = new Classement("0");
        public static Classement NULL { get { return _NULL; } }
        public static Classement ZERO { get { return _ZERO; } }
        private static Classement lastServe;
        public static bool canBeClassement(string input)
        {
            if (string.IsNullOrEmpty(input))
                return true;
            if (regClassement2.IsMatch(input))
                return true;
            if (regClassement.IsMatch(input))
                return true;
            return false;

        }

        public int Rating
        {
            get
            {
                if (this == _NULL || this == _ZERO)
                    return 0;
                return 20 * (Convert.ToInt32(m_class[m_class.Length - 1]));
            }
        }
        public static void Free()
        {
            dict.Clear();
        }
        public static Classement create(string input)
        {
            if (input != null)
                input = input.Replace(" ", "").Trim().Replace(".", "");
            if (input == "0" || input == "00")
                return _ZERO;

            if (string.IsNullOrEmpty(input))
                return _NULL;
            //if ("0.0".Equals(input))
            //    return ZERO;

            if (!canBeClassement(input))
                return null;
            if (lastServe != null)
            {
                if (lastServe.m_class == input)
                    return lastServe;
            }

            if (dict.ContainsKey(input))
            {
                return dict[input];
            }
            lastServe = new Classement(input);

            //var groups = regClassement.Match(input).Groups;
            //var cl = new Classement(groups[1].Value,groups[2].Value); //  (Convert.ToInt32(groups[2].Value)));
            // dict[input] = cl;
            // return cl;
            return lastServe;
        }

        public static Classement create(string className, int rating)
        {
            if (rating < 0)
                return _NULL;
            var input = string.Format("{0}{1}", className, rating);
            return create(input);

        }






        public decimal RapportClassement
        {
            get
            {

                decimal resultat = 0;
                if (this == _ZERO || this == _NULL)
                    return resultat;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }
        public const int END_EQUIV = 25;
        public const int NB_DEC_EQUIV = 8;
        public static Classement create(decimal valRapport)
        {
            if (valRapport < 0)
                return _NULL;
            if (valRapport == 0m)
                return _ZERO;
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            //sb = new StringBuilder();
            //int indexPt = lastNotNull - 1;
            //if ((lastNotNull - firstNotNull) > NB_DEC_EQUIV)
            //    indexPt--;
            ////if (str.Length == 5)
            ////    indexPt--; 

            //for (int j = 0; j <= lastNotNull; j++)
            //{

            //    sb.Append(str[j]);
            //    if (j == indexPt)
            //        sb.Append('.');

            //}
            //str = sb.ToString();
            // str.Insert(str.Length - 1, ".");
            //return str;

            return create(str);
        }


        private string m_class = "";
        // private int m_rating = -1;
        private Classement(string main, string rating)
        {
            m_class = string.Format("{0}{1}", main, rating);
        }
        private Classement(string a_class)
        {
            m_class = a_class;
            // m_rating = a_rating;
        }

        private Classement(Classement o)
        {
            m_class = o.m_class;
            //  m_rating = o.m_rating;

        }
        //public string ClassList
        //{
        //    get { return string. m_class; }
        //    // set { m_class = value; }
        //}
        //public int Rating
        //{
        //    get { return m_rating; }
        //    //   set { m_rating = value; }
        //}
        public override bool Equals(object obj)
        {
            if (obj is Classement)
            {
                Classement l_obj = (Classement)obj;
                return m_class.CompareTo(l_obj.m_class) == 0; // && m_rating == l_obj.m_rating;
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_class.GetHashCode();  //+ m_rating.GetHashCode();
        }

        #region rang
        private Bool m_numericClassList;
        //private String m_classNameAndRating = "";
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                if (m_numericClassList == Bool.not_defined)
                {
                    if (String.IsNullOrEmpty(m_class)) return false;
                    bool res = m_class.isInteger();  //CUtil.isInteger(m_class);
                    m_numericClassList = res ? Bool.True : Bool.False;
                    return res;
                }
                else
                {
                    return m_numericClassList == Bool.True ? true : false;
                }
            }
        }
        public String ClassNameAndRating
        {
            get
            {
                return m_class;
                //if (!isClassListNumeric) return "." + m_rating;
                //return m_class + m_rating;
            }
        }

        public String ClassNameAndRatingWithPt
        {
            get
            {
                if (!isClassListNumeric) return m_class;// "." + m_rating;
                if (m_class.Length < 2)
                    return m_class;
                return m_class.Insert(m_class.Length - 1, ".");
                //   return  m_class. + "." + m_rating;
            }
        }
        /// <summary>
        /// Donne la valeur du classement. Pratique pour la comparaison
        /// </summary>
        /// <returns></returns>
        public double getNormValue()
        {
            if (!isClassListNumeric)
                return -1;
            string classNameAndRating = ClassNameAndRating;
            string strDouble = classNameAndRating.Insert(1, ",");
            return Convert.ToDouble(strDouble);
        }

        //private String getNbStars() { return (m_rating / 20).ToString(); }
        public override string ToString()
        {
            return ClassNameAndRatingWithPt;
            //if (!isClassListNumeric) return m_class;
            //return String.Format("{0}.{1}", m_class, m_rating);
        }




        public decimal ClassementValueDecimal
        {
            get
            {
                if (!isClassListNumeric) return 0;
                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                return Convert.ToDecimal(classNameAndRating);
            }
        }

        public bool isNull()
        { return this == _NULL; }

        public bool isClassed()
        {
            return this != _NULL;
        }

        public bool isPositive()
        {
            return isClassed() && this != _ZERO;
        }

        public bool isZero()
        {
            return this == _ZERO || this == _NULL;
        }

        //public static bool operator ==(Classement c1, Classement c2)
        //{
        //    if ( Object.ReferenceEquals(c1,c2))
        //        return true;
        //    if (Object.ReferenceEquals(c1,null))
        //        return false;
        //    return c1.CompareTo(c2) == 0;
        //}
        //public static bool operator !=(Classement c1, Classement c2)
        //{
        //   return !(c1 == c2); 
        //}


        public static bool operator >(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return true;
            return c1.CompareTo(c2) > 0;
        }
        public static bool operator >=(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return true;
            return c1.CompareTo(c2) >= 0;
        }
        public static bool operator <(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return true;
            return c1.CompareTo(c2) < 0;
        }
        public static bool operator <=(Classement c1, Classement c2)
        {
            if (c1 == null)
                return false;
            if (c2 == null)
                return true;
            return c1.CompareTo(c2) <= 0;
        }

        //public static bool operator ==(Classement c1, decimal d)
        //{
        //    if (c1 == null)
        //        return false;
        //    if (d == 0)
        //        return c1.isZero();
        //    return c1.RapportClassement == d;
        //}
        //public static bool operator !=(Classement c1, decimal d)
        //{
        //    return !(c1 == d);
        //}

        //public static bool operator >(Classement c1, decimal d)
        //{
        //    if (c1 == null)
        //        return false;
        //    if (d == 0)
        //        return c1.isPositive();
        //    return c1.RapportClassement > d;
        //}
        //public static bool operator <(Classement c1, decimal d)
        //{
        //    return !(c1 > d);
        //}

        //public static bool operator >=(Classement c1, decimal d)
        //{
        //    if (c1 == null)
        //        return false;
        //    if (d == 0)
        //        return true; 
        //    return c1.RapportClassement >= d;
           
        //}
        //public static bool operator <=(Classement c1, decimal d)
        //{
        //     if (c1 == null)
        //        return false;
        //    if (d == 0)
        //        return c1.isZero(); 
        //    return c1.RapportClassement <= d;
        //}

        #endregion


        public int CompareTo(Classement other)
        {
            if (other == this)
                return 0;
            if (other == null)
                return 1;
            if (m_class.isNullorEmpty())
            {
                if (other.m_class.isNullorEmpty())
                    return 0;
                return -1;
            }
            if (other.m_class.isNullorEmpty())
                return 1;
            int cmp = 0;
            int count = m_class.Length;
            int ocount = other.m_class.Length;
            for (int i = 0; i < count && i < ocount; i++)
            {
                var c = m_class[i];
                var oc = other.m_class[i];
                cmp = c.CompareTo(oc);
                if (cmp != 0)
                    return cmp;
            }
            if (count < ocount)
            {
                return -1;
                //var otherC = Convert.ToInt32(other.m_class[count].ToString());
                //cmp = m_rating.CompareTo(otherC);
                //if (cmp != 0)
                //    return cmp;
                //return -1;
            }
            else if (count > ocount)
            {
                return 1;
                //var rating = other.m_rating;
                //var value = Convert.ToInt32(m_class[ocount].ToString());
                //cmp = value.CompareTo(rating);
                //if (cmp != 0)
                //    return cmp;
                //return 1;
            }
            else
            {
                return 0;
                //var rating = this.m_rating;
                //var orating = other.m_rating;
                //cmp = rating.CompareTo(orating);
                //return cmp;
            }
        }

        public int CompareTo(object obj)
        {
            var o = obj as Classement;
            if (o == null)
                return 1;
            return CompareTo(o);
        }
    }
}
]]></content>
  </file>
</db>
