using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbRepecheForce = 0;
        public static int NbRepeches { get { return nbrepeches; } }
        public static int NbModif { get { return nbModif; } }
        private bool done;
        public static void Init()
        {
            //lastReads.Clear(); 
            nbrepeches = 0;
            nbModif = 0;
            nbRepecheForce = 0;
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }

        //public void Build(Loader loader)
        //{

        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;
        //    int indexLastRead = -1;
        //    int indexNextSelected = -1;
        //    DateTime lastPlayed = DateTime.MinValue;
        //    TrackSort next = null;
        //    TrackSort reallyLastRead = null;
        //    DateTime currentPub = DateTime.MinValue;
        //    DateTime currentPub2 = DateTime.MinValue;
        //    TrackSort lastRead = null;



        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (track.Selected)
        //        {
        //            next = track;
        //            indexNextSelected = i;
        //            break;
        //        }
        //    }

        //    if (next == null)
        //        return;

        //    int nbRead = 0;
        //    int nbTotal = 0;

        //    var histo = conf.getHisto(album.Rare);

        //    DateTime limit = next.Pub.AddDays(-histo);
        //    for (int i = indexNextSelected - 1; i >= 0; i--)
        //    {
        //        var t = list[i];
        //        var dt = t.Pub;
        //        if (dt < limit)
        //            break;

        //        if (t.Played)
        //            nbRead++;

        //        if (t.Played || t.track.Enabled)
        //            nbTotal++;

        //    }
        //    double delta = conf.getIntervalle(album.Rare);
        //    var intervalle = conf.getIntervalle(album.Rare);
        //    var intervalleMin = conf.getIntervalleMin(album.Rare);
        //    if (nbRead > 0 && nbTotal > 0)
        //    {
        //        //  album.Rare ? conf.intervalleR : conf.intervalle;
        //        var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

        //        delta = (intervalle * (double)nbTotal) / (ecouteMax * (double)nbRead);
        //        var coeff = (double)nbTotal / (double)nbRead;

        //        //0.1 => 10
        //        //0.9 => 1.11
        //        coeff -= 1; // 9  0.11
        //        var dminmax = intervalle - intervalleMin;

        //        var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

        //        if (_delta < delta)
        //            delta = _delta;
        //        else
        //        {
        //        }
        //    }


        //    var deltaLecture = (DateTime.Now - reallyLastRead.PlayedDate).TotalDays;



        //    for (int j = 0; j < indexNextSelected; j++)
        //    {
        //        for (int i = j; i < indexNextSelected; i++)
        //        {
        //            var track = list[i];
        //            if (track.Played)
        //            {
        //                reallyLastRead = track;
        //                lastRead = track;
        //                indexLastRead = i;
        //                lastPlayed = track.PlayedDate;
        //                j = i;
        //                break;
        //            }
        //        }
        //        var pub2 = lastRead.Pub2;

        //        if (conf.extPente > 0)
        //        {
        //            var d0 = (DateTime.Now - pub2).TotalDays;
        //            var dl = conf.extDelta;
        //            if (dl == 0)
        //            {
        //                dl = d0;
        //            }

        //            delta = d0 / conf.extPente;
        //            //01/01/2014 ->01/01/2017
        //            //04/01/2017 -> 04/01/2014
        //            var dateLimitEcoule = DateTime.Now.AddDays(-dl);

        //            var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
        //            log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

        //            if (deltaLimiteEcoule > delta)
        //                delta = deltaLimiteEcoule;

        //            if (delta < 1)
        //                delta = 1;



        //        }

        //        if (conf.limitRead && deltaLecture > intervalle)
        //        {
        //            //13 /10 ->7
        //            var _old = delta;

        //            delta += intervalle - deltaLecture;
        //            log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
        //        }

        //        if (delta < intervalleMin)
        //            delta = intervalleMin;

        //        if (delta > intervalle)
        //            delta = intervalle;


        //        DateTime limitFuture = pub2.AddDays(delta);

        //        if (limitFuture.Second > 0)
        //        {
        //            limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute + TimeSpan.TicksPerMinute);
        //        }


        //        DateTime nextDate = limitFuture;
        //        int nb = 0;
        //        int nblissage = 0;
        //        double deltaMinute = 1;

        //        if (conf.noCollision)
        //            deltaMinute = TimeSpan.FromDays(delta).TotalMinutes;

        //        if (conf.deltaConst)
        //        {

        //        }

        //        else
        //        {
        //            var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
        //            var _deltaRab = limitFuture.AddDays(conf.deltaRab);

        //            for (int i = indexLastRead + 1; i < list.Count; i++)
        //            {
        //                var t = list[i];
        //                if (t.Pub >= limitFuture)
        //                {
        //                    nextDate = t.Pub;
        //                    nblissage++;
        //                    if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
        //                        break;
        //                }
        //                nb++;
        //            }

        //            if (nextDate > limitFuture && nb > 0 && conf.noCollision)
        //                deltaMinute = (nextDate - limitFuture).TotalMinutes / (double)nb;
        //        }

        //        if (deltaMinute < 1)
        //            deltaMinute = 1;



        //        nb = 0;
        //        for (int i = indexLastRead + 1; i < count; i++)
        //        {

        //            var t = list[i];

        //            if (!t.Selected && conf.enabled != sortMode.reset)
        //                continue;
        //            if (!t.track.Enabled)
        //                continue;
        //            var dt = limitFuture.AddMinutes(deltaMinute * nb);
        //            var _delta = (dt - lastRead.Pub2).TotalDays;

        //            if (t.Pub >= dt || conf.enabled == sortMode.reset)
        //                t.increasePub(t.Pub);
        //            else
        //            {
        //                t.increasePub(dt);
        //                nb++;
        //            }


        //        }
        //    }

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (!track.Selected)
        //            continue;
        //        var pub2 = track.Pub2;
        //        var newPub = track.getPub();

        //        if (newPub != pub2)
        //        {
        //            writeComment(track, newPub);
        //        }
        //    }









        //    //  log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", delta.ToString("#.##"), nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));









        //    for (int i = 0; i < list.Count; i++)
        //    {
        //        var track = list[i].track;

        //        if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
        //        {
        //            var aux = currentPub2.AddMinutes(1);
        //            log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
        //            track.Pub2 = aux;
        //        }

        //        currentPub = track.Pub;
        //        currentPub2 = track.Pub2;
        //    }


        //}


        public void init()
        {
            done = false;
        }
        public void build()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            if (pub2 > lastRead.Pub && conf.elastique < 1)
            {
                delta0Corr = deltaLastRead0 * conf.elastique;
                pub2 = lastRead.Pub.AddDays(delta0Corr);
            }


            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }

            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }
                   
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb));
                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false);
                else
                {
                    writeComment(t, dt);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }


        }

        //private void writeComment(TrackInfoItunes track)
        //{
        //    string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
        //    if (track.Pub2 > track.Pub)
        //        comment = string.Format("{0}|{1}", track.Pub2.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));

        //    if (comment != track.Comment)
        //        track.Comment = comment;
        //}

        private void eraseSort(TrackSort track, bool force)
        {
            if (!force && !track.Selected)
                return;
            if (conf.canGoBack || conf.enabled == sortMode.reset)
            {
                DateTime pub = track.Pub;
                if (track.Pub2 >= Conf.Date0 && pub < Conf.Date0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }
                else if (track.Pub2 >= Conf.NewDate0 && pub < Conf.NewDate0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }

                //}
                //else
                //{
                if (track.Pub2 != track.Pub)
                    nbModif++;
                track.Pub2 = track.Pub;
                //}
                track.track.BuildComment();
                // writeComment(track);
            }
        }

        private void writeComment(TrackSort track, DateTime dt)
        {
            if (!track.Selected)
                return;

            if (conf.canGoBack)
            {
                if (track.Pub2 >= Conf.Date0 && dt < Conf.Date0)
                {
                    if (conf.canGoBackButForceSelected)
                    {
                        log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.Date0);
                        nbRepecheForce++;
                        dt = Conf.Date0.AddMinutes(nbRepecheForce);
                    }
                    else
                    {
                        log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.Date0);
                        nbrepeches++;
                    }
                }

                else if (track.Pub2 >= Conf.NewDate0 && dt < Conf.NewDate0)
                {

                    if (conf.canGoBackButForceSelected)
                    {
                        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.Date0);
                        nbRepecheForce++;
                        dt = Conf.Date0.AddMinutes(nbRepecheForce);
                    }
                    else
                    {
                        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.NewDate0);
                        nbrepeches++;
                    }

                }
            }
            else
            {
                if (dt == track.Pub2)
                {
                    log.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.Pub2)
                {
                    log.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.Pub2, dt, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var strDelta = delta.ToString("0.0");

            if (track.Pub2 != dt)
            {

                nbModif++;
                log.log("\t{0}\t{1}=>\t{2}({3}) {4}", track.Pub, track.Pub2, dt, strDelta, track.Name);
                track.Pub2 = dt;
            }
            else if (track.Pub2 > track.Pub)
            {
                log.log("\t{0}\t{1}({2}) {3}", track.Pub, track.Pub2, strDelta, track.Name);
            }


            track.track.BuildComment();
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
           
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta; 
        }
    }
}
