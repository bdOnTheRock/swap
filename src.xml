<db path="C:\Bernard\db1\pd4bb">
  <file path="\PieceDb.Consolid\auto\CalcAuto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.v, this.a);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.a = calcConv(this.v, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.a;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }

        public void checkCoeffOld()
        {
            if (coeffOldAuto)
            {
                coeffOld = (decimal)pdb.util.Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
        }

        private void verifMaxV()
        {

            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = v * pas;
            if (_dx > _dxmax)
            {
                var vv = _dxmax / pas;
                misc.log("verifMaxV {0}->{1}", v.FormatE(4), vv.FormatE(4));
                v = vv;
            }
        }

        private void verifMaxA()
        {
            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = 2 * a * pas * pas;

            if (_dx > _dxmax)
            {
                var aa = _dxmax / (2 * pas * pas);
                misc.log("verifMaxA {0}->{1}", a.FormatE(4), aa.FormatE(4));
                a = aa;
            }
        }

        private void verifBas()
        {
            var dx = v * pas;
            if (dx < epsilon)
            {
                //dx = epsilon;
                v = epsilon / pas;
            }

            //dx = vv * pas;
            //if (dx < epsilon)
            //{
            //    dx = epsilon;
            //    vv = epsilon / pas;
            //}

            var dv = a * pas;
            if (dv < vepsilon)
            {
                // dv = vepsilon;
                a = vepsilon / pas;

            }

            if (a < aepsilon)
                a = aepsilon;

            if (coeffVirt < 1)
                coeffVirt = 1;
        }
        private decimal _v0;
        private decimal getLimitedDelta(decimal v0, int oldSameDirection)
        {
            var v1 = v0;

            if (v0 > 1)
            {
                if (oldSameDirection > v0)
                {
                    v1 = 2 * v0 - oldSameDirection;
                    if (v1 < 1)
                        v1 = 1;
                }
            }
            return v1;
        }
        public bool calcAuto(bool selectedByCoeff)
        {
            var coeffVirt0 = coeffVirt;
            if (coeffOldSwap)
            {
                coeffVirt = coeffOld;
            }
            var _c0 = coeffVirt;
            _v0 = v;
            var oldSameDirection = Math.Abs(_nbSameDirection);

            // vv = v;
            var dv0 = dv;
            var _a0 = a;

            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;

            decimal ecart0 = System.Math.Max(_nbElastique, -_nbElastique2);

            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta;
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff || (checkFall && selectedByCoeff))
                {
                    if (last != selectedByCoeff)
                    {
                        _nbAltHisto++;
                        _nbSameDirection = 0;
                        _nbAlt++;
                    }
                    else
                    {
                        _nbAltHisto = 0;
                    }

                    //if (_nbAltHisto > 1)
                    //{
                    if (selectedByCoeff)
                    {
                        _nbElastique -= getLimitedDelta(coeffElastique1dm, oldSameDirection); // rapportmp* coeffElastique1r;
                        _nbElastique2 -= getLimitedDelta(coeffElastique2dm, oldSameDirection); // rapportmp* coeffElastique2;
                    }
                    else
                    {
                        _nbElastique -= coeffElastique1dp;
                        _nbElastique2 -= coeffElastique2dp;
                    }

                    if (last != selectedByCoeff)
                    {
                        if (_nbAltHisto > 1)
                        {
                            if (currentStaticp > 1 && coeffStaticpRetour > 1)
                            {
                                currentStaticp /= coeffStaticpRetour;
                                if (currentStaticp < 1)
                                    currentStaticp = 1;
                            }
                            if (currentStaticm > 1 && coeffStaticmRetour > 1)
                            {
                                currentStaticm /= coeffStaticmRetour;
                                if (currentStaticm < 1)
                                    currentStaticm = 1;
                            }
                        }
                    }

                    else
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;
                    }



                    // }
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;


                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                        // _nbSameDirection--;
                        _nbElastique += coeffElastique1sm; // coeffElastique1* rapportmp;
                        _nbElastique2 += coeffElastique2sm; // coeffElastique2r* rapportmp;
                    }
                    else
                    {
                        _nbElastique += coeffElastique1sp;
                        _nbElastique2 += coeffElastique2sp;
                        _nbSameDirectionBox++;
                        // _nbSameDirection++;
                    }
                }

                if (selectedByCoeff)
                {
                    _nbSameDirection--;
                }
                else
                {
                    _nbSameDirection++;
                }
            }

            if (!auto)
                return false;

            var lastProduct = linkProduct;


            var c0 = v;
            //verifHaut();
            //verifBas();


            if (last.HasValue)
            {
                var aux = a;




                lastDelta = null;
                if (last != selectedByCoeff) // if (_nbAltHisto > 1)
                {
                    if (_nbAlt > serialAlt || _nbElastique2 < -serialElastique)
                    {
                        lastDelta = false;
                    }
                }
                else if (checkFall && selectedByCoeff)
                {
                }
                else
                {
                    bool applyanti = false;
                    // bof. pour l'instant seul currentStaticm est géré
                    if (selectedByCoeff)
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;

                    }
                    else if (coeffStaticRetourLarge)
                    {

                        if (currentStaticm > 1)
                        {
                            currentStaticm /= coeffStaticmRetour;
                            if (currentStaticm < 1)
                                currentStaticm = 1;
                        }

                        //if (coeffStaticmRetour > 1 && currentStaticm > coeffStaticmRetour)
                        //    currentStaticm /= coeffStaticmRetour;
                        currentStaticp *= coeffStaticp;
                    }

                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    else if (_nbElastique > serialElastique)
                        applyanti = true;
                    //else if (_nbElastique2 > serialElastique)
                    //    applyanti = true;

                    if (applyanti)
                        lastDelta = true;
                    else
                        lastDelta = null;
                    if (_linkconv)
                        calcConv();


                }



                bool onAugmente = lastDelta.HasValue && (lastDelta_ == null || lastDelta_ == lastDelta);
                if (onAugmente)
                {
                    a *= (1 + aa);
                    //verifHaut();
                    //verifBas();
                }
                else
                {
                    decimal ecart1 = System.Math.Max(_nbElastique, -_nbElastique2);


                    if (ecart1 > 0 && ecart1 < ecart0)
                    {
                        if (a > aepsilon)
                        {
                            a /= (1 + aa);
                            if (a < aepsilon)
                                a = aepsilon;
                        }

                        //verifHaut();
                        //verifBas();

                    }
                }

                //if (c0 == v || !onAugmente)
                //{

                //    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                //    if (ecart1 < ecart0)
                //    {
                //        a /= (1 + aa);
                //        if (a < aepsilon)
                //            a = aepsilon;

                //    }
                //}
                //else
                //{
                //    a *= (1 + aa);
                //    verifHaut();
                //    verifBas();

                //}


                // vv += pas * a;



                verifMaxA();

                if (lastDelta.HasValue)
                {
                    //verifMaxA();
                    if (false == lastDelta)
                    {
                        var _v = _v0 - pas * a;
                        var limit = _v0 / vv;
                        if (_v < limit)
                        {
                            _v = limit;
                            a = (_v0 - _v) / pas;
                        }
                        v = _v;

                        if (_linkconv)
                            calcConv();

                    }
                    else if (true == lastDelta)
                    {
                        var deltav = pas * a;
                        var limit = _v0 * (vv - 1);
                        var limit2 = vepsilon / pas;

                        if (limit < limit2)
                            limit = limit2;


                        if (deltav > limit)
                        {
                            deltav = limit;
                            a = deltav / pas;
                        }

                        v = _v0 + deltav;

                    }

                    //  verifMaxV();
                    //verifHaut();
                    //verifBas();
                }


                verifMaxV();


                misc.log("convergence {0:0.##}->{1:0.######}", c0, v);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, a);
            }

            string montee = selectedByCoeff ? "down" : "up";

            verifBas();
            var _rapportTmp = rapportmp;
            if (selectedByCoeff)
            {
                _rapportTmp = getLimitedDelta(_rapportTmp, oldSameDirection); 
                //if (rapportmp > 1)
                //{
                //    if (oldSameDirection > rapportmp)
                //    {
                //        _rapportTmp = 2 * rapportmp - oldSameDirection;
                //        if (_rapportTmp < 1)
                //            _rapportTmp = 1;
                //    }
                //}

                coeffVirt -= pas * v * _rapportTmp / currentStaticp;
            }
            else
                coeffVirt += pas * v / currentStaticm;


            if (selectedByCoeff)
            {
                verifMaxA();
                verifMaxV();

                verifBas();
                coeffVirt = _c0 - pas * v * _rapportTmp / currentStaticp;
                verifBas();
            }




            //verifHaut();
            //verifBas();
            dx = Math.Abs(coeffVirt - _c0);
            if (_c0 > 0)
                dcoeff = 1 + dx / _c0;

            if (selectedByCoeff)
                dx /= _rapportTmp;


            dv = Math.Abs(v - _v0);
            if (dv == 0)
                dv = dv0 * (a / _a0);



            // da = Math.Abs(a - _a0);
            misc.log("{0} {1:0.### ###} {2:0.### ###}->{3:0.### ###}", montee, dx, c0, coeffVirt);


            histo.Add(new HistoValue(coeffVirt, dx, a, v / currentStaticm, dv, v));

            checkCoeffOld();

            if (coeffOldSwap)
            {
                coeffOld = coeffVirt;
                coeffVirt = coeffVirt0;
            }

            return dx != 0;
        }

    }
}
]]></content>
  </file>
</db>
