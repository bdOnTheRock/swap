<db path="C:\Bernard\db1\pdb4b">
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math; 

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        private bool loadLastFull;
        private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        //// r�cup�ration des infos externes
        //public void LegacyConsolid(CListPiece list, DateTime date)
        //{
        //    misc.log("Cdb::LegacyConsolid");

        //    DateTime now = DateTime.Now;
        //    ChronoData.refreshDate(date);

        //    foreach (CPiece ext in list)
        //    {
        //        m_list.legacyConsolid(ext);
        //    }

        //    m_list.bilanNatives();

        //    setAlbumArtistFromFile();

        //}

        //public void LegacyConsolid(CPiece ext)
        //{
        //    m_list.legacyConsolid(ext);
        //}

        //public void SynchroNative(DateTime date)
        //{
        //    misc.log("Cdb::SynchroNative");
        //    ChronoData.refreshDate(date);
        //    foreach (CPiece piece in m_list)
        //    {
        //        piece.SynchroNative();
        //    }

        //}

        private void setAlbumArtistFromFile()
        {
            foreach (ITrackMetaData piece in m_list)
            {
                setAlbumArtistFromFile(piece);
            }
        }



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        public void Sov(string fileIt)
        {
            var list = new List<string> { fileIt, LOCAL_FILE.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

        public void SovIni()
        {
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni); 

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

       
        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        private void write()
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                m_list.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



            if (lastFull != null)
            {
                try
                {
                    var diff = DiffFile.FullName;
                    if (mode == dbMode.full)
                        diff = diff.Replace(".xml", ".d.xml");

                    using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                    {
                        writer.WriteStartElement("db");
                        writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                        writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                        m_list.writeDiff(writer, lastFull);
                        writer.WriteEndDocument();
                        writer.Flush();
                    }

                    File.Copy(diff + ".tmp", DiffFile.FullName, true);
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

            WriteDB2();
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        public void WriteDB2()
        {

            misc.log("CDb:WriteDB2");
            lock (lockSave)
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff); 
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }


            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        //if (m_list != null)
                        //{
                        //    m_list.checkId(l_piece); 
                        //}
                        //checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }



        private  CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }

        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(CPlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
  <file path="\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private CPlayList listes = new CPlayList("listes");
        public CPlayList Listes { get { return listes; } }

        private const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.Parent = htIds[parentId];
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            DateTime maxEnabled = DateTime.MinValue;
            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
                if (l_file.Enabled)
                {
                    var t = l_file.LastModifClass;
                    if (t > maxEnabled)
                        maxEnabled = t;
                }
            }
            misc.log("***********************************************************");
            misc.log("maxEnabled: {0}", maxEnabled);
            misc.log("***********************************************************");
        }

        public CListPiece()
        {

        }

        #endregion


        //public void checkId(CPiece toCheck)
        //{
        //    foreach (CFile f in toCheck.Files)
        //    {
        //        if (htLoc.ContainsKey(f.Path))
        //        {
        //            var pOrg = htLoc[f.Path];
        //            toCheck.setId(pOrg.PieceId);
        //            toCheck.PieceParentId = pOrg.PieceParentId;
        //        }
        //    }
        //}

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        public void bilanNatives()
        {
            misc.log("Bilan Natives");
            foreach (CPiece piece in this)
            {
                if (piece.HasNoNative)
                    misc.logNoDate(piece.ToString());
            }
        }

        private void merge(CPiece org, CPiece cand)
        {
            misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
            org.merge(cand);
        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.addData(toDelete);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            if (remote.PieceParentId > 0)
            {
                if (remote.Parent == null)
                    remote.Parent = htIds[remote.PieceParentId];


            }
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (remote.PieceParentId > 0)
                {
                    var parent = htIds[remote.PieceParentId];
                    misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                    //l_pieceOrg.PieceParentId = remote.PieceParentId;
                    l_pieceOrg.Parent = parent;
                }
                //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                l_pieceOrg.consolid(remote, a_priority);
            }
        }

        /// <summary>
        /// synchro enrte base locale et liste native
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        //public void legacyConsolid(CPiece native)
        //{
        //    CPiece l_pieceOrg = getPiece(native);

        //    if (l_pieceOrg == null)
        //    {
        //        log("add from business:" + native.ToString());
        //        l_pieceOrg = new CPiece(native);
        //        l_pieceOrg.legacyConsolid(native);
        //        Add(l_pieceOrg);
        //    }
        //    else
        //    {
        //        l_pieceOrg.legacyConsolid(native);
        //    }

        //}

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, PIECES);
            foreach (CPiece l_piece in this)
            {
                l_piece.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, PIECES);
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());  
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            list.Sort(new PieceComparer());

            return list;
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, CPlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    CPlayList sub = new CPlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];
                    var tl = new TrackList(piece);
                    parent.add(tl);
                }
            }
        }

        private void writeList(XmlWriter w, CPlayList parent)
        {
            foreach (PlComponent c in parent)
            {
                if (c is CPlayList)
                {
                    var pl = c as CPlayList;
                    w.WriteStartElement(TOKEN_LIST);
                    w.WriteAttributeString("id", pl.ID.ToString());
                    w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                    writeList(w, pl);
                    w.WriteEndElement();
                }
                else if (c is TrackList)
                {
                    var t = c as TrackList;
                    w.WriteStartElement(TOKEN_LIST_TRACK);
                    w.WriteAttributeString("id", t.PieceId.ToString());
                    w.WriteEndElement();
                }
            }
        }

        public void buildLists(CPlayList listes)
        {
            this.listes.DeleteChilds();
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    CDb.checkId(sub);
                    subExt.ID = sub.ID;

                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }
        #endregion
    }

}






]]></content>
  </file>
  <file path="\PieceDb.Db\Legacy.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using pdb.obj;
using pdb.util;
using pdb.db;
using pdb.db.obj;

namespace pdb.db
{
   public class LegacyApp
    {
        // private List<ITrackNative> m_legacyList = new List<ITrackNative>();
        private ILoader loader;
        // private Dictionary<String, ITrackNative> ht_fileTrack = new Dictionary<string, ITrackNative>();
        private CListPiece list = new CListPiece();
        private BgDictString<ITrackInfoItunes> htfiles = new BgDictString<ITrackInfoItunes>();
        private List<ITrackInfoItunes> listAux = new List<ITrackInfoItunes>();

        public void init(ILoader loader)
        {
            this.loader = loader;
            //  CListPiece.loader = loader;
            //   m_defaultFolder = loader.DefaultFolder;


            //XmlDocument l_doc = new XmlDocument();
            //Console.WriteLine("chargement businessData");

            //l_doc.LoadXml(File.ReadAllText(DB_XML).Replace("http://www.apple.com/DTDs/PropertyList-1.0.dtd", ""));
            //m_node = l_doc.ChildNodes[2].ChildNodes[0];

            //XmlNode l_xmlFolder = getNext(m_node, "Music Folder");
            ////m_folder = New Uri(l_xmlFolder.InnerText).LocalPath
            //m_defaultFolder = l_xmlFolder.InnerText;
        }

        public CListPiece LegacyList
        {
            get
            {
                return list;
            }

        }

        //public void loadData(CDb db, bool scan)
        //{
        //    DateTime begin = DateTime.Now; 
        //    list = new CListPiece(); 
        //    loadTracks();
        //    loader.checkDetect(begin); 

        //    foreach (ITrackInfoItunes piece in listAux)
        //    {
        //        //  piece.setClassPlayList();
        //        if (piece.Location.isNullorEmpty())
        //        {
        //            misc.log("{0} {1} {2} sans localisation", piece.Artist, piece.Album, piece.Name);
        //            continue;
        //        }
        //        // menageClassList(piece);
        //        list.Add(new CPiece(piece));
        //    }
        //    list.bilanNatives();


        //    loader.checkDetect(begin); 
        //    loadLists();
        //    loader.checkDetect(begin); 

        //    if (scan)
        //        GetNewTracks(db.Remote);           //  scanFiles(new DirectoryInfo(loader.DefaultFolder), false);
          








        //    //foreach (CPiece piece in list)
        //    //{
        //    //    CListFile files = piece.Files;
        //    //    if (files.Count > 1)
        //    //    {
        //    //        files.Sort();
        //    //        for (int i = 1; i < files.Count; i++)
        //    //        {
        //    //            CFile file = files[i];
        //    //            String path = file.Path;
        //    //            loader.deleteTrack(path);

        //    //            DirectoryInfo poubelle = new DirectoryInfo(loader.DefaultFolder + Path.DirectorySeparatorChar + "poubelle");
        //    //            if (poubelle.Exists) poubelle.Create();
        //    //            if (!file.isExtern())
        //    //            {
        //    //                FileInfo org = new FileInfo(path);
        //    //                String newPath = poubelle.FullName + Path.DirectorySeparatorChar + file.File;

        //    //                try
        //    //                {
        //    //                    org.moveTree(newPath, true);
        //    //                    List<DirectoryInfo> dirs = new List<DirectoryInfo>();
        //    //                    //System.IO.File.Move(path, newPath);
        //    //                }
        //    //                catch (Exception)
        //    //                {
        //    //                    misc.log("unable to move from {0} to {1}", path, newPath);
        //    //                }
        //    //            }

        //    //        }
        //    //        updateClassList(piece);
        //    //    }
        //    //}



        //}

        public void scanFiles(DirectoryInfo dir, bool podcasts)
        {
            if (!podcasts)
            {
                if (dir.Name.ToLower() == "podcasts") return;
            }
            if (dir.Name.ToLower() == "poubelle") return;
            foreach (FileInfo file in dir.GetFiles())
            {
                if (!htfiles.ContainsKey(file.FullName))
                {
                    ITrackInfoItunes track = loader.createTrack(-1, file.FullName);
                    if (track != null)
                    {
                        if (track.isPodcast == podcasts)
                        {

                            if (file.FullName.ToLower() != track.Location.ToLower())
                            {
                                misc.log("path {0} != Location {1}", file.FullName, track.Location);
                            }
                            else
                            {
                                //  CPiece piece = new CPiece(track);
                                listAux.Add(track);
                                htfiles.Add(file.FullName, track);
                                // updateClassList(piece); 
                            }
                        }
                    }
                }
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(subDir, podcasts);
            }
        }


        private void loadTracks()
        {
            htfiles = new BgDictString<ITrackInfoItunes>(); 
           
            listAux = new List<ITrackInfoItunes>(); 
            misc.log("Clegacy:loadTracks");
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(listTrack);


            foreach (ITrackInfoItunes track in listTrack)
            {
                if (track.Location.isNullorEmpty())
                {
                    misc.log("track absent {0}", track.Name);
                }
                else if (track.isPodcast)
                {
                }
                else
                {
                    //  CPiece piece = new CPiece(track);
                    listAux.Add(track);
                    if (!htfiles.ContainsKey(track.Location))
                        htfiles.Add(track.Location, track);
                }

            }
        }

        //private void GetNewTracks(CListPiece local)
        //{
        //    if (local == null)
        //        return; 
        //    misc.log("checkNewtracks from Db");
        //    foreach (CPiece piece in local)
        //    {
        //        if (piece.Files.Exists)
        //        {
        //            if (!list.Contains(piece))
        //            {
        //                loader.createLegacyTrack(piece);
        //                list.Add(piece); 
        //              //  updateClassList(piece);
        //            }
        //        }
        //    }

        //}


        private void loadLists()
        {
            misc.log("chargement listes");
            loader.loadLists();
           
        }



        //private void updateClassList(ITrackNative piece)
        //{

        //    foreach (CPlayList list in piece.ClassPlayLists)
        //    {
        //        PieceInAList pieceInList = list.getPieceInList(piece);
        //        if (pieceInList != null)
        //            pieceInList.Delete();

        //    }

        //    String plName = piece.ClassName;
        //    loader.setClassPlayList(piece, plName);

        //}

        //public void menageClassList()
        //{
        //    menageClassList(this.list.getList()); 
        //}


        public void menageClassList(IEnumerable<CPiece> list)
        {
            foreach (CPiece track in list)
            {
                menageClassList2(track);
            }
        }

        //private void menageClassList(ITrackNative piece)
        //{
        //    var listC = piece.ClassPlayLists;
        //    var count = listC.Count;
        //    if (count > 1)
        //    {
        //        for (int i = 1; i < count; i++)
        //        {
        //            CPlayList pl = listC[i];
        //            misc.log("{0}:{1} suppression {2}", piece, piece.ClassName, pl.Name);
        //            PieceInAList pieceInList = pl.getPieceInList(piece);
        //            if (pieceInList != null)
        //                pieceInList.Delete();
        //            // pl.remove(pieceInList); 
        //            //  loader.deleteTrackInList(pieceInList);
        //        }

        //        //String plName = piece.ClassName;
        //        //loader.setClassPlayList(piece, plName);
        //    }
        //}

        //private void menageClassList2(CPiece piece)
        //{
        //    var listC = piece.ClassPlayLists;
        //    var count = listC.Count;
        //    var classListName = piece.ClassName;
        //    if (count > 1)
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            CPlayList pl = listC[i];
        //            if (pl.Name == classListName)
        //                continue;
        //            misc.log("{0}:{1} suppression {2}", piece, piece.ClassName, pl.Name);
        //            PieceInAList pieceInList = pl.getPieceInList(piece);
        //            if (pieceInList != null)
        //                pieceInList.Delete();
        //            // pl.remove(pieceInList); 
        //            //  loader.deleteTrackInList(pieceInList);
        //        }

        //        //String plName = piece.ClassName;
        //        //loader.setClassPlayList(piece, plName);
        //    }
        //}

    }
}

]]></content>
  </file>
  <file path="\PieceDb.Db\TrackList.cs">
    <content><![CDATA[using pdb.db.obj;
using pdb.obj;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.db
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            return new TrackList(source as CPiece);
        }
    }
    public class TrackList : PlComponent, ITrackInfoItunes
    {

        private CPiece piece;
        public TrackList(CPiece piece)
        { this.piece = piece; }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public CPiece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        public string Comment
        {
            get
            {
                return piece.Comment;
            }
            set
            {
                piece.Comment = value;
            }
        }

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        public string ArtWork
        {
            get
            {
                return piece.ArtWork;
            }
            set
            {
                piece.ArtWork = value;
            }
        }

        public string Grouping
        {
            get { return piece.Grouping; }
        }

        public void setGrouping(string value, bool prior)
        {
            piece.setGrouping(value, prior);
        }



        public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            piece.AddPlayList(a_playList);
        }

        public void removePlayList(CPlayList list)
        {
            piece.removePlayList(list);
        }

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
          //  set { piece.PieceParentId = value; }
        }


        public TrackIdentity Key
        {
            get { return piece.Key;  }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListDate.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;

namespace pdb.db.obj
{

    /// <summary>
    /// liste des dates d'écoute d'un morceau
    /// </summary>
    /// <remarks></remarks>
    /// 

    public class CListDate : IEnumerable<System.DateTime>, IData
    {

        private const string DATES = "dates";

        private const string DATE = "date";
        private List<System.DateTime> m_list = new List<System.DateTime>();
        public static int Period = 30;

        private static CDateComparer c_comparer = new CDateComparer();
        private static DateTime min = new DateTime(1970, 3, 27);
        public CListDate(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, DATES);
            if (l_xml == null)
                return;
            foreach (XmlElement l_xmlDate in l_xml)
            {
                string l_strDate = l_xmlDate.InnerText;
                DateTime l_date = Convert.ToDateTime(l_strDate);
                check(l_date);
            }
        }
        public CListDate()
        {
        }

        public CListDate(CListDate o)
        {
            foreach (DateTime dt in o.m_list)
            {
                check(dt); 
            }
        }

        public CListDate(List<DateTime> dates)
        {
            merge(dates);
        }

        public void check(System.DateTime a_date)
        {
            if (a_date > min)
            {
                if (!m_list.Contains(a_date))
                {
                    if (!isDateInList(a_date))
                    {
                        m_list.Add(a_date);
                    }
                }
            }
        }

        private bool isDateInList(System.DateTime a_date)
        {
            foreach (System.DateTime l_date in m_list)
            {
                if (l_date == a_date)
                    return true; 
                //string refe = l_date.ToString();
                //if (refe == a_date.ToString())
                //    return true;
                //if (refe == a_date.AddHours(1).ToString())
                //    return true;
                //if (refe == a_date.AddHours(-1).ToString())
                //    return true;
            }
            return false;
        }

        public void merge(IEnumerable<DateTime> a_list)
        {
            foreach (System.DateTime l_date in a_list)
            {
                check(l_date);
            }
        }

        public void merge(DateTime dt)
        {

            check(dt);

        }




        public System.Collections.Generic.IEnumerator<System.DateTime> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return m_list.GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        private void sort()
        {
            m_list.Sort(c_comparer);
        }

        #region IData Members


        public void write(ITextWriter a_sw)
        {
            sort();
            XMLTool.openBalise(a_sw, DATES);

            foreach (System.DateTime l_date in this)
            {
                XMLTool.writeValue(a_sw, CListDate.DATE, l_date.ToString());
            }
            XMLTool.closeBalise(a_sw, DATES);

        }


        public void write(XmlWriter w)
        {
            sort();
            w.WriteStartElement(DATES);

            foreach (System.DateTime l_date in new List<DateTime>(this))
            {
                w.WriteElementString(CListDate.DATE, l_date.ToString());
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListDate lastFull)
        {
            return m_list.Count != lastFull.m_list.Count;
        }
        public void writeDiff(XmlWriter w, CListDate lastFull)
        {
            if (m_list.Count == lastFull.m_list.Count)
                return; 
            sort();
            lastFull.sort(); 
            w.WriteStartElement(DATES);

            foreach (System.DateTime l_date in new List<DateTime>(this))
            {
                bool found = false;
                foreach (DateTime o in new List<DateTime>(lastFull.m_list))
                {
                    if (o == l_date)
                    {
                        found = true;
                        break; 
                    }
                }
                if (found)
                    continue; 
                w.WriteElementString(CListDate.DATE, l_date.ToString());
            }
            w.WriteEndElement();
        }


        #endregion
        public int Count
        {
            get { return m_list.Count; }
        }
        public System.DateTime this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new PieceDbException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public DateTime LastModif
        {
            get
            {
                if (m_list.Count == 0)
                    return System.DateTime.MinValue;
                sort();
                return m_list[0];
            }
        }
        public List<DateTime> Dates { get { return m_list; } }

        public class CDateComparer : IComparer<System.DateTime>
        {

            public int Compare(System.DateTime x, System.DateTime y)
            {
                return -1 * System.DateTime.Compare(x, y);
            }
        }

        public void removeLast()
        {
            int count = m_list.Count;
            if (count == 0)
                return;
            m_list.RemoveAt(0);
        }


    }
}





]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers accédant au même morceau
    /// </summary>
    /// <remarks></remarks>
    public class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        private CFile pertinentFile;
       // private bool? _exists;
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                CFile f = new CFile(att.Value);
                @add(f);
                return;
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                CFile l_file = new CFile(l_xmlFile.InnerText);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }

        public CListFile(CListFile o)
        {
            foreach (CFile f in o)
                @add(f); 
        }
        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
            {
                m_list.Add(a_file);
                pertinentFile = null;
            }
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            if (pertinentFile != null)
                return pertinentFile;
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            pertinentFile = list.Count == 0 ? null : list[0];
            return pertinentFile;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        public void getSecondaryFiles(List<CFile> list)
        {
            if (m_list.Count <= 1)
                return;
            var pertinent = getPertinentFile();

            foreach (CFile f in m_list)
            {
                if (f.exists() && f != pertinent)
                    list.Add(f);
            }

        }

        public string File
        {
            get
            {
                CFile l_file = getPertinentFile();
                if (l_file == null)
                {
                    if (m_list.Count > 0) return m_list[0].File;
                    return "";
                }
                return l_file.File;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }
        public String getUri()
        {
            CFile l_file = getPertinentFile();
            if (l_file == null)
                return "";
            return l_file.getUri();
        }

        public bool Exists
        {
            get
            {
                //if (_exists.HasValue)
                //    return _exists.Value;
                if (pertinentFile != null)
                {
                  //  _exists = true;
                    return true;
                }

                foreach (CFile f in m_list)
                {
                    if (f.exists())
                    {
                     //   _exists = true;
                        return true;
                    }
                }

              //  _exists = false;
                return false;

            }
        }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                @add(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        private IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }
        private void onChange() { if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>(m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            return m_list.Count != lastFull.m_list.Count;
        }
        public void writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (m_list.Count == lastFull.m_list.Count)
                return;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                bool found = false;
                foreach (CFile o in lastFull.m_list)
                {
                    if (o.File.Equals(l_file.File))
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;

                l_file.write(w);
            }
            w.WriteEndElement();
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        private long size = -1;
        public long Size
        {
            get
            {
                if (size < 0)
                {
                    var file = getPertinentFile();
                    if (file == null)
                        size = 0;
                    else
                        size = file.Size;
                }
                return size;
            }

        }

        public string DirAndFileName
        {
            get
            {
                var file = getFirstFile();
                if (file == null)
                    return "";
                return file.DirAndFileName;
            }
        }


    }
}


]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, IDataObserver, ITrackInfoItunes
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

      
        private PieceMaster master; 

        #region "Composants"
     
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
      
      


      
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        private void OnCommentChange(String value)
        {
            checkNative();
            if (native == null)
                return;
            native.Comment = value;
        }
        private void OnGroupingChange(String value, bool prior)
        {
            checkNative();
            if (native == null)
                return;
            native.setGrouping(value, prior);
        }
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            //Classement.Observer = this;
            //Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {
            master = new PieceMaster(); 
         
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();          
            valueChangedHandler();
        }

        //public CPiece(string location, string baseClassement)
        //    : this()
        //{
        //    m_files.add(new CFile(location));
        //    m_classement = new CPieceClassement(baseClassement);
        //    valueChangedHandler();
        //}

        public CPiece(string location)
            : this()
        {
            master = new PieceMaster(location);  

            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            valueChangedHandler();
          
        }

        public void initClassementIfEmpty(string classement)
        {
            master.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            master.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

//        public CPiece(ITrackInfoItunes ext)
//        {
//            native = ext;
//            //  ext.registerDependency(this); 

//            m_classPlayLists = ext.ClassPlayLists;
//            //m_playList = ext.PLayLists;

//            string className = ext.ClassName; // getClassName(ext); 

//            m_dates = new CListDate();
//            ListDates.check(ext.PlayedDate);

//            m_files = new CListFile();
//            Files.add(new CFile(ext.Location));
//            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
//#if VOL
//            m_infos = new CPieceInfo(ext.Year, ext.Volume);
//#else
//            m_infos = new CPieceInfo(ext.Year);
//#endif
//            this.artWork = ext.ArtWork;

//            m_classement = new CPieceClassement(className, ext.Rating);
//            //m_comment = ext.Comment;
//            //grouping = ext.Grouping; 

//            m_duration = ext.Duration;
//            bool enabled = ext.Enabled;
//            if (enabled)
//                Checked.Enable();
//            else
//                Checked.Disable();

//            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
//            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
//            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
//            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
//            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
//            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

//            m_ref.Observer = this;
//            Classement.Observer = this;
//            Checked.Observer = this;
//            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





//            valueChangedHandler();


//        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                master = new PieceMaster(a_xml); 
                //m_dates = new CListDate(a_xml);
                //m_files = new CListFile(a_xml);
                //m_classement = new CPieceClassement(a_xml);
                //var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                //{
                //    if (xDisabled != null)
                //    {
                //        if (xDisabled.InnerText == "false")
                //            Checked.Enable();
                //        else
                //            Checked.Disable(); 
                //    }
                //}
            }
            else
            {
                //m_dates = new CListDate();
                //m_files = new CListFile();
                //m_classement = new CPieceClassement();

            }





           // var xtool = new XMLTool(a_xml);
         //   artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
          

            m_ref.Observer = this;
            //Classement.Observer = this;
            //Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!master.choose(other.master))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                 master.mergeManual(other.master);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);

                master.mergeDataFrom(other.master); 
               // Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        public void addData(CPiece other)
        {
            master.addData(other.master); 
        }


        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
               // Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);
                master.consolid(remote.master, a_priority); 
             //   Checked.Consolid(remote.Checked, a_priority);

                //if (m_duration.TotalMilliseconds < 2)
                //    this.m_duration = remote.m_duration;
                //else if (remote.m_duration.TotalMilliseconds < 2)
                //    remote.m_duration = this.m_duration;
                //else if (a_priority == mergePriority.right)
                //    m_duration = remote.m_duration;

              //  addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        //public void legacyConsolid(CPiece l_native)
        //{



        //    //TODO éviter de créer un objet juste pour la comparaison
        //    //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



        //    //this.grouping = l_native.Grouping;
        //    //this.m_comment = l_native.Comment; 







        //    l_native.m_ref.legacyConsolid(this.m_ref);
        //    l_native.m_infos.legacyConsolid(this.m_infos);

        //    l_native.setClassPlayList(this);
        //    l_native.Classement.LegacyConsolid(this.Classement);
        //    l_native.Checked.LegacyConsolid(this.Checked);

        //    //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

        //    addData(l_native);

        //    this.m_playList = l_native.PLayLists;
        //    this.m_classPlayLists = l_native.ClassPlayLists;
        //    this.m_duration = l_native.Duration;
        //    raiseChangeRefEvent();

        //    //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
        //    this.native = l_native.native;

        //    checkNative();
        //}

//        /// <summary>
//        /// Synchro directe entre la Db et le track Itunes (mode daemon)
//        /// </summary>
//        public void SynchroNative()
//        {
//            checkNative();
//            if (native == null)
//                return;

//            m_ref.SynchroNative(native);
//#if VOL
//            m_infos.SynchroNative(native.Year, native.Volume);
//#else
//            m_infos.SynchroNative(native.Year);
//#endif
//            var newClassList = getClassName(native);
//            Classement newCl = new Classement(newClassList, native.Rating);
//            Classement.SynchroNative(newCl);
//            Checked.SynchroNative(native.Enabled);

//            this.ListDates.merge(native.PlayedDate);



//            //  this.m_playList = native.PLayLists;
//            this.m_classPlayLists = native.ClassPlayLists;
//            if (native.Duration.TotalMilliseconds > 1)
//                this.m_duration = native.Duration;
//            raiseChangeRefEvent();
//        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            master.removeVersions();
        }

      

        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            master.Menage(this); // Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        //private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        //private List<CPlayList> m_playList = new List<CPlayList>();
        //public void AddPlayList(CPlayList a_playList)
        //{
        //    if (a_playList.isClassSubList())
        //    {
        //        m_classPlayLists.Add(a_playList);
        //    }
        //    m_playList.Add(a_playList);
        //}
        //public void removePlayList(CPlayList list)
        //{
        //    if (list.isClassSubList())
        //        m_classPlayLists.Remove(list);
        //    m_playList.Remove(list);
        //}

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in m_playList)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        //private void setClassPlayList(ITrackNative pieceDb)
        //{
        //    string dbClasslist = pieceDb.ClassName;
        //    int count = m_classPlayLists.Count;
        //    if (count > 0)
        //    {
        //        string className = m_classPlayLists[0].Name;
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //            foreach (var list in m_classPlayLists)
        //            {
        //                className = list.Name;
        //                if (className == dbClasslist)
        //                    continue;
        //                break;
        //            }
        //        }

        //        if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
        //        {
        //            misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
        //            return;
        //        }

        //        Classement.ClassList = className;

        //    }
        //}

        //public string getClassName(ITrackNative native)
        //{
        //    string dbClasslist = this.ClassName;
        //    var firstStep = getClassName_(native);
        //    if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
        //    {
        //        misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
        //        return dbClasslist;
        //    }
        //    else
        //        return firstStep;
        //}

        //public string getClassName_(ITrackNative native)
        //{
        //    string dbClasslist = this.ClassName;
        //    string className = dbClasslist;
        //    int count = native.ClassPlayLists.Count;
        //    if (count > 0)
        //    {
        //        className = native.ClassPlayLists[0].Name;
        //        if (count > 1)
        //        {
        //            native.ClassPlayLists.Sort(new CPlayListComparer());
        //            foreach (var list in native.ClassPlayLists)
        //            {
        //                className = list.Name;
        //                if (className.Equals(dbClasslist))
        //                    continue;
        //                break;
        //            }
        //        }
        //    }
        //    return className;
        //}

        //utilisé par le player maison
        //public void setClassPlayList(String name)
        //{
        //    Classement.ClassList = name;
        //    // TODO Gérer l'absence de classList
        //}

        //private CPlayList ClassPlayList
        //{
        //    get
        //    {
        //        if (m_classPlayLists.Count > 0)
        //            return m_classPlayLists[0];
        //        return null;
        //    }
        //}

    //    public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return master.ClassName; } set { } }

        //public List<CPlayList> ClassPlayLists
        //{
        //    get
        //    {
        //        return m_classPlayLists;
        //    }
        //}



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            master.write(a_sw);
            var dur = master.Duration; 

            //Classement.write(a_sw);

            //Files.write(a_sw);
            //ListDates.write(a_sw);

            //if (!Checked.Enabled)
            //    XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            //if (artWork.NotNullOrEmpty())
            //    XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            //if (dur.TotalMilliseconds > 1)
            //    XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }


        public bool hasParent() { return m_id != master.Id; }

        public void write(XmlWriter w)
        {           
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());

                bool hasParent_ = hasParent(); 
                if (hasParent_)
                    w.WriteAttributeString("parent",master.Id.ToString());
                if (!hasParent_)
                {
                    if (Duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(PieceMaster.TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (hasParent_)
                {
                    master.write(w); 
                }

            

                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

    
        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (master.Id != m_id)
                w.WriteAttributeString("parent", master.Id.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (master.Id == m_id)
            {
                master.writeDiff(w, lastFull.master);               
            }

            


          

            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;
            return master.HasChange(lastFull.master); 

            //if (parent == null)
            //{
            //    if (Classement.HasChange(lastFull.Classement))
            //        return true;
            //    if (Files.HasChange(lastFull.Files))
            //        return true;
            //    if (ListDates.HasChange(lastFull.ListDates))
            //        return true;
            //}

            //if (Checked.Enabled != lastFull.Checked.Enabled)
            //    return true;


            //if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
            //    return true;

            return false;
        }

        #endregion

       

        


        public CListFile Files
        {
            get { return master.Files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return master.DurationInSec; }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
       // private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get
            {
                if (master.Id == m_id)
                    return -1;
                return master.Id; 
            }
        }

        public int MasterId
        {
            get
            {
                return master.Id; 
            }
        }

        //public CPiece Master
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return this; 
        //        return parent;
        //    }
        //}


        public void setId(int value)
        {
            if (m_id < 0)
            {
                m_id = value;
            }
        }

     //   public CPieceClassement Classement { get { return master.Classement;  } }
        public TimeSpan Duration
        {
            get {return master.Duration; }
            set
            {
                master.Duration = value; 
            }
        }
      //  public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
       // private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return master.Classement; }


        //public string getUri()
        //{
        //    return Files.getUri();

        //    //string l_file = File;
        //    //if (l_file.Contains("file://"))
        //    //{
        //    //    return l_file;
        //    //}
        //    //else
        //    //{
        //    //    return CLegacy.DefaultFolder + File;
        //    //}

        //}


        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId); 
            return string.Format("{0} {1}{2}{3} {4} {5}", master.Classement, PieceId, parent, Name, Album, master.File); 
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return Location + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return master.Path; // Files.Path; 
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public bool Exists { get { return master.Exists;}} // Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

       
        private string _grouping;
        public string Grouping
        {
            get
            {
                if (_grouping == null)
                {
                    if (native != null)

                        _grouping = native.Grouping;
                }
                return _grouping;
            }
            //set
            //{
            //    //if (value != Grouping)
            //    //{
            //    //  grouping = value;
            //    OnGroupingChange(value);
            //    //}
            //}
        }

        public void setGrouping(string value, bool prior)
        {
            if (value != _grouping)
            {
                _grouping = value;
                OnGroupingChange(value, prior);
            }
        }

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        //private CListDate DatesClassement_
        //{
        //    get
        //    {
        //        //if (m_datesModifClassement == null)
        //        //    m_datesModifClassement = Classement.Dates;
        //        return Classement.Dates;
        //    }
        //}

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        //public String getClassementEvol()
        //{
        //    DateTime playedCorr = ListDates.LastModif;
        //    try
        //    {
        //        if (playedCorr > DateTime.MinValue)
        //            playedCorr -= m_duration;
        //    }
        //    catch (Exception)
        //    {
        //        logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
        //    }
        //    if (DatesClassement_.LastModif > playedCorr)
        //    {
        //        return Classement.Evol;
        //    }
        //    return "";

        //}

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            master.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return master.StrClassement; 
            }
            set
            {
                master.StrClassement = value; 
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }

        public string DirAndFileName
        {
            get
            {
                return Files.DirAndFileName;
            }
        }
        //private CPiece parent;

        public void setParent(CPiece parent)
        {
            var _oldParent = master;

            if (parent == null)
            {
                var copy = new PieceMaster(master, m_id);
                this.master = copy; 
                return;
            }
            else
            {
                master = parent.master; 
            }
        }
        //public CPiece Parent
        //{
        //    get { return parent; }
        //    set
        //    {
        //        var _oldParent = parent;

        //        if (value == null)
        //        {
        //            parent = null;
        //            PieceParentId = -1;
        //            if (_oldParent != null)
        //            {
        //                addDataLink(_oldParent);
        //            }
        //            return;
        //        }
        //        else
        //        {
        //            parent = value.Master; 
        //        }
        //        parent.addDataLink(this);
        //        PieceParentId = parent.PieceId;

        //    }
        //}

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState; 
        public exportState ExportStatus
        {
            get
            {
                return _exportState; 
            }
            set
            {
                _exportState = value; 
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return master.DatesClassementBrut; 
            }
        }


        public string Comment
        {
            get
            {
                return master.Comment; 
            }
            set
            {
                master.Comment = value; 
            }
        }
    }
}






]]></content>
  </file>
  <file path="\PieceDb.Db\piece\PieceMaster.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.db.obj;
using pdb.db.piece.data;
using System.Xml;
using pdb.util;

namespace pdb.db.piece
{
    public class PieceMaster
    {
        private const string TOKEN_DISABLED = "disabled";
        public const string TOKEN_DURATION = "duration";
        private static Logger logMaster = Logger.getLogger("Master");



        private CListDate m_dates;
        private CListFile m_files;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private CPieceChecked m_Enabled = new CPieceChecked();

        private int m_id = -1;


        public PieceMaster(XmlElement a_xml)
        {
            var xtool = new XMLTool(a_xml);
            m_id = xtool.getIntAttValue("id");
            m_dates = new CListDate(a_xml);
            m_files = new CListFile(a_xml);
            m_classement = new CPieceClassement(a_xml);
            var xDisabled = xtool.NodeLookUp(TOKEN_DISABLED);
            {
                if (xDisabled != null)
                {
                    if (xDisabled.InnerText == "false")
                        m_Enabled.Enable();
                    else
                        m_Enabled.Disable();
                }
            }

            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);


            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }
        }

        public PieceMaster(PieceMaster o, int id)
        {
            m_id = id;

            m_dates = new CListDate(o.m_dates);
            m_files = new CListFile(o.m_files);
            m_classement = new CPieceClassement(o.m_classement); 
        }

        private string _comment;
        public string Comment
        {
            get
            {
                return _comment;
            }
            set
            {
                _comment = value;
            }
        }


        public PieceMaster()
        {
            m_dates = new CListDate();
            m_files = new CListFile();
            m_classement = new CPieceClassement();
        }

        public PieceMaster(string location)
            : this()
        {
            m_files.add(new CFile(location));
        }


        public int Id
        {
            get { return m_id; }
        }

        //public CPieceClassement Classement { get { return m_classement; } }
        //public CListFile Files { get { return m_files; } }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        public void addData(PieceMaster other)
        {
            if (other == this)
                return;
            m_dates.merge(other.m_dates);
            other.m_dates.merge(m_dates);

            m_files.merge(other.m_files);
            other.m_files.merge(m_files);
        }

        public void mergeDataFrom(PieceMaster other)
        {
            if (other == this)
                return;
            m_classement.mergeAll(other.m_classement, mergePriority.none);
        }

        public void consolid(PieceMaster remote, mergePriority a_priority)
        {

            try
            {
                m_classement.Consolid(remote.m_classement, a_priority);


                m_Enabled.Consolid(remote.m_Enabled, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);

            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }

        public void removeVersions()
        {
            m_classement.removeVersions();
        }

        public void Menage(CPiece piece)
        {
            //  misc.log("ménage {0}", this); 
            m_classement.Menage(piece);
        }

        public string ClassName { get { return m_classement.ClassList; } }

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(m_classement.Value))
                return;
            m_classement.Value = cl;

        }

        public pdb.db.piece.type.Classement Classement { get { return m_classement.Value; } }
        public string File { get { return m_files.File; } }
        public string Path { get { return m_files.Path; } }
        public bool Exists { get { return m_files.Exists; } }

        public TimeSpan Duration
        {
            get { return m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    m_duration = value;
                }
            }
        }


        private void log(String txt)
        {
            logMaster.log(txt);
        }


        public int DurationInSec
        {
            get { return Convert.ToInt32(m_duration.TotalSeconds); }
        }

        public void write(ITextWriter a_sw)
        {
            m_classement.write(a_sw);
            m_files.write(a_sw);
            m_dates.write(a_sw);

            if (!m_Enabled.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());

            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
        }




        public void write(XmlWriter w)
        {

            try
            {


                m_classement.write(w);
                m_files.write(w);
                m_dates.write(w);

                if (!m_Enabled.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

        public bool HasChange(PieceMaster lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }

            if (m_classement.HasChange(lastFull.m_classement))
                return true;
            if (m_files.HasChange(lastFull.m_files))
                return true;
            if (m_dates.HasChange(lastFull.m_dates))
                return true;


            if (m_Enabled.Enabled != lastFull.m_Enabled.Enabled)
                return true;


            if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
                return true;

            return false;
        }

        public void writeDiff(XmlWriter w, PieceMaster lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }



            m_classement.writeDiff(w, lastFull.m_classement);
            m_files.writeDiff(w, lastFull.m_files);
            m_dates.writeDiff(w, lastFull.m_dates);

            if (!m_Enabled.Enabled && lastFull.m_Enabled.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");

            if (m_Enabled.Enabled && !lastFull.m_Enabled.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "false");

            if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());







            w.WriteEndElement();
        }

        public bool choose(PieceMaster remote)
        {
            return m_classement.choose(remote.m_classement);
        }

        public void mergeManual(PieceMaster other)
        {
            m_classement.mergeManual(other.m_classement);
        }

        public String getClassementEvol()
        {
            DateTime playedCorr = m_dates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logMaster.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, m_dates.LastModif, m_duration);
            }
            if (m_classement.Dates.LastModif > playedCorr)
            {
                return m_classement.Evol;
            }
            return "";

        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return m_classement.getDates();
            }
        }

        public void setClassement(string className, int rating)
        {
            m_classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return m_classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;



namespace pdb.db.piece.data
{

    /// <summary>
    /// Donnée + liste des versions
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class CPieceData<T> : IData, IEnumerable<CPieceDataVersion<T>>
    {
        /// <summary>
        /// Liste des versions
        /// </summary>
        protected List<CPieceDataVersion<T>> m_list = new List<CPieceDataVersion<T>>();
        private static CDataVersionComparerInv c_comparerInv = new CDataVersionComparerInv();

        private bool m_bOverride = false;
        public abstract string getToken();
        public abstract T getNullValue();
        public abstract CPieceDataValue<T> createPieceDataValue(XmlElement a_node);
        public abstract CPieceDataValue<T> createPieceDataValue(string a_value);
        public abstract CPieceDataValue<T> createPieceDataValueT(T value);
        // protected Bool empty = Bool.not_defined;
        //   protected static DateTime _now = DateTime.Now;

        protected IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }

        public bool Override { get { return m_bOverride; } }

        
        public static DateTime Now
        {
            get
            {
                return ChronoData.Now;
            }
        }

        #region signaux

        //public class PieceDataChangeNativeEventArgs : EventArgs
        //{
        //    public PieceDataChangeNativeEventArgs(T value) { this.Value = value; }
        //    readonly public T Value;
        //}

        //public class PieceDataChangeLocalEventArgs : EventArgs
        //{
        //    public PieceDataChangeLocalEventArgs(T Old, T New) { this.Old = Old; this.New = New; }
        //    readonly public T Old;
        //    readonly public T New;
        //}

        //  public event EventHandler<PieceDataChangeNativeEventArgs> changeNativeValue;
        private void OnchangeNativeValue(T value) { if (observer != null) changeNativeValue(value); }
        protected abstract void changeNativeValue(T value);

        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByRemote;
        private void OnChangeLocalByRemote(T Old, T New)// { if (changeLocalValueByRemote != null) changeLocalValueByRemote(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByRemote(getToken(), Old, New);
        }
        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByNative;
        private void OnChangeLocalByNative(T Old, T New) // { if (changeLocalValueByNative != null) changeLocalValueByNative(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByNative(getToken(), Old, New);
        }
        //public event EventHandler<PieceDataChangeLocalEventArgs> cannotMerge;
        private void OnCannotMerge(T Old, T New) { }

        // public event EventHandler change;
        private void onChange() { if (observer != null) observer.RefChange(); }
        #endregion


        public CPieceData(CPieceData<T> o)
        {
            foreach (CPieceDataVersion<T> v in o.m_list)
                m_list.Add(new CPieceDataVersion<T>(v)); 
        }

        public CPieceData(string a_value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_value, this);
            m_list.Add(l_version);

        }

        public CPieceData(T value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(value, this);
            m_list.Add(l_version);
        }

        public CPieceData()
        {
        }






        /// <summary>
        /// Ajoute si nécessaire les versions réciproques 
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>On ne prend en compte que les versions de date définie</remarks>
        /// 




        public void mergeOnlyVersion(CPieceData<T> a_list)
        {
            foreach (CPieceDataVersion<T> l_version in a_list.m_list)
            {
                check(l_version);
            }
            sortAndCompact();
            foreach (CPieceDataVersion<T> l_remote in this.m_list)
            {
                a_list.check(l_remote);
            }
            a_list.sortAndCompact();
        }

        public void mergeAll(CPieceData<T> other, mergePriority a_priority)
        {
            T valueOrg = Value;
            mergeOnlyVersion(other);
            if (!this.Equals(other))
            {
                mergePriority l_ret = this.isMaster(other, a_priority);
                if (l_ret == mergePriority.left)
                {
                    OnChangeLocalByNative(other.Value, this.Value);
                    other.eraseSingleFrom(this);
                }
                else if (l_ret == mergePriority.right)
                {
                    this.eraseSingleFrom(other);
                }
                else
                {
                    OnCannotMerge(this.Value, other.Value);
                }
            }

            if (!Value.Equals(valueOrg))
            {
                onChange();
            }
        }

        /// <summary>
        /// Synchronise les infos de deux pieces (local-distant)
        /// </summary>
        /// <param name="remote">Piece sur fichier pdb_export</param>
        /// <remarks>on teste le cgangement de valeur</remarks>
        public virtual void Consolid(CPieceData<T> remote, mergePriority a_priority)
        {
            sortAndCompact();
            remote.sortAndCompact();
            T l_valueOrg = Value;
            mergeAll(remote, a_priority);

            if (!l_valueOrg.Equals(Value))
            {
                m_bOverride = true;
                OnChangeLocalByRemote(l_valueOrg, Value);
            }

            sortAndCompact();
            remote.sortAndCompact();

        }

        public bool Imported
        {
            get { return m_bOverride; }
        }

        protected virtual void LegacyConsolidByNative(CPieceData<T> local)
        {
            local.eraseSingleFrom(this);
        }

        protected virtual bool canErase()
        {
            return false;
        }

        public void removeVersions()
        {
            sortAndCompact();
            if (m_list.Count > 1)
            {
                m_list = new List<CPieceDataVersion<T>> { m_list[0] };
            }
        }






        public virtual void LegacyConsolid(CPieceData<T> local)
        {
            if (!this.Equals(local))
            {
                mergePriority l_merge = checklegacyModif(local);

                if (l_merge == mergePriority.right)
                {
                    this.m_bOverride = true;
                    this.eraseSingleFrom(local);
                    // this.empty = Bool.not_defined;
                    OnchangeNativeValue(Value);
                }
                else
                {
                    OnChangeLocalByNative(local.Value, this.Value);
                    if ((local.Significant || canErase()) && Now != local.LastModif)
                    {
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, m_list[0].Data);
                        local.m_list.Add(l_version);
                        local.sortAndCompact();
                    }
                    else
                    {
                        local.eraseSingleFrom(this);
                    }
                    //    local.empty = Bool.not_defined;
                }

            }
        }

        public virtual void SynchroNative(T native)
        {
            if (native != null && isSignificant(native) && !Value.Equals(native))
            {
                bool update = true;
                if (native is string)
                {
                    if (native.ToString().Trim().Equals(Value.ToString().Trim()))
                        update = false;
                }

                if (update)
                {
                    OnChangeLocalByNative(this.Value, native);
                    CPieceDataValue<T> newValue = createPieceDataValueT(native);
                    CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, newValue);
                    m_list.Add(l_version);
                    sortAndCompact();
                }
            }
        }

        /// <summary>
        /// Dans le cas d'une égalité de principe, tenter une comparaison basée sur la complétude
        /// </summary>
        /// <param name="remote "></param>
        /// <returns>Indique si la comparaison a été faite</returns>
        /// <remarks></remarks>
        public bool choose(CPieceData<T> remote)
        {
            mergeAll(remote, mergePriority.none);
            // si le merge est effectif (ie l'un des deux a une date définie alors le erge est fait
            // pour provoquer un merge manuel il faut que les deux soient sans date et différents
            return Equals(remote);
        }
        public void mergeManual(CPieceData<T> other)
        {
            //Console.WriteLine("master ? 1 (final:1)   2 ( final:2 ) n:no");
            //string l_resp = Console.ReadLine();
            //if (l_resp == "1")
            //{
            //    Console.WriteLine("merge from first to second");
            //    //Console.WriteLine("merge from second to first")
            //    other.eraseSingleFrom(this);

            //}
            //else if (l_resp == "2")
            //{
            //    Console.WriteLine("merge from second to first");
            //    this.eraseSingleFrom(other);
            //}
            //else
            //{
            Console.WriteLine("abort merge");
            //Return choice.no
            //}
        }

        /// <summary>
        /// Parfois, des valeurs identiques sont indiquées commme des modifications. 
        /// Ordonnancement par ordre chronomogique, et élimination des doublons
        /// </summary>
        protected void sortAndCompact()
        {
            if (m_list.Count < 2) return;
            m_list.Sort(c_comparerInv);
            CPieceDataVersion<T> last = m_list[m_list.Count - 1];
            List<CPieceDataVersion<T>> aux = new List<CPieceDataVersion<T>>(m_list);
            for (int i = m_list.Count - 2; i >= 0; i--)
            {
                CPieceDataVersion<T> current = m_list[i];
                if (current.Data.Equals(last.Data))
                    aux.Remove(current);
                last = current;
            }
            m_list = aux;

        }

        private void eraseSingleFrom(CPieceData<T> a_list)
        {


            if (m_list.Count == 0)
            {
                CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_list.m_list[0].Date, a_list.m_list[0].Data);
                m_list.Add(l_version);

            }
            else
            {
                m_list[0].Data = a_list.m_list[0].Data;
            }
            //  empty = Bool.not_defined;

            onChange();


        }



        public bool Equals(CPieceData<T> obj)
        {
            return Value.Equals(obj.Value);
        }

        /// <summary>
        /// détermine quelle info est maitre dans la perspective de les merger
        /// </summary>
        /// <param name="remote"></param>
        /// <param name="a_priority"></param>
        /// <returns>True  : Je suis maître</returns>
        /// <remarks>Pre-condition:  me != remote</remarks>
        private mergePriority isMaster(CPieceData<T> remote, mergePriority a_priority)
        {
            if (this.Equals(remote))
                throw new PieceDbException(this.ToString() + " and " + remote.ToString() + " are equivalent");

            mergePriority l_consistencyComp = compareByConsistency(remote);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (LastModif == System.DateTime.MinValue && remote.LastModif == System.DateTime.MinValue)
            {
                return a_priority;
            }
            else
            {
                return mergePriority.none;
                //  throw new PieceDbException("meme date de modif pourtant les fichiers sont différents!");
            }
        }
        protected virtual bool CheckLegacyConsistency()
        {
            return true;
        }
        private mergePriority checklegacyModif(CPieceData<T> local)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(local);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
            }

            if (local.Imported) return mergePriority.right;
            return mergePriority.left;
        }

        private mergePriority checklegacyModif(T native)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(native);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
                //right = native qui est master
            }
            if (this.Imported) return mergePriority.left;
            return mergePriority.right;
        }


        private mergePriority compareByConsistency(CPieceData<T> other)
        {
            if (!Significant && other.Significant)
                return mergePriority.right;
            if (Significant && !other.Significant)
                return mergePriority.left;

            if (Empty && !other.Empty)
                return mergePriority.right;
            if (!Empty && other.Empty)
                return mergePriority.left;

            return mergePriority.none;
        }

        private mergePriority compareByConsistency(T native)
        {
            if (!Significant && isSignificant(native))
                return mergePriority.right;
            if (Significant && !isSignificant(native))
                return mergePriority.left;

            return mergePriority.none;
        }

        public System.DateTime LastModif
        {
            get
            {
                if (Empty)
                    return System.DateTime.MinValue;
                //  sortAndCompact();
                return m_list[0].Date;
            }
        }

        public T Value
        {
            get
            {
                if (Empty)
                    return getNullValue();
                //sortAndCompact();
                int i = 0;
                while (true)
                {
                    var version = m_list[i];
                    if (!version.Consider)
                    {
                        i++;
                        continue;
                    }
                    return version.Data.Value;
                }

            }
            set
            {
                if (value.Equals(Value)) return;
                m_list.Insert(0, new CPieceDataVersion<T>(Now, createPieceDataValueT(value)));

            }
        }

        public void removeLastVersion()
        {
            int count = m_list.Count;
            if (count <= 1)
                return;
            m_list.RemoveAt(0);
            sortAndCompact();
        }

        public T LastValue
        {
            get
            {
                if (Empty)
                    return getNullValue();
                int count = m_list.Count;
                if (count < 2)
                    return getNullValue();
                int i = 1;
                while (true)
                {
                    var version = m_list[i];
                    if (!version.Consider)
                    {
                        i++;
                        if (i >= count)
                        {
                            return getNullValue();
                        }
                        continue;
                    }
                    return version.Data.Value;
                }

            }

        }


        private bool Simple
        {
            get { return (m_list.Count == 1 && m_list[0].Date == System.DateTime.MinValue) || Empty; }
        }
        public bool Empty
        {
            get
            {
                //if (empty == Bool.not_defined)
                //{
                bool ret = m_list.Count == 0 || m_list[0].Empty;
                return ret;
                //    empty = ret ? Bool.True : Bool.False;
                //    return ret;
                //}
                //return empty == Bool.True;

            }
        }

        public bool Significant
        {
            get
            {
                if (m_list.Count > 1)
                    return true;
                return m_list.Count == 1 && m_list[0].Significant;
            }
        }
        public abstract bool isSignificant(T value);



        public void checkList(CPieceData<T> other)
        {
            foreach (CPieceDataVersion<T> version in other)
            {
                check(version);
            }
            sortAndCompact();
        }


        /// <summary>
        /// indique si la liste contient déja la version
        /// </summary>
        /// <param name="a_version">version testée</param>
        /// <returns>True : si version connue</returns>
        /// <remarks>On ne prend en compte que les dates définies</remarks>
        private bool Contains(CPieceDataVersion<T> a_version)
        {
            foreach (CPieceDataVersion<T> l_elt in this)
            {
                System.DateTime l_date = l_elt.Date;
                if (l_date > System.DateTime.MinValue && a_version.Date == l_date)
                {
                    return true;
                }
            }
            return false;
        }


        private void check(CPieceDataVersion<T> a_version)
        {
            if (!Contains(a_version))
            {
                if (a_version.Date > System.DateTime.MinValue)
                {
                    if (a_version.Consider)
                    {
                        m_list.Add(a_version);
                        //     empty = Bool.not_defined;
                    }
                }
            }

        }


        public CPieceData(System.Xml.XmlElement a_node)
        {

            bool l_bSingle = false;

            XmlElement l_Mynode = XMLTool.NodeLookUp(a_node, getToken());

            if (l_Mynode == null)
                return;

            XmlAttribute att = l_Mynode.Attributes[CPieceDataValue<T>.TOKEN];
            if (att != null)
            {
                l_bSingle = true;
            }




            foreach (XmlNode l_node in l_Mynode)
            {
                if (!l_bSingle)
                {

                    if (l_node is XmlElement && l_node.Name == CPieceDataVersion<T>.VERSION)
                    {
                        XmlElement l_elt = (XmlElement)l_node;
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(l_elt, this);
                        if ((!l_version.Data.Empty || canErase()))
                        {
                            m_list.Add(l_version);
                        }
                    }
                    else
                    {
                        l_bSingle = true;
                        // break; // TODO: might not be correct. Was : Exit For
                    }
                }
            }

            if (l_bSingle)
            {
                CPieceDataVersion<T> l_version = null;
                if (l_Mynode != null)
                    l_version = new CPieceDataVersion<T>(l_Mynode, this);
                else
                    l_version = new CPieceDataVersion<T>(att.Value, this);
                m_list.Add(l_version);
            }
            sortAndCompact();
        }




        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, getToken());
            if (Simple)
            {
                a_sw.Append(m_list[0].Data.ToString());
            }
            else
            {
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in m_list)
                {
                    l_version.write(a_sw);
                }
            }
            XMLTool.closeBalise(a_sw, getToken());
        }

        protected virtual void writeSimple(XmlWriter w)
        {
            w.WriteElementString(getToken(), m_list[0].Data.ToString());
            //  w.WriteAttributeString(getToken(), m_list[0].Data.ToString()); 
        }

        public void write(XmlWriter w)
        {
            if (Empty)
                return;
            //  w.WriteStartElement(getToken()); 

            if (Simple)
            {
                writeSimple(w);


            }
            else
            {
                w.WriteStartElement(getToken());
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                {
                    l_version.write(w);
                }
                w.WriteEndElement();
            }

        }

        public bool HasChange(CPieceData<T> lastFull)
        {
            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, CPieceData<T> lastFull)
        {
            //if (Empty)
            //    return;
            ////  w.WriteStartElement(getToken()); 

            sortAndCompact();
            lastFull.sortAndCompact();

            if (Value == null)
            {
                if (lastFull.Value == null)
                    return;
            }

            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
            {

                if (Simple)
                {
                    if (lastFull.m_list.Count < 1 || m_list.Count < 1 || !(lastFull.m_list[0].Data.Value.Equals(m_list[0].Data.Value)))
                    {
                        writeSimple(w);
                        return;
                    }


                }
                else
                {
                    w.WriteStartElement(getToken());

                    //    m_list.Sort(c_comparerInv); 

                    //int count = lastFull.m_list.Count;
                    //int count0 = count; 
                    //if (m_list.Count > count)
                    //    count = m_list.Count;

                    //for (int i = count -1 ; i >=0; i++)
                    //{
                    //    CPieceDataVersion<T> my = m_list[i];
                    //    CPieceDataVersion<T> old = null;
                    //    if (i < count0 - 1)
                    //        old = lastFull.m_list[i]; 

                    //    if (old == null)



                    //}
                    foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                    {
                        bool found = false;
                        foreach (CPieceDataVersion<T> l_version_old in new List<CPieceDataVersion<T>>(lastFull.m_list))
                        {
                            if (l_version_old.Date == l_version.Date && l_version_old.Data.Equals(l_version.Data))
                            {
                                found = true;
                                break;
                            }

                        }

                        if (found)
                            continue;
                        l_version.write(w);
                    }
                    w.WriteEndElement();
                }
            }

        }



        public virtual CListDate Dates
        {
            get
            {
                CListDate dates = new CListDate();
                foreach (CPieceDataVersion<T> data in m_list)
                {
                    dates.check(data.Date);
                }
                return dates;
            }
        }
        //private class CDataVersionComparer : IComparer<CPieceDataVersion<T>>
        //{


        //    public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
        //    {
        //        return System.DateTime.Compare(x.Date, y.Date);
        //    }
        //}
        private class CDataVersionComparerInv : IComparer<CPieceDataVersion<T>>
        {
            public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
            {
                if (!x.Consider)
                {
                    if (!y.Consider)
                        return -1 * System.DateTime.Compare(x.Date, y.Date);
                    return 1;
                }
                if (!y.Consider)
                    return -1;

                return -1 * System.DateTime.Compare(x.Date, y.Date);
            }
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return m_list.GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public System.Collections.Generic.IEnumerator<CPieceDataVersion<T>> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceDataAlbum.cs">
    <content><![CDATA[using System.Xml;
using pdb.db.piece.value;
using pdb.db.piece.type;
using pdb.util;
using pdb.obj;

namespace pdb.db.piece.data
{

    //class CPieceDataAlbum : CPieceData<Name>
    //{


    //    public CPieceDataAlbum(XmlElement a_node)
           
    //    {
    //        XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
    //        if (l_v2 != null)
    //        {
    //            new_(l_v2);
    //        }
    //        else
    //        {
    //            new_(a_node);
    //        }
    //    }

    //    private void new_(System.Xml.XmlElement a_node)
    //    {
    //        string l_class = XMLTool.getNodeValue(a_node, TOKEN_CLASS);
    //        int l_rating = -1;
    //        string l_strRating = XMLTool.getNodeValue(a_node, TOKEN_RATING);
    //        if (!string.IsNullOrEmpty(l_strRating))
    //            l_rating = Convert.ToInt32(l_strRating);

    //        m_data = new Classement(l_class, l_rating);

    //    }
    //    public CPieceDataAlbum(string a_value)
    //        : base(a_value)
    //    {
    //    }

    //    public override CPieceDataValue<string> createPieceDataValue(XmlElement a_node)
    //    {
    //        return new CPieceDataValueString(a_node);
    //    }
    //    public override CPieceDataValue<string> createPieceDataValue(string a_value)
    //    {
    //        return new CPieceDataValueString(a_value);
    //    }

    //    public override string getToken()
    //    {
    //        return "album";
    //    }
    //    public override string getNullValue()
    //    {
    //        return "";
    //    }
    //    public override CPieceDataValue<string> createPieceDataValueT(string a_value)
    //    {
    //        return new CPieceDataValueString(a_value);
    //    }
    //    public override bool isSignificant(string value)
    //    {
    //        return value.Trim().Length > 0;
    //    }


    //}
    class CPieceDataAlbum : CPieceData<string>
    {


        public CPieceDataAlbum(XmlElement a_node)
            : base(a_node)
        {
        }
        public CPieceDataAlbum(string a_value)
            : base(a_value)
        {
        }

        public CPieceDataAlbum() : base() { }

        public override CPieceDataValue<string> createPieceDataValue(XmlElement a_node)
        {
            return new CPieceDataValueString(a_node);
        }
        public override CPieceDataValue<string> createPieceDataValue(string a_value)
        {
            return new CPieceDataValueString(a_value);
        }

        

        public override string getToken()
        {
            return "album";
        }
        public override string getNullValue()
        {
            return "";
        }
        public override CPieceDataValue<string> createPieceDataValueT(string a_value)
        {
            return new CPieceDataValueString(a_value);
        }
        public override bool isSignificant(string value)
        {
            if (value == null)
                return false;
            if (value.Equals(TrackIdentity.UNKNOW_ALBUM))
                return false; 
            return value.Trim().Length > 0;
        }

        protected override void changeNativeValue(string value)
        {
            observer.changeNativeValueAlbum(value); 
        }


    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceDataClassement.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.type;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;
namespace pdb.db.piece.data
{


    public class CPieceClassement : CPieceData<Classement>
    {

        private const string TOKEN_CLASSEMENT = "classement";
        public CPieceClassement(CPieceClassement o)
            : base(o)
        {
        }

        public CPieceClassement(System.Xml.XmlElement a_node)
            : base(a_node)
        {
            if (XMLTool.NodeLookUp(a_node, getToken()) == null)
            {
                CPieceDataValueClassement l_data = new CPieceDataValueClassement(a_node);
                m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, l_data));
            }   
          //  int count = m_list.Count;
//            if (count > 0)
//            {
//                var version = m_list[count - 1];
//                if (string.IsNullOrEmpty(version.Data.Value.ClassList))
//                {
//                    version.Consider = false;
//                    //  empty = Bool.not_defined; 
//                }
//#if ASC
//                var versionF = m_list[0];
//                var valueOrg = versionF.Data;
//                var classOrg = valueOrg.Value.ClassList;
//                var rating = valueOrg.Value.Rating;
//                if (classOrg.StartsWith("0"))
//                {
//                    classOrg = "1";
//                    rating = 0; 
//                  //  classOrg = classOrg.Remove(0, 1);
//                }

//                valueOrg.Value = new Classement(classOrg, rating); 

//#endif
//            }


        }

        public void initClassementIfEmpty(string classement)
        {
            if (m_list.Count > 0)
                return;
            var cl = pdb.db.piece.type.Classement.create(classement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public void eraseClassement()
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            initClassementIfEmpty("0.0"); 
        }

        public CPieceClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            m_list.Add(new CPieceDataVersion<Classement>(Now,new CPieceDataValueClassement( cl)));
        }

        public CPieceClassement(string a_class, int a_rating)
        {
            Classement l_class = new Classement(a_class, a_rating);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_class)));
            // empty = Bool.not_defined; 

        }

        public CPieceClassement(int a_rating)
            : this("", a_rating)
        {
        }
        public CPieceClassement()
            : base()
        {
        }

        protected override bool CheckLegacyConsistency()
        {
            return false;
        }
        public override CPieceDataValue<Classement> createPieceDataValue(System.Xml.XmlElement a_node)
        {
            return new CPieceDataValueClassement(a_node);
        }

        public override string getToken()
        {
            return TOKEN_CLASSEMENT;
        }

        public override CPieceDataValue<Classement> createPieceDataValue(string a_str)
        {
            return null;
        }

        public override Classement getNullValue()
        {
            return new Classement("", 0);
        }
        public override CPieceDataValue<Classement> createPieceDataValueT(Classement value)
        {
            return new CPieceDataValueClassement(value);
        }

        public override bool isSignificant(Classement value)
        {
            return value.ClassList != "";
        }

        public string ClassList
        {
            get { return Value.ClassList; }


            //TODO A REVOIR
            set
            {
                if (m_list.Count == 0)
                {
                    int l_rating = Rating;
                    Classement l_new = new Classement(value, l_rating);
                    m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_new)));
                    //  empty = Bool.False;
                }
                else
                {
                    if (Value.ClassList != value)
                    {
                        //int l_rating = Rating;
                        //Classement l_new = new Classement(value, l_rating);
                        //m_list.Add(new CPieceDataVersion<Classement>(now, new CPieceDataValueClassement(l_new)));
                        m_list[0].Data.Value.ClassList = value;
                    }
                    // empty = Bool.not_defined;
                }
            }
        }

        protected override void writeSimple(XmlWriter w)
        {
            w.WriteStartElement(getToken());
            m_list[0].Data.write(w); 
            w.WriteEndElement(); 
        }

        public void setClassement(string className, int rating)
        {
            Classement cl = new Classement(className, rating);
            if (m_list.Count == 0)
                m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
            else
                m_list[0].Data.Value = cl; 
            sortAndCompact();
        }

        public void eraseClassement2()
        {
            Classement cl = Classement.create("0.0");
            eraseClassement2(cl); 
        }

        public void eraseClassement2(Classement cl)
        {          
            m_list = new List<CPieceDataVersion<Classement>>();
            m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, new CPieceDataValueClassement(cl)));
        }

        public int Rating
        {
            get { return Value.Rating; }
            set { Value.Rating = value; }
        }



        protected override bool canErase()
        {
            return true;
        }

        public override void Consolid(CPieceData<Classement> remote, mergePriority a_priority)
        {
            base.Consolid(remote, a_priority);
            this.checkList(remote);
        }

        public override void LegacyConsolid(CPieceData<Classement> local)
        {
            base.LegacyConsolid(local);
            this.checkList(local);
        }

        public bool isClassListNumeric { get { return Value.isClassListNumeric; } }



        public String Evol
        {
            get
            {

                if (m_list.Count <= 1) return "++";

                Classement last = m_list[0].Data.Value;
                Classement before = m_list[1].Data.Value;

                String strLast = last.ClassNameAndRating;
                String strBefore = before.ClassNameAndRating;

                int cmp = compareClassNameAndRating(strLast, strBefore);
                if (cmp == 0)
                    return "=";  // normalement impossible
                if (cmp < 0) return "+";
                return "-";
            }

        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

        public List<DateTime> getDates()
        {
            var list = new List<DateTime>();
            foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
            {
                list.Add(version.Date);
            }
            return list; 

        }

        public override CListDate Dates
        {
            get
            {
                var list = new List<DateTime>();
                //    double current = -1;
                sortAndCompact();
                foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
                {
                    //double aux = version.Data.Value.getNormValue();
                    //if (aux != current)
                    //{
                    list.Add(version.Date);
                    // current = aux; 
                    //}
                }
                return new CListDate(list);
            }
        }

        public void Menage(CPiece piece)
        {
            sortAndCompact();
            //   misc.log("ménage " + this); 

            var aux = new List<CPieceDataVersion<Classement>>(m_list);


            //// 1. parcours jusqu'à trouver 1.0
            //int index1 = -1;
            //int count = aux.Count;

            //for (int i = 0; i < count; i++)
            //{
            //   CPieceDataVersion <Classement> clv = aux[i];
            //   if (clv.Data.Value.getNormValue() == 1)
            //   {
            //       index1 = i;
            //       break; 
            //   }
            //}

            //if (index1 >= 0)
            //{
            //    while (aux.Count > index1 + 1)
            //    {
            //        misc.log( piece  + " suppression " + aux[index1 + 1] + " cause départ à 1");
            //        aux.RemoveAt(index1 + 1);
            //    }
            //}

            //2. vérification des allez-retours 
            int count = aux.Count;

            while (count > 2)
            {
                for (int i = 0; i < count; i++)
                {
                    var clv0 = aux[i].Data.Value;
                    if (i + 2 >= count)
                    {
                        count = -1;
                        break;
                    }
                    var clv2 = aux[i + 2].Data.Value;
                    if (clv2.getNormValue() == clv0.getNormValue())
                    {
                        misc.log(piece + "suppression " + aux[i] + " cause doublon avec " + aux[i + 2]);
                        aux.RemoveAt(i);
                        count = aux.Count;
                        break;
                    }
                }

            }

            m_list = aux;
            sortAndCompact();



        }

        public override string ToString()
        {
            return Value.ToString();
        }

        protected override void changeNativeValue(Classement value)
        {
            observer.changeNativeValueClassement(value);
        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\type\Classement.cs">
    <content><![CDATA[using System;
using pdb.db.obj;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.db.piece.type
{

    /// <summary>
    /// type de base de la donnée classement : 
    /// paire : liste / rating 
    /// 
    /// </summary>
    /// <remarks>utilisé comme une valeur simple (entier - string)</remarks>
    public class Classement
    {
        public static Regex regClassement = new Regex(@"([0-5]+)\.([0-5])");
        public static Regex regClassement2 = new Regex(@"([0-5]+)");
        private static bool isClassement(string input) { return string.IsNullOrEmpty(input) || regClassement.IsMatch(input); }

        public static bool canBeClassement(string input) {
            if (string.IsNullOrEmpty(input))
                return true;
            if (regClassement2.IsMatch(input))
                return true;
            if (regClassement.IsMatch(input))
                return true;
            return false; 
        
        }
        public static Classement create(string input)
        {
            if (input != null)
                input = input.Replace(" ", "");
            if (input == "0")
                return new Classement("0", 0); 
            if (!isClassement(input))
                return null;
            if (string.IsNullOrEmpty(input))
                return new Classement("", 0);
            var groups = regClassement.Match(input).Groups;
            return new Classement(groups[1].Value, (20 * Convert.ToInt32(groups[2].Value))); 
        }


        public decimal RapportClassement
        {
            get
            {
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat; 
            }
        }
        private string m_class = "";
        private int m_rating = -1;
        public Classement(string a_class, int a_rating)
        {
            m_class = a_class;
            m_rating = a_rating;
        }

        public Classement(Classement o)
        {
            m_class = o.m_class;
            m_rating = o.m_rating; 

        }
        public string ClassList
        {
            get { return m_class; }
            set { m_class = value; }
        }
        public int Rating
        {
            get { return m_rating; }
            set { m_rating = value; }
        }
        public override bool Equals(object obj)
        {
            if (obj is Classement)
            {
                Classement l_obj = (Classement)obj;
                return m_class.Equals(l_obj.m_class) && m_rating == l_obj.m_rating;
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_class.GetHashCode() + m_rating.GetHashCode();
        }

        #region rang
        private Bool m_numericClassList;
        //private String m_classNameAndRating = "";
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                if (m_numericClassList == Bool.not_defined)
                {
                    if (String.IsNullOrEmpty(m_class)) return false;
                    bool res = m_class.isInteger();  //CUtil.isInteger(m_class);
                    m_numericClassList = res ? Bool.True : Bool.False;
                    return res;
                }
                else
                {
                    return m_numericClassList == Bool.True ? true : false;
                }
            }
        }
        public String ClassNameAndRating
        {
            get
            {
                if (!isClassListNumeric) return "." + getNbStars();
                return m_class + getNbStars();
            }
        }

        public String ClassNameAndRatingWithPt
        {
            get
            {
                if (!isClassListNumeric) return "." + getNbStars();
                return m_class + "."+ getNbStars();
            }
        }
        /// <summary>
        /// Donne la valeur du classement. Pratique pour la comparaison
        /// </summary>
        /// <returns></returns>
        public double getNormValue()
        {
            if (!isClassListNumeric)
                return -1;
            string classNameAndRating = ClassNameAndRating;
            string strDouble = classNameAndRating.Insert(1, ",");
            return Convert.ToDouble(strDouble);
        }

        private String getNbStars() { return (m_rating / 20).ToString(); }
        public override string ToString()
        {
            if (!isClassListNumeric) return m_class;
            return String.Format("{0}.{1}", m_class, getNbStars());
        }


        public decimal ClassementValueDecimal
        {
            get
            {
                if (!isClassListNumeric) return 0;
                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                return Convert.ToDecimal(classNameAndRating);
            }
        }

        //public static bool operator ==(Classement c1, Classement c2)
        //{
        //    return c1.ClassementValueDecimal == c2.ClassementValueDecimal; 
        //}
        //public static bool operator !=(Classement c1, Classement c2)
        //{
        //    return c1.ClassementValueDecimal != c2.ClassementValueDecimal;
        //}

        //public static bool operator >(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal > t2.ClassementValueDecimal;
        //}
        //public static bool operator >=(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal >= t2.ClassementValueDecimal;
        //}
        //public static bool operator <(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal < t2.ClassementValueDecimal;
        //}
        //public static bool operator <=(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal <= t2.ClassementValueDecimal;
        //}

        #endregion

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValue.cs">
    <content><![CDATA[
using pdb.util;
namespace pdb.db.piece.value
{

    public abstract class CPieceDataValue<T> : IData
    {
        protected T m_data;
        public const string TOKEN = "value";
        protected abstract void writeDb(ITextWriter a_sw);
        protected virtual void writeDb(System.Xml.XmlWriter w) { w.WriteAttributeString(TOKEN, m_data.ToString()); }
        public override abstract string ToString();
        public virtual bool Significant
        {
            get { return !Empty; }
        }
        public abstract bool Empty { get; }

        public abstract CPieceDataValue<T> createCopy();

       

        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            writeDb(a_sw);
        }

        public void write(System.Xml.XmlWriter a_sw)
        {
            if (Empty)
                return;
            writeDb(a_sw);
        }
      
        public virtual T Value
        {
            get { return m_data; }

            set { m_data = value; }
#if ASC
#endif
        }

        public bool Equals(CPieceDataValue<T> other)
        {
            return m_data.Equals(other.m_data);
        }

    }

 
  
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValueClassement.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.db.piece.type;
using pdb.util;
using pdb.db.piece.data;

namespace pdb.db.piece.value
{
    public class CPieceDataValueClassement : CPieceDataValue<Classement>
    {
        public const string TOKEN_CLASS = "class";

        private const string TOKEN_RATING = "rating";
        //private const string TOKEN_CL = "cl"; 
        public CPieceDataValueClassement(Classement a_value)
        {
            m_data = a_value;
        }

        public override CPieceDataValue<Classement> createCopy()
        {
            var o = new CPieceDataValueClassement(new Classement(m_data));
            return o;
        }

        private void new_(System.Xml.XmlElement a_node)
        {
            var att = a_node.Attributes[TOKEN];
            if (att != null)
            {
                string cl = att.Value;
                m_data = Classement.create(cl);
                return; 
            }
            string l_class = XMLTool.getNodeValue(a_node, TOKEN_CLASS);
            int l_rating = -1;
            string l_strRating = XMLTool.getNodeValue(a_node, TOKEN_RATING);
            if (!string.IsNullOrEmpty(l_strRating))
                l_rating = Convert.ToInt32(l_strRating);

            m_data = new Classement(l_class, l_rating);

        }

        public CPieceDataValueClassement(System.Xml.XmlElement a_node)
        {
            XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
            if (l_v2 != null)
            {
                new_(l_v2);
            }
            else
            {
                new_(a_node);
            }

        }

        public override bool Equals(object obj)
        {
            if (obj is CPieceDataValueClassement)
            {
                CPieceDataValueClassement l_obj = (CPieceDataValueClassement)obj;
                return this.m_data.Equals(l_obj.m_data);
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_data.GetHashCode();
        }

        public override bool Empty
        {
            get { return string.IsNullOrEmpty(m_data.ClassList);  } //&& m_data.Rating <= 0; }
        }
        public override bool Significant
        {
            get { return !string.IsNullOrEmpty(m_data.ClassList) && m_data.Rating >= 0; }
        }

        public override string ToString()
        {
            return m_data.ClassNameAndRatingWithPt; 
            var l_sw = new StringBuilder();
            XMLTool.writeValue(l_sw, TOKEN_CLASS, m_data.ClassList);
            XMLTool.writeValue(l_sw, TOKEN_RATING, m_data.Rating);
          //  l_sw.Close();
            return l_sw.ToString();
        }

        protected override void writeDb(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN_CLASS, XMLTool.RefToXml(m_data.ClassList));
            XMLTool.writeValue(a_sw, TOKEN_RATING, m_data.Rating);
        }

        //protected override void writeDb(XmlWriter w)
        //{
        //    w.WriteAttributeString(CPieceClassement.TOKEN_CLASSEMENT, m_data.ClassNameAndRatingWithPt);  
        //   //w.WriteElementString(TOKEN_CLASS, m_data.ClassList);
        //   //w.WriteElementString(TOKEN_RATING, m_data.Rating.ToString()); 
        //}

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValueInteger.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.util;

namespace pdb.db.piece.value
{
    public class CPieceDataValueInteger : CPieceDataValue<int>
    {
        protected const int INT_EMPTY = -1;

        private void new_(string a_str)
        {
            m_data = INT_EMPTY;
            if (a_str != null && a_str.Trim().Length > 0)
            {
                m_data = Convert.ToInt32(a_str.Trim());
            }
        }
        public CPieceDataValueInteger(string a_innerXml)
        {
            new_(a_innerXml);
        }
        public override CPieceDataValue<int> createCopy()
        {
            return new CPieceDataValueInteger(m_data); 
        }

        public CPieceDataValueInteger(int value)
        {
            m_data = value;
        }
        public CPieceDataValueInteger(XmlElement a_node)
        {
            XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
            var att = a_node.Attributes[TOKEN];
            if (l_v2 != null)
            {
                new_(l_v2.InnerText);
            }
            else if (att != null)
                new_(att.Value); 
            else
            {
                new_(a_node.InnerText);
            }
           
        }


        public override bool Empty
        {
            get { return m_data < INT_EMPTY + 1; }
        }

        protected override void writeDb(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN, m_data);
        }

        //protected override void writeDb(XmlWriter w)
        //{
        //    w.WriteElementString(TOKEN, m_data.ToString()); 
        //}
    

        public override string ToString()
        {
            if (m_data < 0)
                return "";
            return m_data.ToString();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\value\CPieceDataValueString.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;

namespace pdb.db.piece.value
{
    public class CPieceDataValueString : CPieceDataValue<string>
    {

        public void new_(string a_str)
        {
            m_data = XMLTool.FromXml(a_str.Trim());
            DateTime dt = DateTime.MinValue;
            if (DateTime.TryParse(a_str.Trim(), out dt))
                m_data = "";

        }

        public CPieceDataValueString(string a_str)
        {
            new_(a_str);
        }

        public override CPieceDataValue<string> createCopy()
        {
            return new CPieceDataValueString(m_data);
        }
        public CPieceDataValueString(XmlElement a_node)
        {
            XmlElement l_v2 = XMLTool.NodeLookUp(a_node, TOKEN);
            var att = a_node.Attributes[TOKEN];
            if (l_v2 != null)
            {
                new_(l_v2.InnerText);
            }
            else if (att != null)
            {
                new_(att.Value);
            }
            else
                new_(a_node.InnerText); 
        }
        public override bool Empty
        {
            get { return m_data == null || m_data == ""; }
        }



        protected override void writeDb(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN, XMLTool.RefToXml(m_data));
        }

        //protected override void writeDb(XmlWriter w)
        //{
        //    w.WriteElementString(TOKEN, m_data);
        //}

        public override string ToString()
        {
            return XMLTool.RefToXml(m_data);
        }

        //public override bool Significant
        //{
        //    get
        //    {
        //        if (!base.Significant)
        //            return false; 
        //        string value
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\version\CPieceDataVersion.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.value;
using pdb.util;
namespace pdb.db.piece.version
{

    /// <summary>
    /// Enregistrement d'une version d'une valeur
    /// deux parties = date de modif et valeur (générique)
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <remarks></remarks>
    public class CPieceDataVersion<T>  : IData
    {
        public const string VERSION = "version";
        private const string TOKEN_DATE = "date";
        private System.DateTime m_date;

        protected CPieceDataValue<T> m_value;
        public CPieceDataVersion(System.DateTime a_date, CPieceDataValue<T> a_value)
        {
            m_date = a_date;
            m_value = a_value;
        }

        public CPieceDataVersion(CPieceDataVersion<T>  o)
        {
            m_date = o.m_date;
            m_value = o.m_value.createCopy();             
        }

      

        private bool _consider = true;
        public bool Consider { get { return _consider; } set { _consider = value; } }

        public CPieceDataVersion(XmlElement a_node, CPieceData<T> a_pieceData)
        {
            System.DateTime l_date = System.DateTime.MinValue;
            XMLTool l_xml = new XMLTool(a_node);
            string l_strDate = l_xml.getNodeValue(TOKEN_DATE);
            if (string.IsNullOrEmpty(l_strDate))
            {
                var att = a_node.Attributes[TOKEN_DATE];
                if (att != null)
                    l_strDate = att.Value;
            }
            if (!string.IsNullOrEmpty(l_strDate))
                l_date = Convert.ToDateTime(l_strDate);
            m_date = l_date;
            m_value = a_pieceData.createPieceDataValue(a_node);
        }


        public CPieceDataVersion(string a_value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValue(a_value.TrimSafe());
        }

        public CPieceDataVersion(T value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValueT(value);
        }

        public bool Significant
        {
            get { return m_value.Significant; }
        }
        public bool Empty
        {
            get { return (m_date == System.DateTime.MinValue && m_value.Empty) || (!_consider); }
        }
        public System.DateTime Date
        {
            get { return m_date; }
        }
        public CPieceDataValue<T> Data
        {
            get { return m_value; }
            set { m_value = value; }
        }

        public override string ToString()
        {
            return m_date + ":" + m_value.Value;
        }

        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, VERSION);
            if (m_date > System.DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_DATE, m_date.ToString());
            m_value.write(a_sw);
            XMLTool.closeBalise(a_sw, VERSION);
        }

        #region IData Members


        public void write(XmlWriter w)
        {
            if (Empty)
                return;


            w.WriteStartElement(VERSION);
            if (m_date > System.DateTime.MinValue)
                w.WriteAttributeString(TOKEN_DATE, m_date.ToString());
            //  w.WriteElementString(TOKEN_DATE, m_date.ToString()); 
            m_value.write(w);
            w.WriteEndElement();
        }

        #endregion
    }
}
]]></content>
  </file>
  <file path="\pieceDb.iT\Loader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Diagnostics;
using pdb.it.detect;
using System.Collections;
using pdb.it.auto;
using pdb.it.persistance;
using pdb.ordo;
using System.Threading.Tasks;

namespace pdb.it
{

    public class Loader : ILoader, ITrackBuilder, IAbortTask // : ILoader
    {
        private Action abortList;
        protected Logger log = Logger.getLogger("Loader");
        private iTunesApp app;
        private IITSource mainLibrairy;
        private IITPlaylistCollection mainPlayLists;
        //  private IITUserPlaylist BIB;
        private PlayList root = PlayList.create("root", null);
        private List<PlayList> logicals = new List<PlayList>();
        private bool listLoaded;
        //private CPlayList rootComposite = new PlayListComposite("root");
        private String m_defaultFolder = @"D:\zique\";
        private String _dBLegacyPath = "";
        private String _dBLegacyDir = "";
        private XmlElement contentXml;

        private ITrackBuilder trackBuilder;
        private List<ITrackInfoItunes> list;
        public ITrackBuilder TrackBuilder { set { trackBuilder = value; } }
        private IPlayListFilter filterPlaylist = new PlayListDefaultFilter();
        public IPlayListFilter PlayListFilter { set { filterPlaylist = value; } }
        public int VolumeMin = -125;



        private BgDict<int, TrackInfoItunes> m_htPieces = new BgDict<int, TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> m_htLoc = new BgDictString<TrackInfoItunes>();
        private BgDict<int, IITFileOrCDTrack> m_htTracks = new BgDict<int, IITFileOrCDTrack>();

        public void getNatives(ArrayList list)
        {
            foreach (IITFileOrCDTrack t in m_htTracks.Values)
                list.Add(t);
        }

        // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();

        //   private Dictionary<int, TrackInList> m_htPiecesInAList = new Dictionary<int, TrackInList>();
        private BgDict<int, PlayListComposite> m_htPlayLists = new BgDict<int, PlayListComposite>();
        private PlayListRegister m_htLegacyPLayList; // Dictionary<int, IITUserPlaylist>();

        /// <summary>
        /// index des listes suivant persistantID (Xml) 
        /// </summary>
        private BgDictString<PlayList> persistentIDs = new BgDictString<PlayList>();

        #region parsing natif asynchrone
        //  private bool bParsingNativeAsync = true;
        //  private ThreadUtil loopbgLoadTracksNative;

        /// <summary>
        /// dictionnaire des Tracks musique par ID
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTracks = new BgDict<int, IITFileOrCDTrack>();

        private TracksDb persist;
        /// <summary>
        /// dictionnaire tracks par location
        /// </summary>
        //   private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb persistTracks; 
        //  private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        /// <summary>
        /// dictionnaires des tracks de playlist par ID (pas l'ID du track de liste mais l'ID du track de bib)
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTrackList = new BgDict<int, IITFileOrCDTrack>();

        /// <summary>
        /// Cumul des dictionnaires des tracks de playList par location
        /// </summary>
        // private BgDictString<IITFileOrCDTrack> memoTrackList = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb memoTrackList;

        private BgDictString<TrackInList> dictTrackInList = new BgDictString<TrackInList>();

        private BgDictString<TrackInList> logicalDictTrackInList = new BgDictString<TrackInList>();
        private BgDictString<TrackInList> logicalDictTrackInListDeleted = new BgDictString<TrackInList>();


        private static string getKey(string path, string location)
        {
            return String.Concat(path, ":", location).ToLower();
        }

        /// <summary>
        /// Récupération d'un track base ou liste pour ajout de trackListe
        /// </summary>
        /// <param name="location"></param>
        /// <returns></returns>
        public TrackId getAnyTrackByLocation(string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            var t = persist.getTrack(location);
            if (t == null)
            {
                if (FileRegister.Exist(location)) //  File.Exists(location))
                    loadScan("recherche location" + location);
            }
            return t;
        }



        public TrackInList getTrackInList(string path, string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            return dictTrackInList[getKey(path, location)];
        }

        public void recordTrackList(string pl, IITFileOrCDTrack track, int trackDataBaseID, string location, bool memo)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(location))
            {
                StackTrace st = new StackTrace();
                log.log("Loader::recordTrackList location nulle " + st.ToString());
                return;
            }
            //if (!dictTrackList.ContainsKey(trackDataBaseID))
            dictTrackList[trackDataBaseID] = track;
            var key = getKey(pl, location);
            persist.recordTrackList(key, location, track);
            //if (!locationTrack.ContainsKey(location))
            //    locationTrack.record(location, track);

            //if (memo && !memoTrackList.ContainsKey(key))
            //    memoTrackList.record(key, track);

            //  return id;

        }

        public void invalidationTrack(TrackInfoItunes info)
        {
            log.log("invalidation track lors de modification " + info);

            dictTracks.Remove(info.ID);
            dictTrackList.Remove(info.ID);
            persist.invalidation(info.Location);
        }

        public void invalidationTrackInList(string pl, TrackInList tl, IITUserPlaylist _pl)
        {
            log.log("invalidation trackinList " + tl);
            removeTrackInList(pl, tl, _pl);
        }

        /// <summary>
        /// Appelé en cas d'erreur ajout trackList
        /// </summary>
        /// <param name="location"></param>
        /// <param name="id"></param>
        public void invalidationLocation(string location)
        {
            log.log("invalidation track (AddTrack)" + location);
            persist.invalidation(location);
        }


        //public void recordTrackList(PlayList pl, IITFileOrCDTrack track, string location)
        //{

        //    if (!locationTrack.ContainsKey(location))
        //        locationTrack[location] = track;
        //    var key = getKey(pl, location);
        //    memoTrackList[key] = track;
        //}

        public TrackId getMemoTrackList(string path, IITUserPlaylist pl, string location)
        {
            var key = getKey(path, location);
            return persist.getTrackList(key, path, pl);
            // return memoTrackList.getTrackList(key, pl); //  [key];
        }



        private static bool erreurTrackList;
        public static bool ErreurTrackKist { get { return erreurTrackList; } set { erreurTrackList = value; } }



        public void recordTrackInList(string pl, TrackInList track, bool verifDoublon)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            //if (dictTrackInList.ContainsKey(key))
            //{
            //    if (verifDoublon)
            //    {
            //        string txt = "pas deux fois le même élément de liste \r\n" + track + "\r\n" + track.Location;
            //        log.log(txt);

            //        throw new ApplicationException(txt);
            //    }
            //}
            //else
            if (!dictTrackInList.ContainsKey(key))
                dictTrackInList[key] = track;
            // dictTrackInList[getKey(pl, track.Location)] = track;
        }

        public void removeTrackInList(string pl, TrackInList track, IITUserPlaylist plt)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, track.Location, plt);

            dictTrackList.Remove(track.TrackDataBaseId);
            //  locationTrack.remove(track.Location);

        }

        public void removeTrackInList(string pl, string location, int TrackDataBaseId, IITUserPlaylist plt)
        {

            string key = getKey(pl, location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, location, plt);

            dictTrackList.Remove(TrackDataBaseId);
            //  locationTrack.remove(track.Location);
        }

        public void removeTrack(TrackInfoItunes track)
        {
            persist.removeTrack(track.Location);
        }
        /// <summary>
        /// Utilisé pour vérifier avant l'ajout que le track existe
        /// </summary>
        /// <param name="pl"></param>
        /// <param name="track"></param>
        /// <returns></returns>
        public bool LogicalContainsTrackInList(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInList.ContainsKey(key);
        }

        public bool LogicalTrackInListDeleted(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInListDeleted.ContainsKey(key);
        }


        public void LogicalRecordTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInListDeleted.Remove(key);
            logicalDictTrackInList.Add(key, track);
        }

        public void LogicalRemoveTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInList.Remove(key);
            logicalDictTrackInListDeleted.Add(key, track);
        }



        #endregion






        private bool modeXml = true;
        private bool deleteFile;
        private bool errorAccess;
        private bool singleThread;

        //public static Loader Instance
        //{
        //    get
        //    {
        //        if (_instance == null)
        //            _instance = new Loader();
        //        return _instance;
        //    }
        //}


        private Conf conf = new Conf();

        public Conf Conf
        {
            set
            {
                conf = value;
                if (detector != null)
                    detector.Conf = value.Detect;

                PlayList.Conf = conf;
                if (player != null)
                    player.Conf = value;
                TrackWrapper.SingleThread = conf.SingleThread;
                ItUtil.SingleThread = conf.SingleThread;
                singleThread = conf.SingleThread;

            }
        }
        public bool ModeXml { set { modeXml = value; } }
        private Loader(bool deleteFile)
        {
            this.deleteFile = deleteFile;

        }



        #region events
        private string currentReading = "";
        void app_OnPlayerPlayingTrackChangedEvent(object iTrack)
        {

            log.log("app_OnPlayerPlayingTrackChangedEvent:" + iTrack);
            checkChangeSong();
        }

        void app_OnPlayerPlayEvent(object iTrack)
        {
            try
            {
                log.log("app_OnPlayerPlayEvent:" + iTrack);
                checkChangeSong();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

        }

        private string currentSong;
        private DateTime currentSongDt;
        private void getCurrentSong()
        {
            getCurrentTrack();
            getCurrentPlayList();
            currentSongDt = DateTime.Now;


            try
            {

                if (_currentTrack != null)
                {
                    getPlayerState();

                    BackGroundTaskMgr.Playing = _playerState != ITPlayerState.ITPlayerStateStopped;
                    currentSong = _currentTrack.Location + " " + _playerState.ToString();
                }
            }
            catch { }
            getCurrentPlayList();
        }
        private string CurrentSong
        {
            get
            {
                if ((DateTime.Now - currentSongDt).TotalMinutes > 1)
                {
                    getCurrentSong();
                }

                return currentSong;
            }
        }

        private PlayListComposite _currentPlayList;
        private DateTime _currentPlayListTempo;
        private void getCurrentPlayList()
        {
            _currentPlayListTempo = DateTime.Now;
            try
            {
                enter();
                var _cur = app.CurrentPlaylist;
                if (_cur == null)
                    _currentPlayList = null;
                else
                    _currentPlayList = m_htPlayLists[_cur.playlistID];
            }
            finally
            {
                release();
            }
        }
        private IITFileOrCDTrack _currentTrack;
        private void getCurrentTrack()
        {
            currentTrackTempo = DateTime.Now;
            try
            {
                enter();
                _currentTrack = TrackWrapper.create(app.CurrentTrack);
                _currentTrackLocation = "";
                if (_currentTrack != null)
                    _currentTrackLocation = _currentTrack.Location;
            }
            finally
            {
                release();
            }
        }
        public PlayListComposite CurrentPlaylist
        {
            get
            {
                if ((DateTime.Now - _currentPlayListTempo).TotalMinutes > 1)
                {
                    getCurrentPlayList();
                }
                return _currentPlayList;
            }
        }
        private DateTime currentTrackTempo;
        public IITFileOrCDTrack CurrentTrack
        {
            get
            {
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrack;
            }

        }
        private string _currentTrackLocation;
        public string CurrentTrackLocation
        {
            get
            {
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrackLocation;

            }
        }

        private ITPlayerState _playerState;
        private void getPlayerState()
        {
            currentStateTempo = DateTime.Now;
            try
            {
                enter();
                _playerState = app.PlayerState;
            }
            finally
            {
                release();
            }
        }
        private DateTime currentStateTempo;
        public ITPlayerState PlayerState
        {
            get
            {
                if ((DateTime.Now - currentStateTempo).TotalMinutes > 1)
                    getPlayerState();
                return _playerState;
            }
        }


        private void checkChangeSong()
        {
            getCurrentSong();

            var track = CurrentTrackLocation;
            if (!track.Equals(currentReading))
            {
                currentReading = track;
                PlayComputedTrack();
            }

        }
        #endregion



        private bool useDetect;
        public Loader(Conf conf, bool useDetect)
            : this(conf.DeleteFile)
        {
            this.Conf = conf;
            this.m_defaultFolder = conf.DefaultFolder;
            if (!m_defaultFolder.EndsWith(@"\"))
                m_defaultFolder += @"\";
            this.useDetect = useDetect;

            this.player = new AutoPlayer(this, conf);

        }

        public Loader(Conf conf, Action abortList)
            : this(conf, true)
        {
            this.abortList = abortList;
        }

        public void saveIds()
        {
            if (persist != null)
                persist.record();
        }

        private bool initialized;

        public void init()
        {
            if (initialized)
                return;
            initialized = true;
            app = new iTunesApp();

            mainLibrairy = app.LibrarySource;
            mainPlayLists = mainLibrairy.Playlists;

            TrackInfoItunes.Loader = this;
            PlayList.Loader = this;
            //BackGroundTaskMgr.Async = true;
            //BackGroundTaskMgr.start(); 
            trackBuilder = this;
            m_htLegacyPLayList = new PlayListRegister(this.app);
            m_htLegacyPLayList.load("init");

            app.OnPlayerPlayEvent += new _IiTunesEvents_OnPlayerPlayEventEventHandler(app_OnPlayerPlayEvent);
            app.OnPlayerPlayingTrackChangedEvent += new _IiTunesEvents_OnPlayerPlayingTrackChangedEventEventHandler(app_OnPlayerPlayingTrackChangedEvent);


            detector = new Detector(app.LibraryXMLPath, logDetect, conf.Detect);
            if (useDetect)
                detector.start();


            string file = app.LibraryXMLPath;
            // bool exists = File.Exists(file);
            //while (!File.Exists(file))
            //    Thread.Sleep(30);
            m_defaultFolder = getDefaultFolder();
            log.log(m_defaultFolder);

            log.log("suppression:{0} erreur accès:{1}", deleteFile, errorAccess);

            FileInfo fTrack = new FileInfo(_dBLegacyDir + conf.DbTrack);
            DirectoryInfo dir = fTrack.Directory;
            if (!dir.Exists) dir.Create();
            // persistTracks = new TrackDb(app, f.FullName);

            var fTrackList = new FileInfo(_dBLegacyDir + conf.DbTrackList);
            dir = fTrackList.Directory;
            if (!dir.Exists) dir.Create();
            //memoTrackList = new TrackDb(app, f.FullName);

            persist = new TracksDb(app, fTrack.FullName, fTrackList.FullName, conf.ProxyTrack, conf.ProxyTrackList, conf.PersistIt, conf.SingleThread);








            //if (deleteFile)
            //{

            //    //  log.log("suppression de " + file);
            //    while (true)
            //    {
            //        try
            //        {
            //            //if (!errorAccess)
            //            log.log("suppression de " + file);
            //            File.Delete(app.LibraryXMLPath);
            //            break;
            //        }
            //        catch (Exception e)
            //        {
            //            // log.log("error acces " + file);
            //            errorAccess = true;
            //            Thread.Sleep(1000);
            //        }
            //    }
            //}



            //if (deleteFile && errorAccess)
            //    log.log("finalement pas suppression de " + file + " car erreur accès");


        }

        private void enter()
        {
            if (singleThread)
            {
                BgTask.chrono.bip("l:ent0");
                Locker.Enter();
                BgTask.chrono.bip("l:ent1");
            }
        }
        private void release()
        {
            if (singleThread)
                Locker.Release();
        }

        # region detect
        //  private bool waitForNextSong;


        // public bool WaitForNextSong { get { return waitForNextSong; } set { waitForNextSong = value; } }



        private DateTime lastLoad;
        //private DateTime confirmLoad = DateTime.MaxValue;
        private string currentSongWhenLoaded = "";
        private Detector detector;

        public void logDetect(string info)
        {
            log.logNoDate("------------------------------------------------------------------------------------");
            log.log(info);
            log.logNoDate("------------------------------------------------------------------------------------");
        }

        public bool detectModif() { return !detector.canLoad(); }

        public void checkDetect(DateTime ini)
        {
            detector.check(ini);
        }

        public void exception()
        {
            currentSongWhenLoaded = "-";
        }
        public void reset(bool firstStep, bool forceLoad)
        {
            string _current = CurrentSong;
            log.log("reset ::firstStep {0} forceLoad {1} currentSongWhenLoaded :{2} currentSong:{3}", firstStep, forceLoad, currentSongWhenLoaded, _current);

            if (!forceLoad)
                detector.reset();
            //  DateTime lastLoad = DateTime.Now;
            // string currentSongWhenLoaded = "";

            //if (waitForNextSong)
            //    currentSongWhenLoaded = CurrentSong;


            //if (!deleteFile && firstStep)
            //    lastLoad = DateTime.MinValue;
            bool canread = false;

            FileInfo fLibrary = new FileInfo(app.LibraryXMLPath);
            bool condition = false;

            while (!canread)
            {

                try
                {
                    Thread.Sleep(1000);
                    _current = CurrentSong;
                    fLibrary.Refresh();
                    if (fLibrary.Exists)
                    {
                        //DateTime dt = fLibrary.LastWriteTime;
                        ////if (lastLoad == DateTime.MinValue)
                        ////{
                        ////    lastLoad = dt;
                        ////    confirmLoad = dt.AddSeconds(conf.Confirm);
                        ////    condition = true;
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////    log.log("temps chargement:{0} confirm :{1}", lastLoad, confirmLoad);
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////}
                        DateTime now = DateTime.Now;
                        TimeSpan _delta = now - lastLoad;


                        if (condition)
                        {
                            bool load = true;
                            if (!forceLoad)
                                load = detector.canLoad();
                            //if (now > confirmLoad)
                            //{
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("temps de confirmation dépassé {0}", confirmLoad);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    load = true;
                            //}
                            //else if (dt > lastLoad)
                            //{
                            //    nbTick++;
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("library modifiée {0} {1}", dt, nbTick);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    lastLoad = dt;

                            //    if (nbTick <= conf.TickRefresh)
                            //    {
                            //        int delta = conf.ConfirmTick; // (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                            //        DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;
                            //        var _confirmLoad = dt0.AddSeconds(delta);
                            //        var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                            //        if (_confirmLoad2 > _confirmLoad)
                            //            _confirmLoad = _confirmLoad2; 
                            //        if (_confirmLoad > confirmLoad)
                            //            confirmLoad = _confirmLoad;
                            //        log.log("confirm {0}", confirmLoad);
                            //    }

                            //}

                            if (load)
                            {
                                DateTime ini = DateTime.Now;
                                try
                                {

                                    log.logNoDate("***********************************************************************");
                                    log.log("chargement library {0} {1}", _current, _delta);
                                    log.logNoDate("***********************************************************************");
                                    DateTime __tick = DateTime.Now;
                                    XmlDocument doc = new XmlDocument();
                                    doc.XmlResolver = null;
                                    contentXml = null;

                                    gcCollect();
                                    string itXml = app.LibraryXMLPath;
                                    doc.Load(itXml);



                                    var root = doc.DocumentElement;
                                    contentXml = root.ChildNodes[0] as XmlElement;

                                    doc = null;
                                    root = null;
                                    gcCollect();
                                    if (!forceLoad)
                                    {

                                        if (conf.Detect.CancelLoad && !detector.canLoad())
                                        {
                                            log.log("Abort car modif fichiers");
                                            continue;
                                        }
                                        checkDetect(ini);
                                        detector.signalLoad();
                                        canread = true;
                                        lastLoad = DateTime.Now;
                                        condition = false;
                                    }

                                    //   confirmLoad = DateTime.MaxValue;
                                    currentSongWhenLoaded = _current;
                                    log.logNoDate("***********************************************************************");
                                    log.log("fin chargement library {0} ", (DateTime.Now - __tick));
                                    log.logNoDate("***********************************************************************");


                                    return;
                                }
                                catch (Exception ex)
                                {

                                    log.log(ex.ToString());
                                    Thread.Sleep(1000);
                                    //nbTick++;
                                    //dt = fLibrary.LastWriteTime;

                                    //int delta = (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                                    //DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;

                                    //var _confirmLoad = dt0.AddSeconds(delta);
                                    //if (_confirmLoad > confirmLoad)
                                    //    confirmLoad = _confirmLoad;
                                    //var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                                    //if (_confirmLoad2 > _confirmLoad)
                                    //    _confirmLoad = _confirmLoad2; 
                                    //log.log("confirm {0}", confirmLoad);
                                }
                            }
                            else
                            {
                                misc.Pre = "[Load " + detector.Limit.ToLongTimeString() + "] ";
                                continue;
                            }
                        }



                        //  log.log("library modifiée {0}", dt);

                        bool conditionWait = false;
                        bool conditionNoWait = false;


                        if (conf.WaitForNextSong)
                        {
                            conditionWait = _current != currentSongWhenLoaded;
                        }
                        else
                        {
                            conditionNoWait = _delta > conf.Refresh;
                        }




                        if (firstStep || forceLoad || conditionWait || conditionNoWait || _delta > conf.RefreshMax)
                        {

                            condition = true;
                            if (!forceLoad)
                                detector.reset();
                            checkChangeSong();
                            if (abortList != null)
                                abortList();
                            // lastLoad = dt;

                            //if (firstStep)
                            //    confirmLoad = dt.AddSeconds(conf.Confirm);
                            //else
                            //{
                            //    log.log("library modifiée {0} attente modif {1}", dt, (nbTick + 1));
                            //    // if (nbTick <= 1)
                            //    confirmLoad = now.AddSeconds(conf.Confirm);
                            //    log.log("confirm {0}", confirmLoad);


                            //}

                        }
                        //}
                    }


                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                if (!canread)
                {
                    Thread.Sleep(100);
                    if (!condition)
                    {
                        if (conf.WaitForNextSong)
                            Thread.Sleep(conf.Delay);
                    }
                }

            }


        }

        #endregion

        #region Infos

        //public CPiece getPiece(IITTrack track)
        //{
        //    return m_htPieces[track.TrackDatabaseID];
        //}


        //public IITFileOrCDTrack getPieceInList(PieceInAList trackList)
        //{
        //    return m_htPiecesInAList[trackList.ID];
        //}

        //public void deleteTrackInList(PieceInAList trackList)
        //{
        //    TrackInList track = m_htPiecesInAList[trackList.ID];
        //    track.Delete();
        //    //   track.Track.Delete();
        //    m_htPiecesInAList.Remove(trackList.ID);
        //}

        private String getDefaultFolder()
        {
            string path = app.LibraryXMLPath;

            _dBLegacyDir = Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
            _dBLegacyPath = _dBLegacyDir + "iTunes Library.itl";

            String uri = "";

            String token = "<key>Music Folder</key><string>";
            //<key>Music Folder</key><string>file://localhost/F:/bernard/zique/</string>
            log.log("load {0}", path);

            while (true)
            {
                try
                {
                    foreach (String line in File.ReadAllLines(path))
                    {
                        if (line.Contains(token))
                        {
                            Regex regex = new Regex("<string>(.+)</string>");
                            Match m = regex.Match(line);
                            if (!m.Success) return "";
                            uri = m.Groups[1].Value;
                            return new Uri(uri).LocalPath.Replace("\\\\localhost\\", "");
                        }
                    }
                }
                catch
                {
                    errorAccess = true;
                    Thread.Sleep(30);
                }
            }
        }
        public String DefaultFolder
        {
            get
            {
                return m_defaultFolder;
            }
        }
        #endregion

        //public void replace(TrackInfoItunes native, TrackInfoItunes local)
        //{
        //    local.ID = native.ID;
        //    if (m_htPieces.ContainsKey(native.ID))
        //    {
        //        m_htPieces.Remove(native.ID);
        //    }
        //    native.synchroLegacy(local);
        //    m_htPieces[native.ID] = local;
        //}

        #region chargement


        public TrackInfoItunes getInfo(int trackDataBaseId)
        {
            return m_htPieces[trackDataBaseId];
        }

        public void loadTracks(List<ITrackInfoItunes> list)
        {
            lock (this)
            {
                erreurTrackList = false;
                this.list = list;

                //   m_htPieces = new Dictionary<int, TrackInfoItunes>();
                m_htTracks = new BgDict<int, IITFileOrCDTrack>();
                // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();
                // m_htPiecesInAList = new Dictionary<int, TrackInList>();
                m_htPlayLists = new BgDict<int, PlayListComposite>();
                persistentIDs = new BgDictString<PlayList>();
                // m_htLegacyPLayList.load("loadTracks"); //  = new Dictionary<int, IITUserPlaylist>();


                /// <summary>
                /// dictionnaire asynchrone
                /// </summary>
                //dictTracks = new BgDict<int, IITFileOrCDTrack>();
                //locationTrack = new BgDict<string, IITFileOrCDTrack>();
                //dictTrackList = new BgDict<int, IITFileOrCDTrack>();
                dictTrackInList = new BgDictString<TrackInList>();

                log.log("DEBUT loadTracks");
                if (!modeXml)
                {
                    loadTracksNative();
                    return;
                }


                //XmlDocument test = new XmlDocument();
                //test.Load(@"C:\Users\bd\Music\iTunes\test.xml");
                //var trackTest = new TrackInfoItunes(test.DocumentElement); 
                //  list = new List<TrackInfoItunes>();

                //recherche du noeud contenant les données Track
                XmlNode xtracks = null;
                for (int i = 0; i < contentXml.ChildNodes.Count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Tracks")
                    {
                        xtracks = contentXml.ChildNodes[i + 1];
                        break;
                    }
                }

                //   int nb = 0;
                int count = xtracks.ChildNodes.Count;
                bool impair = false;
                foreach (XmlNode xTrack in xtracks.ChildNodes)

                // for (int i = 0; i < count; i += 2)
                {
                    impair = !impair;
                    if (impair)
                        continue;

                    //  var xTrack = xtracks.ChildNodes[i + 1];
                    //int ID = TrackInfoItunes.getID(xTrack);
                    string loc = TrackInfoItunes.getLocation(xTrack);
                    //TrackInfoItunes track = trackBuilder.create(xTrack);


                    TrackInfoItunes track = null;
                    if (m_htLoc.ContainsKey(loc))
                    {
                        track = m_htLoc[loc];
                        track.build(xTrack);

                    }
                    //  log.log("add track {0}", track);

                    else
                    {
                        track = create(loc);
                        track.build(xTrack);
                        if (track.Strange)
                            continue;



                        m_htPieces.Add(track.ID, track);
                        m_htLoc.Add(loc, track);
                    }

                    string location = track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        log.log("phase load :: suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    else if (!FileRegister.Exist(location)) // conf.CheckFileExist && !File.Exists(location))
                    {
                        log.log("phase load :: suppression du track absent " + track.Album + "/" + track.Name + " " + location);
                        track.Delete();
                        continue;
                    }




                    list.Add(track);
                    //  track.Index = nb;
                    //   nb++;

#if VERIF
                track.verif();
#endif
                }
                log.log("FIN loadTracks");
            }

        }

        //private void buildIndexesTracks()
        //{
        //    int count = list.Count;
        //    for (int i = 0; i < count; i++)
        //    {
        //        list[i].Index = i;
        //    }
        //}

        private void bgLoadTracksNative()
        {

            try
            {



                IITTrackCollection tracks = null;
                int count = 0;
                IEnumerator enumerator = null;
                try
                {
                    enter(); tracks = app.LibraryPlaylist.Tracks;
                    count = tracks.Count;
                    enumerator = tracks.GetEnumerator();
                }
                finally { release(); }

                int i = 0;
                while (true)
                //int count  = tracks.Count; 
                //for (int i= 1; i<=count; i++)
                {
                    while (BackGroundTaskMgr.PauseKeyBoard)
                        Thread.Sleep(100);
                    bool _cont = false;

                    try
                    { enter(); _cont = enumerator.MoveNext(); }
                    finally { release(); }
                    if (!_cont)
                        break;
                    i++;

                    try
                    {
                        IITFileOrCDTrack track = null;
                        try
                        {
                            enter();
                            //   var t = tracks[i];
                            track = TrackWrapper.create(enumerator.Current as IITFileOrCDTrack);
                        }
                        finally
                        {
                            release();
                        }
                        if (track == null)
                            continue;

                        //if (t.Kind == ITTrackKind.ITTrackKindFile)
                        //{
                        //lock (this)
                        //{
                        // IITFileOrCDTrack track = t as IITFileOrCDTrack;
                        int l_id = 0;
                        string location = "";
                        try
                        {
                            enter();
                            l_id = track.TrackDatabaseID;
                        }
                        finally
                        {
                            release();
                        }
                        try
                        {
                            enter();
                            location = track.Location;
                        }
                        finally
                        {
                            release();
                        }
                        if (i % 1000 == 0)
                            log.log("scan {0}/{1} id:{2} {3}", i, count, l_id, location);


                        if (location == null)
                        {
                            log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                            try
                            {
                                enter(); track.Delete();
                            }
                            finally
                            {
                                release();
                            }
                            continue;
                        }
                        else
                        {

                            //  log.log("bg Add track " + location);
                            dictTracks[l_id] = track;
                            dictTrackList[l_id] = track;
                            this.persist.recordTrack(location, track);


                        }

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                }
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!!!!!!!!!!!!!!!>>>>>>!!!!!!!!!!!!!!!!!!>>>>FIN bgLoadTracksNative ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
            }
            finally
            {
                lock (this)
                    scanLoaded = false;

                //list = new CListPieceWithoutPodcast(m_htPieces.Values);
            }
        }

        public void loadTracksNative()
        {

            IITTrackCollection tracks = app.LibraryPlaylist.Tracks;

            foreach (IITTrack t in tracks)
            {
                if (t.Kind == ITTrackKind.ITTrackKindFile)
                {
                    IITFileOrCDTrack track = TrackWrapper.create(t);
                    string location = "";
                    try
                    {
                        location = track.Location;
                    }
                    catch
                    {
                    }
                    log.log("add track " + location);

                    if (location.isNullorEmpty())
                    {
                        log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    if (!FileRegister.Exist(location)) //  File.Exists(location))
                    {
                        log.log("Suppression du track absent " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }



                    //if (persist.containsTrack(location))
                    //{
                    //    log.log("suppression du track doublon " + track.Album + "/" + track.Name + " " + track.Location);
                    ////    track.Delete();
                    //    continue;
                    //}

                    persist.recordTrack(location, track);
                    //              String l_strFile = track.Location.Replace(m_defaultFolder, "");
                    int l_id = track.TrackDatabaseID;

                    //string l_Artist = track.Artist.TrimSafe();
                    //string l_Album = track.Album.TrimSafe();
                    //string l_Name = track.Name.TrimSafe();
                    //int l_trackNumber = -1;
                    //if (track.TrackNumber > 100) track.TrackNumber = 0;
                    //if (track.TrackNumber > 0)
                    //{
                    //    l_trackNumber = track.TrackNumber;
                    //}

                    //CPieceReference l_details = new CPieceReference(l_Artist, l_Album, l_Name, l_trackNumber);

                    //int l_year = -1; if (track.Year > 0) l_year = track.Year;
                    //CPieceInfo l_infos = new CPieceInfo(l_year);

                    //int l_rating = 0; if (track.Rating > 0) l_rating = track.Rating;


                    //DateTime l_date = DateTime.MinValue; if (track.PlayedDate > DateTime.MinValue) l_date = track.PlayedDate;

                    //int l_duration = track.Duration;
                    //bool l_enabled = track.Enabled;


                    //CPiece l_piece = new CPiece(l_details, l_strFile, l_infos, l_rating, l_date, l_duration, l_enabled);
                    TrackInfoItunes l_piece = create(location);
                    l_piece.build(track);
                    //new TrackInfoItunes(track);
                   // l_piece.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                    m_htTracks[l_id] = track;
                    m_htPieces[l_id] = l_piece;
                    //l_piece.ID = l_id;
                    //   buildArt(track); 
                    list.Add(l_piece);
                    //  log.log("add track {0}", l_piece);

                }
            }

            log.log("FIN LoadTracksNative ");
            //list = new CListPieceWithoutPodcast(m_htPieces.Values);
        }

        ///// <summary>
        ///// Récupération d'un track  Itunes en fonction de son index
        ///// </summary>
        ///// <param name="id"></param>
        ///// <returns></returns>
        //public IITFileOrCDTrack getTrack(string location)
        //{
        //    if (m_htFileTracks.ContainsKey(location))
        //        return m_htFileTracks[location];

        //    foreach (IITTrack t in app.LibraryPlaylist.Tracks)
        //    {
        //        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //        {
        //            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //            string _loc = track.Location;
        //            if (!m_htFileTracks.ContainsKey(_loc))
        //            {
        //                m_htFileTracks.Add(_loc, track);
        //                if (location.Equals(_loc))
        //                    return track;
        //            }
        //        }
        //    }

        //    return null;



        //}
        /// <summary>
        /// Récupération d'un track en vue de le supprimmer
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public TrackId getTrackTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;

            _track = dictTracks[ID].check(trackInfoItunes.Location);
            TrackPersistantId _id = null;
            TrackId trackId = persist.getTrackTrack(trackInfoItunes.Location);

            if (trackId != null)
            {
                _id = trackId.Id;
                _track = trackId.Track.check(trackInfoItunes.Location);
            }
            #region complique
            if (conf.ComplexSearch)
            {
                if (_track == null)
                {
                    try
                    {
                        enter();
                        int index = list.IndexOf(trackInfoItunes);
                        if (index >= 0)
                            _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);


                        if (_track == null)
                        {
                            loadScan("recherche TrackTrack " + trackInfoItunes.Location);
                            return null;
                        }

                        string attendu = trackInfoItunes.Location;
                        string mesure = _track.Location;
                        persist.recordTrack(mesure, _track); // [mesure] = _track;
                        dictTracks[_track.TrackDatabaseID] = _track;

                        if (attendu.Equals(mesure))
                        {
                            //    log.log("-->bg Add track via getTrack: " + _track.Location);
                            // dictTracks[ID] = _track;
                        }
                        else
                        {

                            //   log.log("-->bg Add BAD track via getTrack attendu :{0}, mesuré {1}", attendu, mesure);
                            loadScan("TrackTrack attendu " + attendu + " <> mesuré " + mesure);
                            return null;
                        }
                    }
                    finally { release(); }
                }
            }
            #endregion
            if (_track == null)
                loadScan("?");

            return new TrackId(_id, _track);
        }



        /// <summary>
        /// Récupération d'un track en vue de le modifier
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public IITFileOrCDTrack getTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;
            //  TrackPersistantId _id = null;
            int IDFound = -1;
            try
            {

                _track = dictTracks[ID];

                if (_track == null)
                {
                    var _t = persist.getTrack(trackInfoItunes.Location);
                    if (_t != null && _t.Track != null)
                    {
                        _track = _t.Track;
                        //_id = _t.Id;
                    }
                }
                BgTask.chrono.bip("getT");
                #region complique
                if (conf.ComplexSearch)
                {
                    if (_track == null)
                    {
                        try
                        {
                            enter();
                            //loadScan("recherche track " + trackInfoItunes);
                            int index = list.IndexOf(trackInfoItunes);
                            if (index >= 0)
                                _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);

                            if (_track != null)
                            {
                                IDFound = _track.TrackDatabaseID;
                                dictTracks[IDFound] = _track;
                                dictTrackList[IDFound] = _track;
                                persist.recordTrack(_track); // [_track.Location] = _track;


                                if (IDFound == ID)
                                { //    log.log("getTrack by ID: " + trackInfoItunes.Location);
                                }
                                else if (_track.Location == trackInfoItunes.Location)
                                    log.log("getTrack by location: " + trackInfoItunes.Location);
                                else
                                {
                                    _track = null;
                                }
                            }
                        }
                        finally { release(); }

                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 2 " + trackInfoItunes);
                        _track = dictTrackList[ID];
                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 4 " + trackInfoItunes);
                        _track = null;
                    }
                }

                #endregion



            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
                loadScan("recherche track Exception " + trackInfoItunes);
            }

            #region complique
            if (conf.ComplexSearch)
            {
                if (_track != null)
                {
                    IDFound = _track.TrackDatabaseID;
                    dictTracks[IDFound] = _track;
                    dictTrackList[IDFound] = _track;
                    persist.recordTrack(_track);
                }
            }
            #endregion

            // return new TrackId(_id, _track);
            return _track;
        }

        //void Track_classNameChanged(object sender, TrackInfoItunes.TrackClassNameEventArgs e)
        //{
        //    TrackInfoItunes track = sender as TrackInfoItunes;
        //    updateClassList(track);
        //}

        //private void updateClassList(TrackInfoItunes piece)
        //{

        //    List<CPlayList> copy = new List<CPlayList>();
        //    foreach (CPlayList list in piece.ClassPlayLists)
        //    {
        //        PieceInAList pieceInList = list.getPieceInList(piece);
        //        if (pieceInList != null)
        //        {

        //            // deleteTrackInList(pieceInList);
        //            pieceInList.Delete();
        //            //    list.remove(pieceInList);
        //            copy.Add(list); //  piece.removePlayList(list);
        //        }
        //    }

        //    String plName = piece.ClassName;
        //    setClassPlayList(piece, plName);

        //    foreach (CPlayList list in copy)
        //    {
        //        piece.removePlayList(list);
        //    }


        //}

        public IEnumerable<ITrackInfoItunes> ListAllTracks { get { return list; } }
        public IEnumerable<ITrackInfoItunes> ListTracks { get { return list.FindAll(t => !t.isPodcast); } }
        public IEnumerable<ITrackInfoItunes> ListPodCast { get { return list.FindAll(t => t.isPodcast); } }
        public void loadListsNative()
        {
            IITSourceCollection sources = app.Sources;

            for (int i = 1; i <= sources.Count; i++)
            {
                loadPlayListsNative(sources[i]);
            }
            //   Console.WriteLine(root.ToString());
        }

        private bool scanLoaded;
        public void loadScan(string raison)
        {
            if (scanLoaded)
                return;

            lock (this)
            {
                if (scanLoaded)
                    return;
                scanLoaded = true;

                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!>>>>DEBUT bgLoadTracksNative ( " + raison + " ) ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");


                var loopbgLoadTracksNative = new ThreadUtil(bgLoadTracksNative, "BgT");
                // loopbgLoadTracksNative.Name = "BgT";
                loopbgLoadTracksNative.Start();
            }
        }
        public void loadLists()
        {
            lock (this)
            {
                log.log("Début load list");
                DateTime begin = DateTime.Now;
                // persistentIDs = new Dictionary<string, PlayList>();
                if (listLoaded)
                {
                    foreach (PlayList logical in logicals)
                    {
                        logical.DeleteBase();
                    }
                }
                root.DeleteChilds(); // = new PlayList("root", null);
                gcCollect();
                if (!modeXml)
                {
                    loadListsNative();
                    return;
                }
                // IITSourceCollection sources = app.Sources;


                //for (int i = 1; i <= sources.Count; i++)
                //{
                //    IITSource source = sources[i];
                //    var playlists = source.Playlists;

                //    foreach (IITPlaylist pl in playlists)
                //    {
                //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                //        {
                //            var upl = pl as IITUserPlaylist;
                //            recordlegacyPlayList(upl);
                //        }
                //        checkDetect(begin);
                //    }
                //}


                //if (bParsingNativeAsync)
                //{
                //    Thread loopbgLoadTracksNative = new Thread(bgLoadTracksNative);
                //    loopbgLoadTracksNative.Name = "BgT";
                //    loopbgLoadTracksNative.Start();
                //}



                XmlNode xPlaylists = null;
                int count = contentXml.ChildNodes.Count;
                for (int i = 0; i < count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Playlists")
                    {
                        xPlaylists = contentXml.ChildNodes[i + 1];
                        break;
                    }
                    continue;
                }


                foreach (XmlNode xDist in xPlaylists.ChildNodes)
                {
                    string KEY = "key";
                    int ID = -1;
                    string persistentID = null;
                    string parentPersistentID = null;
                    bool forgetIt = false;
                    bool folder = false;
                    string name = null;
                    XmlNode contentList = null;
                    int count2 = xDist.ChildNodes.Count;
                    for (int i = 0; i < count2; i += 2)
                    {
                        XmlNode meta = xDist.ChildNodes[i];
                        string value = xDist.ChildNodes[i + 1].InnerText;
                        if (meta.Name == KEY)
                        {
                            switch (meta.InnerText)
                            {
                                case "Master": forgetIt = true; break;
                                case "Distinguished Kind": forgetIt = true; break;
                                case "Name": name = value; break;
                                case "Playlist ID": ID = Convert.ToInt32(value); break;
                                case "Playlist Persistent ID": persistentID = value; break;
                                case "Folder": folder = true; break;
                                case "Parent Persistent ID": parentPersistentID = value; break;
                                case "Playlist Items": contentList = xDist.ChildNodes[i + 1]; break;

                            }

                        }
                    }

                    if (forgetIt)
                        continue;
                    PlayList parent = null;


                    if (parentPersistentID == null)
                        parent = root;
                    else parent = persistentIDs[parentPersistentID];

                    IITUserPlaylist upl = null;
                    try
                    {
                        upl = m_htLegacyPLayList.getItPl(ID, name);
                    }
                    catch
                    {
                        log.log("impossible de charger la liste " + ID + " " + name);
                        throw;
                    }
                    PlayList current = addChildPlayList2(upl, parent, name, ID, persistentID);
                    log.log("add pl {0}", current);

                    if (folder)
                        continue;
                    if (contentList == null)
                        continue;
                    bool _blogic = false;
                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (current.isSubList(logical))
                            {
                                _blogic = true;
                                break;
                            }
                        }
                        if (_blogic)
                            continue;
                    }


                    bool go = filterPlaylist.consider(current);
                    if (!go) continue;

                    ////    if (current.isSubList("gen")) continue;
                    //    if (current.isSubList("auto")) continue;
                    //    if (current.isSubList("d")) continue;
                    //    if (current.isSubList("c")) continue;




                    int countList = contentList.ChildNodes.Count;
                    int ii = 0;
                    foreach (XmlNode xdictTrack in contentList.ChildNodes)
                    {
                        int id = Convert.ToInt32(xdictTrack.ChildNodes[1].InnerText);

                        TrackInfoItunes piece = m_htPieces[id];
                        if (piece == null)
                            continue;

                        TrackInList plPiece = new TrackInList(current, piece, id);
                        plPiece.ID = ID * 1000 * 1000 + ii;
                        current.add(plPiece);
                        //current.addPiece(piece);
                        ii++;
                        afterCreate(current, piece, id);
                    }



                    //   current.scanTracks();



#if VERIF
                current.verif();
#endif
                    log.log("{0} elts", current.ChildsCount);
                }

                if (listLoaded)
                    reintegrateLogical();



                contentXml = null;
                gcCollect();

                checkDetect(begin);
                listLoaded = true;
                log.log("Fin de load Lists");
            }






        }

        private void reintegrateLogical()
        {
            foreach (PlayList pl in logicals)
                pl.reintegrate();
        }

        protected virtual void afterCreate(PlayList playlist, TrackInfoItunes track, int id)
        {
        }

        //private void loadPlayLists(IITSource source)
        //{
        //    log.log("Loader:loadPlayLists source");
        //    IITPlaylist pl;
        //    IITUserPlaylist upl;

        //    for (int index = 1; index <= source.Playlists.Count; index++)
        //    {
        //        pl = source.Playlists[index];
        //        log.log("Loader:loadPlayLists check {0}", pl.Name);
        //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
        //        {
        //            upl = pl as IITUserPlaylist;
        //            recordlegacyPlayList(upl);


        //            if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
        //                upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
        //            {

        //                PlayListComposite parent = null;
        //                IITUserPlaylist iparent = upl.get_Parent();
        //                if (iparent != null)
        //                {
        //                    parent = m_htPlayLists[iparent.playlistID];
        //                }
        //                else
        //                {
        //                    parent = root;
        //                }


        //                CPlayList current = addChildPlayList(parent, upl);

        //                if (current.isSubList("gen")) continue;
        //                if (current.isSubList("auto")) continue;
        //                if (current.isSubList("d")) continue;
        //                if (current.isSubList("c")) continue;

        //                log.log("add pl {0}", current);




        //                //current.ID = upl.playlistID;
        //                //m_htPlayLists.Add(upl.playlistID, current);

        //                //parent.add(current);


        //                if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
        //                {
        //                    foreach (IITTrack t in upl.Tracks)
        //                    {
        //                        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //                        {
        //                            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //                            if (!track.Podcast)
        //                            {
        //                                TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
        //                                TrackInList plPiece = new TrackInList(piece, track);
        //                                plPiece.ID = track.trackID;
        //                                m_htPiecesInAList.Add(plPiece.ID, plPiece);
        //                                current.add(plPiece);
        //                                current.addPiece(piece);
        //                            }
        //                        }
        //                    }
        //                    log.log("{0} elts", current.ChildsCount);
        //                }


        //            }

        //        }
        //    }

        //}

        private void loadPlayListsNative(IITSource source)
        {
            log.log("Loader:loadPlayLists source");
            IITPlaylist pl;
            IITUserPlaylist upl;

            for (int index = 1; index <= source.Playlists.Count; index++)
            {
                pl = source.Playlists[index];
                log.log("Loader:loadPlayLists check {0}", pl.Name);
                if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                {
                    upl = pl as IITUserPlaylist;
                    recordlegacyPlayList(upl);


                    if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
                        upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    {

                        PlayListComposite parent = null;
                        IITUserPlaylist iparent = upl.get_Parent();
                        if (iparent != null)
                        {
                            parent = m_htPlayLists[iparent.playlistID];
                        }
                        else
                        {
                            parent = root;
                        }


                        CPlayList current = addChildPlayList(parent, upl);

                        // if (current.isSubList("gen")) continue;
                        if (current.isSubList("auto")) continue;
                        if (current.isSubList("d")) continue;
                        if (current.isSubList("c")) continue;

                        log.log("add pl {0}", current);




                        //current.ID = upl.playlistID;
                        //m_htPlayLists.Add(upl.playlistID, current);

                        //parent.add(current);


                        if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                        {
                            foreach (IITTrack t in upl.Tracks)
                            {
                                if (t.Kind == ITTrackKind.ITTrackKindFile)
                                {
                                    IITFileOrCDTrack track = TrackWrapper.create(t); // as IITFileOrCDTrack;
                                    if (!track.Podcast)
                                    {
                                        TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
                                        TrackInList plPiece = new TrackInList(piece, track);
                                        plPiece.ID = track.trackID;
                                        // m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                        current.add(plPiece);
                                     //   current.addPiece(piece);
                                    }
                                }
                            }
                            log.log("{0} elts", current.ChildsCount);
                        }


                    }

                }
            }

        }

        private CPlayList addChildPlayList(PlayListComposite parent, IITPlaylist iSubList)
        {
            CPlayList subList = new CPlayList(iSubList.Name);
            subList.ID = iSubList.playlistID;
            //  if (m_htPlayLists.ContainsKey(subList.ID))
            m_htPlayLists.Add(subList.ID, subList);
            m_htLegacyPLayList.recordlegacyPlayList(iSubList as IITUserPlaylist);

            parent.add(subList);
            return subList;
        }

        private PlayList addChildPlayList2(IITUserPlaylist upl, PlayList parent, string name, int ID, string persistentID)
        {
            try
            {
                enter();
                if (!m_htPlayLists.ContainsKey(ID))
                {
                    PlayList subList = null;
                    //bool subListIsGenerated = false; // listLoaded && parent.isSubList(gen);
                    //bool subListIsGen = false; // = parent == root && name == "gen";


                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (logical.Parent != null && parent != null)
                            {
                                if (parent.isSubList(logical))
                                {
                                    subList = parent.getComposite(ID) as PlayList;
                                    break;
                                }
                            }
                        }
                    }

                    if (subList == null)
                    {

                        var strLists = conf.LogicalLists;
                        for (int l = 0; l < strLists.Count; l++)
                        {
                            if (subList != null)
                                break;
                            string strList = strLists[l];
                            string path = strList; // "root" + strList;
                            string[] parts = path.Split('\\');
                            int count = parts.GetLength(0);
                            PlayListComposite current = root;
                            for (int i = 0; i < count; i++)
                            {
                                string part = parts[i];
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                var plPart = current.getComposite(part) as PlayList;
                                //if (plPart == null)
                                //{
                                //    if (listLoaded)
                                //        break;
                                //}
                                if (i == count - 1)
                                {
                                    if (name == part)
                                    {
                                        if (listLoaded)
                                        {
                                            PlayList pl = logicals.Find(lo => lo.Name == name);
                                            if (pl.Parent == null)
                                            {
                                                current.add(pl);
                                                subList = pl;
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            subList = PlayList.create(name, parent, upl);
                                            if (!logicals.Contains(subList))
                                                logicals.Add(subList);
                                            break;

                                        }
                                    }
                                }

                                current = plPart;
                                if (current == null)
                                    break;
                            }

                        }
                    }

                    //if (listLoaded)
                    //{
                    //    foreach (PlayList logical in logicals)
                    //    {
                    //        if (parent.isSubList(logical))
                    //        {
                    //            subList = parent.getComposite(name) as PlayList;
                    //        }
                    //    }
                    //}



                    //if (subListIsGenerated)
                    //    subList = parent.getComposite(name) as PlayList;
                    //else if (subListIsGen && listLoaded)
                    //{
                    //    subList = gen;
                    //    root.add(gen);
                    //}

                    if (subList == null)
                        subList = PlayList.create(name, parent, upl);
                    //if (subListIsGen)
                    //    gen = subList;

                    if (m_htPlayLists.ContainsKey(ID))
                    {
                        var str = string.Format("zarb:ID{0} subList.ID {1} clé existante {2} {3}", ID, subList.ID, subList.getPath(), m_htPlayLists[ID].getPath());

                    }
                    else
                    {

                        subList.ID = ID;

                        m_htPlayLists.Add(subList.ID, subList);
                        persistentIDs.Add(persistentID, subList);
                    }

                }




            }
            finally { release(); }




            return persistentIDs[persistentID]; // subList;
        }




        private void recordlegacyPlayList(IITUserPlaylist upl)
        {
            //  log.log(upl.playlistID + " " + upl.Name);
            //  m_htLegacyPLayList.Add(upl.playlistID, upl);
        }

        //private void recordlegacyPlayList(IITUserPlaylist upl, int index)
        //{
        //    log.log(upl.playlistID + " " + upl.Name);
        //    m_htLegacyPLayList.Add(index, upl);
        //}

        #endregion

        #region manip
        public PlayListComposite getOrCreateFolder(String folder)
        {
            PlayListComposite plFolder = root.getComposite(folder);
            if (plFolder == null)
            {
                IITPlaylist itFolder = app.createFolder(folder);
                recordlegacyPlayList(itFolder as IITUserPlaylist);
                plFolder = addChildPlayList(root, itFolder);
            }
            return plFolder;
        }

        public PlayListComposite getOrCreateFolder(PlayListComposite folder, String name, bool buildIf)
        {
            PlayListComposite pSub = folder.getComposite(name);
            if (pSub == null && buildIf)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITPlaylist itSub = itFolder.createFolder(name);

                pSub = addChildPlayList(folder, itSub);
            }
            return pSub;
        }

        public CPlayList getList(PlayListComposite folder, String name)
        {
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    var itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist);
                    plist = addChildPlayList(folder, itPlist);
                }
                return plist as CPlayList;
            }

        }

        public PlayList getPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            if (folder == null)
                return null;
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null && buildIf)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    IITPlaylist itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist as IITUserPlaylist);
                    plist = addChildPlayList(folder, itPlist);

                    return PlayList.create(name, folder as CPlayList, itPlist as IITUserPlaylist);
                }

                return plist as PlayList;
            }


        }

        public void mergeList(CPlayList playlist, ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task)
        {
            PlayList pl = playlist as PlayList;
            if (pl == null)
            {
                log.log("pas un PLayList {0}", playlist);
                return;
            }

            withOrder = !pl.VerifyDoublon;
            if (withOrder)
                pl.mergeListWithOrder(newElements_, writer, task);
            else
                pl.mergeList(newElements_, writer);
        }




        public void removeList(PlayListComposite folder, String name)
        {
            PlayListComposite plist = folder.getComposite(name);
            if (plist != null)
            {
                IITPlaylist itPlist = m_htLegacyPLayList.getItPl(plist.ID, plist.Name);
                itPlist.Delete();
                m_htLegacyPLayList.Remove(plist.ID, plist.Name);
                m_htPlayLists.Remove(plist.ID);
                folder.remove(plist);
            }
        }

        public void SynchronizePodcast()
        {
            log.log("UpdateIPod");
            app.UpdateIPod();
        }

        public void addList(PlayListComposite folder, String name, ICollection<IFile> list)
        {
            lock (this)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITUserPlaylist itPlist = itFolder.createPlaylist(name);
                recordlegacyPlayList(itPlist as IITUserPlaylist);

                if (list.Count == 0) return;

                //   String[] paths = new String[list.Count+1];

                //for(int i=0; i<list.Count; i++)
                //{
                //    paths[i+1] = list[i].Path ; 
                //}
                //   object objPath = (object)paths;
                //   itPlist.AddFiles(ref objPath); 



                foreach (IFile piece in list)
                {
                    itPlist.AddFile(piece.Location);
                }
            }
        }
        #endregion

        /// <summary>
        /// Rangement de la classList
        /// </summary>
        /// <param name="track"></param>
        /// <param name="orgClassName"></param>
        /// <param name="newClassName"></param>
        //public void setClassPlayList(TrackInfoItunes track, string orgClassName, string newClassName)
        //{
        //    lock (this)
        //    {

        //        //1. Suppression
        //        var list = new List<CPlayList>(track.ClassPlayLists);
        //        foreach (CPlayList pl in list)
        //        {
        //            if (pl.Name.Equals(newClassName))
        //                continue;
        //            var trackInList = pl.getPieceInList(track);
        //            if (trackInList != null)
        //                trackInList.Delete();
        //        }

        //        //2. vérif que la liste cible ne contient pas déjà le track
        //        foreach (CPlayList pl in list)
        //        {
        //            if (!pl.Name.Equals(newClassName))
        //                continue;
        //            var trackInList = pl.getPieceInList(track);
        //            if (trackInList != null)
        //                return;
        //        }

        //        //3. ajout
        //        PlayList newpl = getClassPlayList(newClassName);
        //        newpl.Add(track.Location, "setClassPlayList", true);

        //    }


        //}

        public PlayList getFolderOrList(PlayList root, string name, bool findFolder)
        {
            if (root == null)
                root = this.root;
            var current = root;

            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {
                    var plComposite = plComponent as PlayListComposite;
                    if (plComposite.Name == name)
                    {
                        var playList = plComposite as PlayList;
                        var specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone;
                        if (findFolder)
                            specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder;
                        if (playList.ItPlayList.SpecialKind == specialKind)
                        {
                            return playList;

                        }
                    }

                }
            }

            return null;

        }

        private PlayList searchClassList(PlayList current, string listName)
        {
            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {

                    var plComposite = plComponent as PlayListComposite;
                    var name = plComposite.Name;

                    bool sameBase = true;

                    for (int i = 0; i < listName.Length && i < name.Length; i++)
                    {
                        if (!listName[i].Equals(name[i]))
                        {
                            sameBase = false;
                            break;
                        }
                    }

                    if (!sameBase)
                        continue;

                    var playList = plComposite as PlayList;
                    var subSearch = searchClassList(playList, listName);

                    if (subSearch != null)
                        return subSearch;

                    if (name.Equals(listName))
                    {
                        if (playList.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            return playList;
                    }

                }
            }
            return null;
        }


        private PlayList getClassPlayList(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;

                var search = searchClassList(classement, listName);
                if (search != null)
                    return search;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false);
                if (last == null)
                {

                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);


                }

                return last as PlayList;
            }

        }


        private PlayList getClassPlayList__OLD(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false); // current.getComposite(listName);
                if (last == null)
                {
                    //if (current.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    //{
                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);
                    //}

                }

                return last as PlayList;
            }

        }


        public PlayList getOrCreatePlayList(PlayList root, string listName, bool isFolder)
        {
            if (_aborted)
                return null;
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;

                if (root == null)
                    root = this.root;


                var pl = getFolderOrList(root, listName, isFolder);

                if (pl == null)
                {
                    if (_aborted)
                        return null;
                    IITUserPlaylist itPlayList = null;
                    if (isFolder)
                    {
                        if (root == this.root)
                            itPlayList = app.createFolder(listName);
                        else
                            itPlayList = root.ItPlayList.createFolder(listName);

                    }
                    else
                    {
                        if (root == this.root)
                            itPlayList = app.createPlaylist(listName);
                        else
                            itPlayList = root.ItPlayList.createPlaylist(listName);
                    }

                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    pl = PlayList.create(listName, root, itPlayList);
                }

                return pl;
            }
        }

        //public PlayList getOrCreatePlayList(string listName, bool isFolder)
        //{
        //    return getOrCreatePlayList(this.root, listName, isFolder);
        //}



        public void setClassPlayList(ITrackMetaData piece, String listName)
        {
            lock (this)
            {
                if (String.IsNullOrEmpty(listName)) return;
                //String listName = piece.ClassList;
                IITUserPlaylist itCurrent;
                PlayListComposite classement = getOrCreateFolder(CPlayList.CLASSEMENT);

                PlayListComposite current = classement;


                if (listName.isInteger())
                {

                    for (int i = 0; i < listName.Length; i++)
                    {
                        String FolderOrList = listName.Substring(0, i + 1);

                        PlayListComposite subList = current.getComposite(FolderOrList);
                        //  PlayListComposite parent = current.Parent; 
                        IITUserPlaylist itSubList;
                        // IITUserPlaylist itParent = m_htLegacyPLayList[parent.ID]; 
                        if (subList == null)
                        {
                            itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);

                            if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            {

                                var currentName = itCurrent.Name;
                                // suppression et mémorisation des pistes
                                var listAux = new List<ITrackMetaData>();
                                foreach (IITFileOrCDTrack track in itCurrent.Tracks)
                                {
                                    ITrackMetaData pieceToMove = m_htPieces[track.TrackDatabaseID];
                                    listAux.Add(pieceToMove);
                                    // m_htPiecesInAList.Remove(track.trackID);
                                    track.Delete();
                                }

                                // suppression de la liste
                                PlayListComposite parent = current.Parent;
                                IITUserPlaylist itParent = m_htLegacyPLayList.getItPl(parent.ID, parent.Name);

                                itCurrent.Delete();
                                parent.remove(current);
                                m_htPlayLists.Remove(current.ID);

                                // création durépertoire                                                       
                                itCurrent = itParent.createFolder(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itCurrent);
                                current = addChildPlayList(parent, itCurrent);

                                //remplacement de la liste supprimée
                                IITUserPlaylist itRempl = itCurrent.createPlaylist(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itRempl);
                                PlayListComposite rempl = addChildPlayList(current, itRempl);

                                // ajout des morceaux
                                foreach (ITrackMetaData pieceToMove in listAux)
                                {
                                    IITOperationStatus status = itRempl.AddFile(pieceToMove.Location);
                                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                                    TrackInList plPiece = new TrackInList(pieceToMove, track);
                                    plPiece.ID = track.trackID;
                                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                    rempl.add(plPiece);
                                }

                            }
                            itSubList = i < listName.Length - 1 ? itCurrent.createFolder(FolderOrList) as IITUserPlaylist : itCurrent.createPlaylist(FolderOrList) as IITUserPlaylist;
                            recordlegacyPlayList(itSubList as IITUserPlaylist);
                            subList = addChildPlayList(current, itSubList);
                        }
                        current = subList;
                    }

                }
                else
                {
                    PlayListComposite subList = current.getComposite(listName);
                    if (subList == null)
                    {
                        itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); // [current.ID];
                        IITPlaylist itSubList = itCurrent.createPlaylist(listName);
                        recordlegacyPlayList(itSubList as IITUserPlaylist);
                        subList = addChildPlayList(current, itSubList);
                    }
                    current = subList;
                }

                itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); //  [current.ID];
                if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                {
                    PlayListComposite sub = current.getComposite(itCurrent.Name);
                    if (sub == null)
                    {
                        IITUserPlaylist itSubList = itCurrent.createPlaylist(itCurrent.Name) as IITUserPlaylist;
                        recordlegacyPlayList(itSubList);
                        sub = addChildPlayList(current, itSubList);
                    }
                    current = sub;
                    itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);
                }


                {
                    IITOperationStatus status = itCurrent.AddFile(piece.Location);
                    if (status == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                    if (track == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    TrackInList plPiece = new TrackInList(piece, track);
                    plPiece.ID = track.trackID;
                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                    current.add(plPiece);
                    TrackInfoItunes trackBib = m_htPieces[track.TrackDatabaseID];
                    //CPlayList pl = current as CPlayList;
                    //if (pl != null)
                    //    pl.addPiece(trackBib);

                }
            }


        }
        //public ITrackMetaData getTrack(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes; 
        //    if (track == null || !exists(piece) )
        //        return new TrackInfoItunes(getNewTrack(piece));

        //    return track;
        //}


        //public IITFileOrCDTrack AddFile(IITUserPlaylist pl, string location)
        //{
        //    IITFileOrCDTrack track = null;
        //    IITOperationStatus status = pl.AddFile(location);
        //    if (status == null)
        //    {
        //        log.log("{0} : unable to AddFile {0}", pl.Name, location);
        //        return null;
        //    }
        //    while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
        //    {
        //        Thread.Sleep(30);
        //    }

        //    track = status.Tracks[1] as IITFileOrCDTrack;
        //    return track;
        //}


        public void createTrack(TrackInfoItunes piece)
        {

            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);
                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }
                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    piece.TrackTrack = new NoTrack(piece);
                    return;
                }



                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                m_htTracks.Add(track.TrackDatabaseID, track);
                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, piece);
                piece.TrackTrack = track;
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }

        }

        public TrackInfoItunes getNewTrack(IFile piece)
        {

            TrackInfoItunes intern = null;
            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return null;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);
                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    return m_htPieces[track.TrackDatabaseID]; // m_htTracks[track.TrackDatabaseID];
                }
                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    return null;
                }

                intern = create(track.Location);
                intern.build(track);
                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                m_htTracks.Add(track.TrackDatabaseID, track);
                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, intern);
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }
            return intern;
        }



        //private TrackInfoItunes getNewTrack(ITrackNative piece)
        //{

        //    //PlayListComposite plNew = root.getComposite("news");
        //    //IITUserPlaylist itNews;
        //    //if (plNew == null)
        //    //{
        //    //    itNews = app.CreatePlaylist("news") as IITUserPlaylist;
        //    //    recordlegacyPlayList(itNews);
        //    //    plNew = addChildPlayList(root, itNews);
        //    //}

        //    //itNews = m_htLegacyPLayList[plNew.ID];

        //    //// String[] path = new String[] { piece.Path };
        //    //IITOperationStatus status = itNews.AddFile(piece.Path);
        //    //track = status.Tracks[1] as IITFileOrCDTrack;
        //    //piece.ID = track.TrackDatabaseID;
        //    //m_htTracks.Add(track.TrackDatabaseID, track);
        //    //m_htPieces.Add(track.TrackDatabaseID, piece);
        //    //return track;

        //    TrackInfoItunes intern = getNewTrack(piece as IFile);

        //    try
        //    {
        //        intern.Artist = piece.Artist;
        //    }
        //    catch { log.log("unable to change artist {0}  {1}", piece.Artist, piece); }
        //    try
        //    {
        //        intern.Album = piece.Album;
        //    }
        //    catch { log.log("unable to change album  {0}  {1}", piece.Album, piece); }
        //    try
        //    {
        //        intern.Name = piece.Name;
        //    }
        //    catch { log.log("unable to change name  {0}  {1}", piece.Name, piece); }
        //    try
        //    {
        //        if (piece.TrackNumber > 100000) intern.TrackNumber = 0;
        //        if (piece.TrackNumber > 0)
        //        {
        //            intern.TrackNumber = piece.TrackNumber;
        //        }
        //        else
        //        {
        //            intern.TrackNumber = 0;
        //        }
        //    }
        //    catch { log.log("unable to change number  {0} {1}", piece.TrackNumber, piece); }
        //    if (piece.Year > 0) try { intern.Year = piece.Year; }
        //        catch { log.log("unable to change year  {0} {1}", piece.Year, piece); }

        //    if (piece.Rating >= 0) try { intern.Rating = piece.Rating; }
        //        catch { log.log("unable to change rating  {0} {1}", piece.Rating, piece); }

        //    try
        //    {
        //        if (!string.IsNullOrEmpty(piece.ClassName))
        //        {
        //            setClassPlayList(intern, "", piece.ClassName);
        //        }
        //    }
        //    catch
        //    {
        //        log.log("unable to change className  {0} {1}", intern.ClassName, piece);
        //    }

        //    try { intern.Enabled = piece.Enabled; }
        //    catch { log.log("unable to change check  {0} {1}", piece.Enabled, piece); }

        //    return intern;


        //}


        //private bool exists(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes;
        //    if (track == null) return false;
        //    return m_htTracks.ContainsKey(track.ID);
        //}

        //public ITrackInfoItunes createLegacyTrack(ITrackNative piece)
        //{
        //    return getNewTrack(piece);
        //}

        //public IITTrackCollection Tracks
        //{
        //    get { return app.LibraryPlaylist.Tracks; }
        //}

        public void Disconnect()
        {
            app = null;
            gcCollect();
        }
        private void gcCollect()
        {
            if (conf.GcCollect)
                misc.gcCollect("Loader");
        }
        public String DbPath { get { return _dBLegacyPath; } }
        public string DbDir { get { return _dBLegacyDir; } }

        public void deleteTrack(String location)
        {
            if (location.isNullorEmpty())
            {
                log.log("Loader: unable to delete track, location empty!");
                return;
            }
            location = location.ToLower();
            //     private Dictionary<int, TrackInfoItunes> m_htPieces = new Dictionary<int, TrackInfoItunes>();
            //private Dictionary<int, IITFileOrCDTrack> m_htTracks = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, IITFileOrCDTrack> m_htPiecesInAList = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, PlayListComposite> m_htPlayLists = new Dictionary<int, PlayListComposite>();
            // private Dictionary<int, IITUserPlaylist> m_htLegacyPLayList = new Dictionary<int, IITUserPlaylist>();
            TrackInfoItunes info = null;
            foreach (TrackInfoItunes _info in m_htPieces.Values)
            {
                if (_info.Location.isNullorEmpty()) continue;
                if (_info.Location.ToLower() == location)
                {
                    info = _info;
                    break;
                }

            }
            if (info == null)
            {
                log.log("Loader:deleteTrack '{0}' non trouvé", location);
                return;
            }

            try
            {
                log.log("Loader:deleteTrack: delete'{0}'", location);
                int ID = info.ID;
                // IITFileOrCDTrack track = info.Track;

                List<TrackInList> listToDelete = new List<TrackInList>();
                //foreach (TrackInList trackInList in info.ClassPlayLists
                //{
                //    if (trackInList.ID == ID)
                //    {
                //        listToDelete.Add(trackInList);
                //    }
                //}

                //foreach (TrackInList trackInList in listToDelete)
                //{
                //    m_htPiecesInAList.Remove(trackInList.ID);
                //    trackInList.Delete();
                //}


                info.Delete();
                list.Remove(info);
                //buildIndexesTracks();
            }
            catch
            {

                log.log("Loader:unable to deleteTrack: '{0}'", location);
            }
        }



        public ITrackInfoItunes createTrack(int id, String location)
        {
            if (!location.isMusic())
                return null;
            //if (location.ToLower().EndsWith(".m3u")) return null;
            //if (location.ToLower().EndsWith(".pls")) return null;
            //if (location.ToLower().EndsWith(".jpg")) return null;
            //if (location.ToLower().EndsWith(".png")) return null;
            return getNewTrack(new FileLocation(location, id));
        }
        private class FileLocation : IFile
        {
            String file;
            int id;
            public FileLocation(String file, int id) { this.file = file; this.id = id; }
            public string Location { get { return file; } }

            public override string ToString()
            {
                return file;
            }



            public int PieceId
            {
                get { return id; }
            }
        }


        public PlayListComposite TreePlayList
        {
            get { return root; }
        }



        #region ITrackBuilder Members



        #endregion

        public virtual TrackInfoItunes create(string location)
        {
            return new TrackInfoItunes() { Location = location };
        }

        # region lecture
        private AutoPlayer player;
        public List<TrackInList> NextTracks { set { player.NextTracks = value; } }
        public TrackInList CurrentTrackInList { get { return player.CurrentTrack; } }
        public void PlayComputedTrack()
        {
            player.PlayComputedTrack();
        }
        //private TrackInList nextTrack;
        //private TrackInList currentTrack; 
        //public TrackInList NextTrack
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("NextTrack:: old : {0}, new {1}", nextTrack, value);
        //        nextTrack = value;
        //    }
        //    get
        //    {
        //        return nextTrack;
        //    }
        //}

        //public TrackInList CurrentTrackInList
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("CurrentTrack:: old : {0}, new {1}", currentTrack, value);
        //        currentTrack = value;
        //    }
        //    get
        //    {
        //        return currentTrack;
        //    }
        //}

        //public void PlayComputedTrack()
        //{
        //    if (conf == null || !conf.AutoPlay)
        //        return;
        //    try
        //    {
        //        if (app.PlayerState != ITPlayerState.ITPlayerStatePlaying)
        //            return;
        //        var usualTrack = CurrentTrackLocation;
        //        if (nextTrack == null)
        //            return;
        //        if (currentTrack == null)
        //            return;
        //        if (usualTrack.Equals(currentTrack.Location))
        //            return;
        //        if (usualTrack.Equals(nextTrack.Location))
        //            return;
        //        log.log("PlayComputedTrack::usualTrack:{0} nextTrack:{1}", usualTrack, nextTrack.Location);
        //        nextTrack.play();
        //        currentReading = nextTrack.Location;
        //        nextTrack = null;


        //    }
        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }


        //}
        #endregion

        private bool _aborted;
        public bool Aborted
        {
            get
            {
                return _aborted;
            }
            set
            {
                _aborted = value;
            }
        }
    }

    public static class TrackUtil
    {

    }
}


]]></content>
  </file>
  <file path="\pieceDb.iT\PlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using iTunesLib;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.IO;
using pdb.it.persistance;

namespace pdb.it
{


    public class PlayList : CPlayList
    {
        private static Loader loader;
        private static Conf conf;
        private static volatile object _lockP = new object();

        private string path;

        public static Loader Loader { set { loader = value; } }
        //  private static int nbReq;
        // private static int nbErr;
        //  private volatile object _lock = new object();
        //private bool scanLaunched = false; 
        // private int indexScan = 1;
        private static BgDictString<int> dictIndex = new BgDictString<int>();
        public static Conf Conf
        {
            set
            {
                conf = value;
                _singleThread = conf.SingleThread;
                scanListLimit = conf.ScanListLimit;
                _gcCollect = conf.GcCollect;
                NbScan = conf.MaxScan;
            }
        }
        private void enter()
        {
            if (_singleThread)
            {
                BgTask.chrono.bip("pl:ent0");
                Locker.Enter();
                BgTask.chrono.bip("pl:ent1");
            }
        }
        private void release()
        {
            if (_singleThread)
                Locker.Release();
        }

        private static bool scanListLimit;
        public static bool ScanListLimit { set { scanListLimit = value; } }
        public bool VerifyDoublon { set { verifyDoublon = value; } get { return verifyDoublon; } }

        private IITUserPlaylist _pl;
        public IITUserPlaylist ItPlayList { get { return _pl; } }

        private static bool _singleThread;
        //  public static bool SingleThread { set { _singleThread = value; } }

        private static bool _gcCollect;

        private bool _abort;
        public static void AbortOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = true;
                //  playLists.Clear();
            }
        }

        public static void StartOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = false;
                //  playLists.Clear();
            }
        }

        private static void addScan(PlayList pl)
        {

            //   log.log("===============>debut scan de {0}", pl);

        }



        private static void removeScan(PlayList pl)
        {

            //   log.log("===============>fin scan de {0}", pl);

        }

        private bool verifyDoublon = true;

        private static List<PlayList> playLists = new List<PlayList>();
        public static PlayList create(string name, CPlayList parent, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, parent, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }


        public static PlayList create(string name, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }

        protected Logger log;
        public Logger Log { get { return log; } }
        private PlayList(string name, CPlayList parent, IITUserPlaylist pl)
            : base(name, parent)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //this.indexScan = dictIndex[path];
        }
        private PlayList(string name, IITUserPlaylist pl)
            : base(name)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //    this.indexScan = dictIndex[path];
        }
        private static BackGroundTaskMgr _backGroundTaskMgr; //  BackGroundTaskMgr BackGroundTaskMgr("PlayList",false);
        private BackGroundTaskMgr _scanBgMgr;
        private BackGroundTaskMgr _addMgr;
        private static BackGroundTaskMgr _addMgrClassement;
        // private Task task;
        private int nbTaskScan;
        public static int NbScan = 3;

        public bool MaxScan { get { return nbTaskScan > NbScan; } }
        //  private int scanPrior;

        public void updatePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.checkScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;
            }
        }

        public void increasePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.increaseScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;

            }
        }

        public BackGroundTaskMgr ScanMgr
        {
            get
            {
                // getScanMgr();
                return _scanBgMgr;
            }
        }

        private void getScanMgr()
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {

                if (_scanBgMgr == null)
                {
                    lock (this)
                    {
                        if (_scanBgMgr == null)
                        {
                            _scanBgMgr = BackGroundTaskMgr.getMgr("scan " + path, 0);
                            _scanBgMgr.makePersistent();
                        }
                    }
                }

            }
        }
        private void loadScanTracks(bool searchDoublon, PlComponent source)
        {
            scanPriority prior = scanPriority.high;
            if (searchDoublon)
                prior = scanPriority.medium;
            increasePriority(prior);

            TaskScan task = TaskScan.create(this, source);
            //if (currentTaskScan == null)
            //{
            //    lock (this)
            //    {
            //        if (currentTaskScan == null)
            //            task = new TaskScan(this);
            //    }
            //}


            if (task == null)
                return;


            if (scanListLimit)
            {
                if (_backGroundTaskMgr == null)
                {
                    lock (this)
                    {
                        if (_backGroundTaskMgr == null)
                            _backGroundTaskMgr = BackGroundTaskMgr.getMgrlarge("PlayList");
                    }
                }
                _backGroundTaskMgr.add(task);
            }
            else
            {
                //if (currentTaskScan == null)
                //{
                //    lock (this)
                //    {
                //        if (currentTaskScan == null)
                //        {
                var th = new ThreadUtil(task.exec, path);
                th.Start();
                //}

                //}
                //}
            }




            //    return;
            //scanLaunched = true; 
            //_backGroundTaskMgr.add(new Task(this)); // new Thread(_scan).Start();
        }

#if V
       private BgDict<string, TrackInList> dict = new BgDict<string, TrackInList>();
#endif

        //private BackGroundTaskMgr _classement;
        //private BackGroundTaskMgr _trackList;
        //private void checkBgMgrFriends()
        //{
        //    if (_classement == null)
        //        _classement = BackGroundTaskMgr.FindMgr("Classement");
        //    if (_trackList == null)
        //        _trackList = BackGroundTaskMgr.FindMgr("TrackList " + path);

        //}
        //private TaskScan currentTaskScan = null;
        private void _scan(TaskScan task)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                //if (!_scanBgMgr.IsEnd)
                //{
                //    lock (this)
                //    {
                //        if (!_scanBgMgr.IsEnd)
                //        {
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN");
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            return;
                //        }
                //    }

                //}

            }


            //lock (this)
            //{
            //    if (currentTaskScan != null)
            //    {
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN LOCK");
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        return;
            //    }
            //    currentTaskScan = task;
            //}



            addScan(this);


            try
            {
                BgDictString<IITTrack> dict = new BgDictString<IITTrack>();
                int count = 0;
                try
                {
                    enter();
                    count = _pl.Tracks.Count;
                }
                finally
                {
                    release();
                }
                var i = dictIndex[path];
                if (i >= count - 1)
                    i = 0;
                i -= 100;
                if (i < 0)
                    i = 0;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan:{0} index:{1} / {2}", path, i, count);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");


                int logNb = 0;
                if (i == 0)
                {
                    nbTaskScan++;
                    logNb = TaskScan.logScan(task);
                }

                var sourceScan = task.source;
                int indexSource = IndexOf(sourceScan);
                string fileSource = sourceScan.Location;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan: nbLog:{0} {1} index:{2} / {3} cause:i={4} {5} ", logNb, path, i, count,
                    indexSource, fileSource);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                if (nbTaskScan > 1)
                {
                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                    log.log("{0} NB SCAN {1}/{2}", this, nbTaskScan, NbScan);

                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                }

                if (MaxScan)
                {
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    log.log("{0} MAX SCAN {1}", this, nbTaskScan);
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                }



                if (BackGroundTaskMgr.Ordonnancement)
                {
                    while (true)
                    {
                        Scan scanItem = new Scan(this, dict, i);
                        _scanBgMgr.add(scanItem);
                        i++;
                        if (i >= count)
                        {
                            //count = _pl.Tracks.Count;
                            //if (count > i)
                            //{
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //    log.log("modification count {0} index:{1} / {2}", path, i, count);
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //}
                            //  if (i >= count)
                            break;
                        }
                    }

                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    log.log("attente fin scan {0} index:{1} / {2}", path, i, count);
                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");



                }
                else
                {

                    #region old
                    // for (int i = 1; i <= count; i++)
                    // {

                    //foreach (IITTrack t in _pl.Tracks)

                    for (int ii = i; ii < count; i++)

                    //var enumerator = _pl.Tracks.GetEnumerator();
                    //while (enumerator.MoveNext())
                    {
                        var _track = TrackWrapper.create(_pl.Tracks[ii + 1]); // as IITFileOrCDTrack;// enumerator.Current as IITFileOrCDTrack;

                        // IITTrack t = _pl.Tracks[i];
                        if (_track == null)
                            continue;
                        if (task.Abort) // || _abortScan)
                        {
                            log.log("tache abandonnée {0}", this);
                            return;
                        }
                        try
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Enter();
                            if (task.Abort) // || _abortScan)
                            {
                                log.log("tache abandonnée {0}", this);
                                return;
                            }
                            //if (t.Kind  == ITTrackKind.ITTrackKindFile)
                            //{
                            //IITFileOrCDTrack _track = t as IITFileOrCDTrack;
                            //if (t == null)
                            //    continue;

                            //  checkBgMgrFriends();

                            //if (BackGroundTaskMgr.Ordonnancement)
                            //{
                            //    Scan scanItem = new Scan(this, dict, i);
                            //    _scanBgMgr.add(scanItem);
                            //}
                            //else
                            //{

#if V
                    TrackInList track =  dict[_track.Location];

#else
                            if (string.IsNullOrEmpty(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste sans localisation ", this);
                                _track.Delete();
                                continue;
                            }

                            if (!FileRegister.Exist(_track.Location)) //   conf.CheckFileExist && !File.Exists(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste absent du système de fichier", this);
                                _track.Delete();
                                continue;
                            }

                            if (verifyDoublon)
                            {
                                if (dict.ContainsKey(_track.Location))
                                {
                                    log.log("{0} {1}===============>suppression du track de liste en doublon ", this, _track.Location);
                                    _track.Delete();
                                    continue;
                                }
                                dict.Add(_track.Location, _track);
                            }
                            BgTask.chrono.bip("oldscan");
                            loader.recordTrackList(getPath(), _track, _track.TrackDatabaseID, _track.Location, true);

                            TrackInList track = loader.getTrackInList(getPath(), _track.Location);
#endif
                            if (track == null)
                            {
                                //TODO vérifier
                                //log.log("ajout exceptionnel du track {0} à la liste {1}", _track.Location, this);
                                //TrackInfoItunes piece = new TrackInfoItunes(_track);
                                //track = new TrackInList(piece, _track);
                                //add(track);
                                //addPiece(piece);



                            }
                            else
                            {
#if V

#else

#endif

                                track.setTrack(_track);
                            }

                            //}
                            //  }
                        }
                        catch (Exception e)
                        {
                            log.log(e.ToString());
                        }
                        finally
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Release();
                        }
                    }

                    #endregion


                }

                if (BackGroundTaskMgr.Ordonnancement)
                {
                    if (_scanBgMgr.Stopped)
                    {
                        log.log("{0} stoppé après la fin de l'empilage, bizarre...", this);
                        _scanBgMgr.start();
                    }
                    while (true)
                    {
                        while (i < count)
                        {
                            i++;
                            Scan scanItem = new Scan(this, dict, i);
                            _scanBgMgr.add(scanItem);
                        }
                        Thread.Sleep(30);
                        if (!_scanBgMgr.IsEnd)
                            continue;
                        int count0 = count;
                        try
                        {
                            enter(); count = _pl.Tracks.Count;
                        }
                        finally { release(); }
                        if (count > count0)
                        {
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            log.log("modification 2 count {0} index:{1} / {2}", path, i, count);
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                        }
                        else
                            break;
                    }



                }

            }

            catch (Exception e)
            {
                log.log(e.ToString());
            }

            finally
            {
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                log.log("fin tâche scan:{0}", path);
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                //lock (this)
                //{
                //    TaskScan.remove(task); // currentTaskScan = null;
                //}
                removeScan(this);
            }


        }

        class Scan : BgTaskBase
        {
            private PlayList pl;
            //  private IITFileOrCDTrack _track;
            private BgDictString<IITTrack> dict;
            private string path;
            private int index;

            public Scan(PlayList pl, BgDictString<IITTrack> dict, int index)
                : base("i=" + index.ToString())
            {
                //    this._track = _track;
                this.pl = pl;
                this.dict = dict;
                this.path = pl.getPath();
                this.index = index;
            }

            public override void exec()
            {
                success = true;
                try
                {
                    pl.enter();
                    var _track = TrackWrapper.create(pl._pl.Tracks[index + 1]);
                    if (_track == null)
                        return;
                    string location = _track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        pl.log.log("{0} ===============>suppression du track de liste sans localisation ", path);
                        pl.increasePriority(scanPriority.medium);

                        _track.Delete();
                        return;
                    }

                    //this.Desc = _track.Location; 
                    if (pl.verifyDoublon)
                    {
                        if (dict.ContainsKey(location))
                        {
                            pl.log.log("{0} {1} ===============>suppression du track de liste en doublon ", path, location);
                            pl.increasePriority(scanPriority.medium);
                            _track.Delete();
                            return;
                        }
                        dict.Add(location, _track);
                    }
                    BgTask.chrono.bip("spl:t");
                    PlayList.loader.recordTrackList(path, _track, _track.TrackDatabaseID, location, true);

                    TrackInList track = PlayList.loader.getTrackInList(path, location);
                    PlayList.dictIndex[path] = index;

                    if (track == null)
                    {
                        //track = pl.getPieceInList(new FileImpl(location)) as TrackInList;
                        //if (track == null)
                        //{
                        //success = false;  // bonne idée mais au rejeu on supprimme un faux doublon
                        return;
                        //}

                        //PlayList.loader.recordTrackInList(pl, track, false);
                    }

                    BgTask.chrono.bip("spl:t2");
                    track.setTrack(_track);


                }
                catch (Exception e)
                { pl.log.log("NIET " + e.Message); }




                finally
                {
                    pl.release();
                    //bool highPriority = false;
                    //if (pl._trackList != null && pl._trackList.Contains(path))
                    //    highPriority = true;
                    //else if (pl._classement != null && pl._classement.Contains(path))
                    //    highPriority = true;

                    //pl.checkPriority(highPriority);
                }
            }
        }



        private class FileImpl : IFile
        {
            private string location;
            private int id; 

            public FileImpl(string location, int id)
            {
                this.location = Location;
                this.id = id; 
            }

            #region IFile Members

            public string Location
            {
                get { return location; }
            }

            public int PieceId { get { return id; } }

            public override bool Equals(object obj)
            {
                var o = obj as IFile;
                if (o == null)
                    return false;
                return location.Equals(o.Location);

            }

            public override int GetHashCode()
            {
                return location.GetHashCode();
            }

            public override string ToString()
            {
                return location;
            }

            #endregion
        }
        //public override bool Contains(string location)
        //{
        //    bool ret =  base.Contains(location);
        //    if (!ret)
        //        return ret;
        //    return loader.LogicalContainsTrackInList(path, location); 
        //}

        public bool LogicalContainsTrackInList(string location)
        {
            return loader.LogicalContainsTrackInList(path, location);
        }

        public bool LogicalTrackInListDeleted(TrackInList track)
        {
            return loader.LogicalTrackInListDeleted(path, track.Location);
        }

        public void removeTrack(TrackInList track)
        {
            // if (!Contains(track.Location))
            loader.removeTrackInList(path, track, _pl);
            loader.LogicalRemoveTrackInList(path, track);
        }


        public void invalidationTrack(TrackInList track)
        {
            loader.invalidationTrackInList(path, track, _pl);
        }

        //public void locateNextTrack(TrackInList current, IFile nextLocation)
        //{
        //    if (current == null)
        //        return; 
        //    int count = Count;

        //    current.locate();
        //    loader.CurrentTrackInList = current;

        //    var next = getPieceInList(nextLocation) as TrackInList; 

        //    if (next != null)
        //    {
        //        next.locate();
        //        loader.NextTrack = next; 
        //    }
        //}

        public void recordNextTracks(List<IFile> nextLocation)
        {

            var list = new List<TrackInList>();

            foreach (IFile file in nextLocation)
            {
                var track = getPieceInList(file) as TrackInList;
                if (track == null)
                    continue;
                if (!track.Enabled)
                    continue;
                list.Add(track);
            }

            loader.NextTracks = list;
        }


        public void findTrack(TrackInList track)
        {

            string location = track.Location;
            var memo = loader.getMemoTrackList(path, _pl, location);
            if (memo != null && memo.Track != null)
            {
                track.setTrack(memo.Track);
                return;
            }

            #region complique
            bool _ok = false;
            if (conf.ComplexSearch)
            {
                //  loadScanTracks(false);




                int index = IndexOf(track);
                IITFileOrCDTrack _track1 = null;
                IITFileOrCDTrack _track2 = null;
                if (index >= 0)
                {
                    try
                    {
                        BgTask.chrono.bip("plf:0");
                        enter();
                        _track1 = TrackWrapper.create(_pl.Tracks[index + 1]); // as IITFileOrCDTrack;
                    }
                    finally
                    {
                        release();
                    }
                    BgTask.chrono.bip("plf:1");
                    //if (_track == null)
                    try
                    {
                        enter();
                        _track2 = TrackWrapper.create(_pl.Tracks.ItemByPlayOrder[index + 1]); // as IITFileOrCDTrack;
                        BgTask.chrono.bip("plf:2");
                    }
                    finally { release(); }

                }
                //if (_track1 == null || _track2 == null)
                //{
                //    // nbErr++;
                //    loadScanTracks(false, track);
                //    return;
                //}

                string location1 = null;
                string location2 = null;

                //TrackPersistantId id1 = null;
                //TrackPersistantId id2 = null;


                try
                {
                    enter();
                    if (_track1 != null)
                    {
                        location1 = _track1.Location;
                        if (!string.IsNullOrEmpty(location1) && (FileRegister.Exist(location1))) //  conf.CheckFileExist || File.Exists(location1)))
                        {
                            _ok = true;
                            if (location1 != location)
                                loader.recordTrackList(path, _track1, _track1.TrackDatabaseID, location1, true);
                        }
                    }
                    if (_track2 != null)
                    {

                        location2 = _track2.Location;
                        if (!string.IsNullOrEmpty(location2) && (FileRegister.Exist(location2)))
                        {
                            _ok = true;
                            if (location2 != location)
                                loader.recordTrackList(path, _track2, _track2.TrackDatabaseID, location2, true);
                        }
                    }

                    if (!_ok)
                    {
                        loadScanTracks(false, track);
                        return;
                    }


                }
                catch (Exception ex)
                {
                    log.log("findTrack::", ex);
                    //nbErr++;
                    loadScanTracks(false, track);
                    return;
                }
                finally { release(); }

#if V
                            TrackInList track2 = dict[location];
#else
                _ok = false;
                TrackInList track21 = loader.getTrackInList(path, location1);
                TrackInList track22 = loader.getTrackInList(path, location2);
#endif


                if (track21 == track)
                {
                    _ok = true;
                    track21.setTrack(_track1);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }

                if (track22 == track)
                {
                    _ok = true;
                    track22.setTrack(_track2);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }
            }

            #endregion

            if (!_ok)
                loadScanTracks(false, track);



        }

        private class mergeListWithOrderTask
        {
            private PlayList playlist;
            private ICollection<IFile> newElements_;
            private IAbortTask writer;
            private IBgTask task;
            private Logger log;
            public mergeListWithOrderTask(PlayList playlist, ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
            {
                this.playlist = playlist;
                this.newElements_ = newElements_;
                this.writer = writer;
                this.task = task;
                log = playlist.log;
            }

            public void launch()
            {
                new Thread(go).Start();
            }

            private void go()
            {
                var newElements = new List<IFile>(newElements_);

                playlist.verifyDoublon = false;

                IITFileOrCDTrack currentPlaying = null;
                string currentAlbum = "----";

                try
                {
                    lock (playlist)
                    {


                        try
                        {
                            if (loader.CurrentPlaylist == playlist)
                            {
                                if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                                {
                                    currentPlaying = loader.CurrentTrack;
                                    if (currentPlaying != null)
                                        //  currentIndex = currentPlaying.Index;
                                        currentAlbum = currentPlaying.Album;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible de déterminer la liste courant", ex);
                        }
                    }


                    // 1. suppression
                    //List<TrackInList> toDelete = new List<TrackInList>();
                    //List<IFile> toAdd = new List<IFile>();



                    //123475
                    //15634


                    // phase 1 
                    int iNew = 0;
                    int iThis = 0;

                    int newCount = newElements.Count;
                    //int thisCount = this.LeafsCount;

                    DateTime debut = DateTime.Now;
                    log.log("debut calcul liste triée " + this);


                    while (true)
                    {
                        if (writer.Aborted || task.Abort || playlist._abort) return;
                        TrackInList currentList = null;
                        if (iThis >= newCount)
                        {
                            currentList = playlist[iThis] as TrackInList;
                            while (currentList != null)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                if (currentAlbum != currentList.Piece.Album)
                                    currentList.Delete();
                                iThis++;
                                currentList = playlist[iThis] as TrackInList;
                            }

                            break;
                        }



                        IFile newCurrent = null;

                        try
                        {
                            newCurrent = newElements[iNew];
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible d'accéder à l'item " + iNew + " " + ex.ToString());
                            break;

                        }



                        var toDelete = new List<IBgTask>();
                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            if (iThis >= playlist.LeafsCount)
                                currentList = null;
                            else
                            {
                                currentList = playlist[iThis] as TrackInList; // _pl.Tracks[iThis + 1] as IITFileOrCDTrack;
                            }

                            if (currentList == null)
                                break;
                            // currentListLocation = currentList.Location;
                            if (newCurrent.Location.Equals(currentList.Location))
                            {
                                break;
                            }

                            var _task = currentList.delete();
                            toDelete.Add(_task);


                            iThis++;

                        }

                        if (toDelete.Count > 0)
                            log.log("{0} {1} elt to delete", this, toDelete.Count);



                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var found = toDelete.Find(t => !t.Success);
                            if (found == null)
                                break;
                            Thread.Sleep(30);
                        }



                        if (currentList == null)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var taskAdd = playlist.Add(newCurrent.Location, string.Format("{0}/{1}", iNew, playlist.LeafsCount), true);

                            while (!taskAdd.Success)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                Thread.Sleep(30);
                            }



                        }
                        else
                        {

                            if (currentAlbum != currentList.Piece.Album && !currentList.Location.Equals(newCurrent.Location))
                                throw new ApplicationException();
                        }

                        iNew++;
                        iThis = iNew;




                    }


                    log.log("fin de lancement liste triée " + (int)((DateTime.Now - debut).TotalMilliseconds) + " ms " + this);


                }

                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                //finally
                //{
                //    try
                //    {
                //        bool _break = false;
                //        if (currentPlaying != null)
                //        {

                //            var newCurrent = loader.CurrentTrack;
                //            string location = null;
                //            try
                //            {
                //                location = currentPlaying.Location;
                //                if (location == newCurrent.Location)
                //                    _break = true;
                //            }
                //            catch
                //            {
                //                log.log("track en lecture avant le merge doit etre suprimmé");
                //            }

                //            if (!_break)
                //            {
                //                log.log("retour à l'index " + currentIndex);
                //                var tr = playlist._pl.Tracks.ItemByPlayOrder[currentIndex];
                //                if (tr != null)
                //                {
                //                    tr.Play();
                //                }
                //            }


                //        }
                //    }
                //    catch (Exception ex)
                //    {
                //        log.log(ex.ToString());
                //    }

                //}

            }
        }


        public void mergeListWithOrder(ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
        {
            new mergeListWithOrderTask(this, newElements_, writer, task).launch();
        }




        public bool mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {

            if (writer.Aborted || _abort) return true;
            verifyDoublon = true;

            // log.log("mergeList"); 

            string currentAlbum = "----";



            lock (this)
            {


                try
                {
                    if (loader.CurrentPlaylist == this)
                    {
                        if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                        {
                            var currentPlaying = loader.CurrentTrack;
                            if (currentPlaying != null)
                                currentAlbum = currentPlaying.Album;
                        }
                    }
                }
                catch (Exception ex)
                {
                    log.log("impossible de déterminer la liste courant", ex);
                }
            }

            //    log.log("mergeList::begin"); 

            List<TrackInList> toDelete = new List<TrackInList>();

            var newElements = new List<IFile>(newElements_);

            BgDictString<IFile> newElt = new BgDictString<IFile>();
            foreach (IFile elt in newElements_)
            {
                newElt[elt.Location] = elt;
            }
            //   log.log("mergeList::fin hashtable"); 
            foreach (TrackInList pl in this)
            {
                if (newElt[pl.Location] == null)
                {
                    if ((!conf.AutoPlay || loader.CurrentPlaylist != this) || (conf.DeleteCurrentAlbum || pl.Piece.Album != currentAlbum))
                        toDelete.Add(pl);
                    pl.FirstClass = true; 
                }
            }
            // log.log("mergeList::fin determination toDelete"); 
            //foreach (TrackInList pl in this)
            //{
            //    IFile elt = newElements.Find(t => t.Location == pl.Location);
            //    if (elt == null)
            //        toDelete.Add(pl);
            //}


            //Addition
            List<IFile> toAdd = new List<IFile>();
            foreach (IFile elt in newElements)
            {
                if (writer.Aborted || _abort) return true;
                string location = elt.Location;
                //   bool founded = false;

#if V
             PieceInAList found = dict[location]; 
#else
                PieceInAList found = loader.getTrackInList(path, location);
#endif

                if (found == null)
                    toAdd.Add(elt);
                //foreach (PieceInAList pl in this)
                //{
                //    if (pl.Location == location)
                //    {
                //        founded = true;
                //        break;
                //    }
                //}

                //if (!founded)
                //    toAdd.Add(elt);
            }
            //  log.log("mergeList::fin determination toAdd");

            if (toAdd.Count > 0)
                log.log("{0} {1} elt to add", this, toAdd.Count);

            if (toDelete.Count > 0)
                log.log("{0} {1} elt to delete", this, toDelete.Count);




            int count = toAdd.Count;
            for (int i = 0; i < count; i++)

            //foreach (IFile track in toAdd)
            {
                if (writer.Aborted || _abort) return true;
                var e = toAdd[i]; 
                Add(e.Location, string.Format("{0}{1}/{2}",e, i + 1, toAdd.Count), true);

            }

            foreach (TrackInList pl in toDelete)
            {
                if (writer.Aborted || _abort) return true;
                pl.Delete();
            }



            //  log.log("mergeList::fin determination toAdd");
            return true;



        }


        private class AddTrack : BgTaskBase
        {
            private string location;
            //   private string desc;
            private Loader loader;
            private PlayList playlist;
            public AddTrack(string location, string desc, Loader loader, PlayList playlist)
                : base(desc)
            {
                //    this.desc = playlist.path + " "+ location + " " + desc;
                this.loader = loader;
                this.location = location;
                this.playlist = playlist;
            }
            public override void exec()
            {

                if (_abort) return;
                if (playlist.verifyDoublon)
                {

                    if (playlist.Contains(location))
                    {
                        playlist.log.log("vérif 1 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v1");

                    if (playlist.LogicalContainsTrackInList(location))
                    {
                        playlist.log.log("vérif 2 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v2");


#if V
           //  PieceInAList found = dict[location]; 
#else

                    var found = loader.getTrackInList(playlist.path, location);
#endif

                    if (found != null)
                    {
                        playlist.log.log("vérif 3 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }

                    chrono.bip("v3");

                    var memo = loader.getMemoTrackList(playlist.path, playlist._pl, location);
                    chrono.bip("vm");
                    if (memo != null)
                    {
                        int TrackDatabaseID = -1;
                        string _test = null;
                        try
                        {
                            _test = memo.Track.Location;
                            TrackDatabaseID = memo.Track.TrackDatabaseID;
                        }

                        catch
                        {
                        }
                        if (location == _test)
                        {
                            playlist.log.log("{0} vérif persist :  track déjà ajouté", Desc);
                            success = true;
                            return;
                        }
                        else
                        {
                            loader.removeTrackInList(playlist.path, location, TrackDatabaseID, playlist._pl);
                        }
                        chrono.bip("vm2");
                    }

                }


                IITFileOrCDTrack newTrack = null;
                var sourceTrack = loader.getAnyTrackByLocation(location);

                chrono.bip("fts");

                if (sourceTrack != null)
                {
                    try
                    {

                        if (_abort) return;
                        var st = sourceTrack.Track;
                        if (st is TrackWrapper)
                        {
                            st = (st as TrackWrapper).InnerTrack;
                        }
                        playlist.enter();
                        newTrack = TrackWrapper.create(playlist._pl.AddTrack(st));
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par track {1}", Desc, ex.ToString());
                        loader.invalidationLocation(location);
                    }

                    finally
                    {
                        playlist.release();
                        chrono.bip("Add");

                    }
                }

                if (newTrack == null)
                {
                    try
                    {
                        success = false;
                        if (!conf.PlayListAddFile)
                            return;


                        if (_abort) return;
                        IITOperationStatus status = null;
                        try
                        {
                            playlist.enter();
                            status = playlist._pl.AddFile(location);
                        }

                        finally
                        {
                            playlist.release();
                        }

                        if (status == null)
                        {
                            playlist.log.log("impossible d'ajouter le track par fichier " + location);
                            success = false;
                            return;


                        }
                        while (status.InProgress)
                            Thread.Sleep(30);
                        try { playlist.enter(); newTrack = TrackWrapper.create(status.Tracks[1]); }
                        finally { playlist.release(); } // as IITFileOrCDTrack;
                        playlist.log.log("{0} track ajouté par fichier ", Desc);
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par fichier {1}", Desc, ex.ToString());
                        success = false;
                        return;

                    }

                    finally
                    {
                        chrono.bip("Add2");
                    }


                }


                if (_abort)
                {
                    success = true;
                    return;
                }


                chrono.bip("Add:?");
                var newTrackTrackDatabaseID = newTrack.TrackDatabaseID;
                loader.recordTrackList(playlist.path, newTrack, newTrackTrackDatabaseID, location, true);
                chrono.bip("f1");
                TrackInfoItunes piece = loader.getInfo(newTrackTrackDatabaseID);
                piece.FirstClass = true ; 
                chrono.bip("f2");
                TrackInList plPiece = new TrackInList(playlist, piece, newTrackTrackDatabaseID);
                chrono.bip("f3");
                loader.LogicalRecordTrackInList(playlist.path, plPiece);


                // new TrackInfoItunes(newTrack);
                //TrackInList t = new TrackInList(  (this, ti, newTrack.TrackDatabaseID);
                plPiece.setTrack(newTrack);
                //if (verifyDoublon)
                playlist.add(plPiece);
               //playlist.addPiece(piece);

                success = true;

            }



        }
        private bool? isClass;
        private int priority = int.MaxValue;
        public void setPrior(int p) { priority = p; }
        public int Prior { get { return priority; } }
        // public bool? IsClass { set { isClass = value; } } 
        public override bool isClassSubList()
        {
            if (isClass != null)
                return isClass.Value;

            isClass = base.isClassSubList();
            return isClass.Value;
        }

        public IBgTask Add(string location, string desc, bool async)
        {


            var task = new AddTrack(location, desc, loader, this);
            if (!async)
            {
                task.exec();
                return task;
            }


            if (BackGroundTaskMgr.Ordonnancement)
            {
                if (!isClassSubList())
                {
                    if (_addMgr == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgr == null)
                            {
                                _addMgr = BackGroundTaskMgr.getMgr("AddTrack " + path, 0);


                            }
                        }
                    }

                    BackGroundTaskMgr.increaseScanPriority(_addMgr, priority);
                    _addMgr.add(task);
                    return task;
                }
                else
                {
                    if (_addMgrClassement == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgrClassement == null)
                            {
                                _addMgrClassement = BackGroundTaskMgr.getMgr("Classement", 0);
                            }
                        }
                    }
                    _addMgrClassement.addAtFirst(task);
                    return task;
                }
            }
            else
            {
                task.exec();
            }

            return task;

        }


        public override bool add(PlComponent component)
        {

            //if (Name == "g1")
            //{
            //    int toto = 0;
            //    foreach (IITFileOrCDTrack t in _pl.Tracks)
            //    {
            //        log.log(t.Index + " " + t.Location+ " " + t.BookmarkTime + " " +  t.Start + " "+ t.Time ); 
            //    }
            //    log.log(_pl.Tracks.
            //}
            TrackInList found = null;
            if (verifyDoublon)
            {
                found = loader.getTrackInList(path, component.Location);
                if (found != null)
                {
                    log.log("track déjà ajouté {0} {1}", this, component.Location);
                    loadScanTracks(true, component);
                }
            }

            bool ret = base.add(component);
            if (!ret)
                return ret;

            TrackInList info = component as TrackInList;
            if (info != null)
            {

                if (found == null)
                    loader.recordTrackInList(path, info, verifyDoublon);

            }



            if (info == null)
                return false;

            //     nb++;

#if V
            dict.Add(info.Location, info); 
          //  dict[info.Location] = info; 
#else



#endif


            return ret;


        }

        public void reintegrate()
        {
            foreach (PlComponent t in this)
            {
                if (t is TrackInList)
                    loader.recordTrackInList(path, t as TrackInList, verifyDoublon);
                else if (t is PlayList)
                    (t as PlayList).reintegrate();
            }


        }



        public override bool remove(PlComponent child)
        {
            //    TrackInList track = child as TrackInList;
            //    if (track != null)
            //        track.Delete(); 

            return base.remove(child);
        }




#if VERIF
        public void verif()
        {
            foreach (TrackInList info in this)
            {
                info.verif(); 
            }
        }
#endif
        //private void scanWithoutLimit()
        //{
        //    try
        //    {
        //        _scan(task);
        //    }

        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }

        //    task = null;

        //}


        private class TaskScan : BgTaskBase
        {
            private static BgDictString<TaskScan> dict = new BgDictString<TaskScan>();
            private static BgDictString<int> logs = new BgDictString<int>();
            private static volatile object _lock = new object();

            public readonly PlComponent source;
            public static TaskScan create(PlayList playlist, PlComponent source)
            {
                string key = playlist.path;
                if (dict.ContainsKey(key))
                    return null;
                TaskScan task = null;
                lock (_lock)
                {
                    if (dict.ContainsKey(key))
                        return null;
                    task = new TaskScan(playlist, source);
                    dict.Add(key, task);
                    logs[key]++;

                }

                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                playlist.log.log("creation tâche scan:{0}", key);
                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                return task;
            }

            public static int logScan(TaskScan task)
            {
                return logs[task.playlist.path];
            }

            private static void remove(TaskScan task)
            {
                dict.Remove(task.playlist.path);
            }


            private TaskScan(PlayList playlist, PlComponent source)
                : base(playlist.path)
            {
                this.playlist = playlist;
                this.source = source;
            }
            private PlayList playlist;
            public override void exec()
            {
                try
                {
                    //if (dict.ContainsKey(playlist.path))
                    //    return;
                    //lock (_lock)
                    //{
                    //    if (dict.ContainsKey(playlist.path))
                    //        return;
                    //    dict.Add(playlist.path, this); 
                    //}
                    playlist._scan(this);

                }
                catch (Exception e)
                {
                    playlist.log.log(e.ToString());

                }

                finally
                {
                    success = true;
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    playlist.log.log("remove tâche scan:{0}", playlist);
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    lock (_lock)
                        dict.Remove(playlist.path);
                }

            }

        }

        public override string ToString()
        {
            return base.ToString() + " " + verifyDoublon;
        }







    }


}
]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        private static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

     //   private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        private static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = -1;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.playedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;

            Fill();
        }

        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            string key = "";
            bool nextIgnore = false;
            rating = 0;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value; break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": playedDate = Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }
                //if (Name.Contains("Les cartes de la mémoire"))
                //{
                //    int toto = 0;
                //}
            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return tracktrack;
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;

                bgClass.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }


        protected string album = "";
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                bgClass.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    album = value;
                }, this,
                "change album from '{0}' to'{1}' {2}", album, value, this
                ));

            }
        }
        protected string name = "";
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgClass.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return; 
                }
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        protected DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                //if (playCount > 0)
                    return playedDate;
               // return DateTime.MinValue;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (!present)
            {
                grouping = value;
                return; 
            }
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return; 
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        //public List<CPlayList> PLayLists
        //{
        //    get { return listManager.PLayLists; }
        //}

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return listManager.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    listManager.AddPlayList(a_playList);
        //    // className = listManager.ClassName;
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    listManager.removePlayList(list);
        //    // className = listManager.ClassName;
        //}


        public string ClassName
        {
            get
            {
                throw new NotImplementedException(); 
                //className = listManager.ClassName;
                //return className;
            }
            set
            {
                throw new NotImplementedException(); 
                //className = listManager.ClassName;
                //if (className != value)
                //{
                //    bgClass.add(new Bgtask(() =>
                //    {
                //        loader.setClassPlayList(this, className, value);
                //        className = value;
                //    }, this,
                //   "change className from '{0}' to'{1}' {2}", className, value, this));


                //    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                //    //className = value;
                //    //OnClassNameChange(value);
                //}
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }

        public void Delete()
        {
            if (tracktrack != null)
                tracktrack.Delete();
            else
                bgClass.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        private class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion

    }
}



]]></content>
  </file>
  <file path="\PieceDb.obj\CPlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
namespace pdb.obj
{
    public interface IComponentFactor
    {
        PlComponent create(object source); 
    }

    public interface IPlayList
    {
        void DeleteChilds();
        void addObj(object source);
        IPlayList getOrCreate(string name); 
    }

   

    public class CPlayList : PlayListComposite, IPlayList
    {
        private static CPlayList dummy = new CPlayList("DUMMY"); 
     //   private IList<ITrackPlayListRecorder> m_list = new List<ITrackPlayListRecorder>();
        public const string CLASSEMENT = "classement";
        protected IComponentFactor creator = new DefautComponentCreator();


        public CPlayList(string name)
            : base(name)
        {
        }
        public CPlayList(string name, CPlayList parent)
            : this(name)
        {
            if (parent != null)
                parent.add(this);
        }
        
        public CPlayList(string a_name, CPlayList a_parent, IComponentFactor creator)
            :this(a_name,a_parent)
        {
            this.creator = creator; 
           
        }

        public override string Location
        {
            get { return getPath(); }
        }

        ///// <summary>
        ///// juste pour compatibilité arrière
        ///// </summary>
        ///// <param name="a_name"></param>
        ///// <param name="id"></param>
        ///// <param name="a_parent"></param>
        //public CPlayList(string a_name, String id, CPlayList a_parent) : this(a_name, a_parent) { }


        //// <summary>
        //// pour éviter la navigation dans l'arbre
        //// </summary>
        //// <param name="a_piece"></param>
        ////public void addPiece(ITrackPlayListRecorder a_piece)
        ////{
        ////    m_list.Add(a_piece);
        ////    a_piece.AddPlayList(this);
        ////}

        public override void DeleteChilds()
        {
            //foreach (ITrackPlayListRecorder plItem in new List<ITrackPlayListRecorder>(m_list))
            //{
            //    m_list.Remove(plItem);
            //    plItem.removePlayList(this);
            //}
            base.DeleteChilds();
        }

        //public override void add(PlComponent component)
        //{
        //    base.add(component);
        //    if (component is ITrackPlayListRecorder)
        //    {
        //        addPiece(component as ITrackPlayListRecorder); 
        //    }
        //}

        public PieceInAList getPieceInList(IFile a_piece)
        {
            if (a_piece == null)
                return null;
            foreach (PieceInAList track in this)
            {
                if (track.Location.Equals(a_piece.Location))
                    return track;
            }
            return null;
        }

        public PieceInAList getPieceInList(string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            foreach (PieceInAList track in this)
            {
                if (track.Location.Equals(location))
                    return track;
            }
            return null;
        }


        //public void remove(ITrackPlayListRecorder piece)
        //{
        //    m_list.Remove(piece);
        //    piece.removePlayList(this);
        //}

        //public int Count
        //{
        //    get { return m_list.Count; }
        //}

        public virtual bool isClassSubList()
        {
            return isSubList(CLASSEMENT);
        }

        public override bool remove(PlComponent child)
        {
            return base.remove(child);
        }

        public CPlayList getOrCreate(string name)
        {
            var sub = base.getComposite(name) as CPlayList;
            if (sub == null)
            {
                sub = new CPlayList(name, this,creator); 
            }
            return sub; 
        }


        public CPlayList get(string name)
        {
            var sub = base.getComposite(name) as CPlayList;
            if (sub == null)
                sub = dummy; 
            return sub;
        }




        protected override PlComponent create(object o)
        {
            return creator.create(o); 
        }




        void IPlayList.DeleteChilds()
        {
            DeleteChilds(); 
        }

        void IPlayList.addObj(object source)
        {
            addObj(source); 
        }

        IPlayList IPlayList.getOrCreate(string name)
        {
            return getOrCreate(name); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\ILoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{
    public interface ILoader
    {

       // /// <summary>
       // /// Ajout d'une playlist à partir dune liste de fichiers
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // /// <param name="list"></param>
       // void addList(PlayListComposite folder, String name, ICollection<IFile> list);
        /// <summary>
        /// création d'une piste native
        /// </summary>
        /// <param name="piece"></param>
      //  ITrackInfoItunes createLegacyTrack(ITrackNative piece);
       // /// <summary>
       // /// Chemin du fichier de base de données
       // /// </summary>
       // string DbPath { get; }
       // /// <summary>
        /// réépertoire principal où est stockée la musique
        /// </summary>
        string DefaultFolder { get; }
       // /// <summary>
       // /// Suppression d'une piste de PlayList ( sans suppression de la base ) 
       // /// </summary>
       // /// <param name="trackList"></param>
       //// void deleteTrackInList(PieceInAList trackList);
       // /// <summary>
       // /// Récupération de la playlist associée à la playlist native
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // /// <returns></returns>
       // CPlayList getList(PlayListComposite folder, string name);
       // /// <summary>
       // /// récupération ou création du dossier de playlists
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <returns></returns>
       // PlayListComposite getOrCreateFolder(string folder);
       // /// <summary>
       // /// Liste des pistes
       // /// </summary>
       // IEnumerable<ITrackInfoItunes> ListTracks { get; }
        /// <summary>
        /// Chargement des listes
        /// </summary>
        void loadLists();
        /// <summary>
        /// Chargement des pises
        /// </summary>
        void loadTracks(List<ITrackInfoItunes> list);

       // PlayListComposite TreePlayList { get; }

       // /// <summary>
       // /// Suppression dune liste native
       // /// </summary>
       // /// <param name="folder"></param>
       // /// <param name="name"></param>
       // void removeList(PlayListComposite folder, string name);
        /// <summary>
        /// placement d'une piste en rapport avec son classement
        /// </summary>
        /// <param name="piece"></param>
        /// <param name="listName"></param>
        void setClassPlayList(ITrackMetaData piece, string listName);

        void deleteTrack(String location);

        ITrackInfoItunes createTrack(int id,String location);

        void checkDetect(DateTime ini); 

    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        int PieceId { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
        String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        TimeSpan Duration { get; set; }
        string ArtWork { get; set; }
        string Grouping { get; }
        void setGrouping(string value,bool prior);
        bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif 
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    public interface ITrackPlayedDates
    {
        List<DateTime> Dates { get; }
        List<DateTime> DatesClassement { get; }
        List<DateTime> DatesClassementBrut { get; }
        String ClassEvol { get; }
    }

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    public interface ITrackNative : ITrackMetaData//, ITrackPlayListReport
    {
        String ClassName { get; set; }

      //  void registerDependency(ITrackNative local);
     //   void releaseDependency();
    }

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    {
        void setClassement(string className, int rating);
        List<string> RelativesPath { get; }
        exportState ExportStatus { get; set;}
        
    }

    ///// <summary>
    ///// Enregistrement des playlists associées au morceau
    ///// </summary>
    //public interface ITrackPlayListRecorder
    //{
    //    void AddPlayList(CPlayList a_playList);
    //    void removePlayList(CPlayList list);
    //}

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    //public interface ITrackPlayListReport
    //{
    //   // List<CPlayList> PLayLists { get; }
    //    List<CPlayList> ClassPlayLists { get; }
    //}

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    public interface ITrackInfoItunes : ITrackNative
    {


    }

    public class NullTrack : ITrackNative
    {

        #region ITrackNative Members

        public string ClassName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void registerDependency(ITrackNative local) { }
       public void releaseDependency() { }

        #endregion

        #region ITrackMetaData Members

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        public TimeSpan Duration
        {
            get { return new TimeSpan();  }
            set { }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            
        }
            
        public void setGrouping(string value, bool prior) { }


        public int Volume { get { return 0; } set { } }

        #endregion

        #region IFile Members

        public string Location
        {
            get { return ""; }
        }

        #endregion

        #region ITrackReference Members

        public string Artist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Album
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Name
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        #endregion

        #region ITrackPlayListReport Members

        public List<CPlayList> PLayLists
        {
            get { return new List<CPlayList>(); }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return new List<CPlayList>(); }
        }

        #endregion

        public bool FirstClass { get { return false; } set {  } }

        public int PieceId
        {
            get { return -1;  }
        }

        public int PieceParentId
        {
            get { return -1; }
            set { }
        }



        public TrackIdentity Key
        {
            get { return new TrackIdentity(this);  }
        }
    }





}


]]></content>
  </file>
  <file path="\PieceDb.obj\pdb.obj.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.obj</RootNamespace>
    <AssemblyName>pdb.obj</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CPlayList.cs" />
    <Compile Include="CPlayListComparer.cs" />
    <Compile Include="DictRef.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="IBgTask.cs" />
    <Compile Include="ILoader.cs" />
    <Compile Include="Interfaces.cs" />
    <Compile Include="Metadata.cs" />
    <Compile Include="TrackIdentity.cs" />
    <Compile Include="PlComponent.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
</db>
