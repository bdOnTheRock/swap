<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    class StatAlbum
    {
        private string key;
        private int count;

        public void clear()
        {
            count = 0;
        }

        public StatAlbum(string key)
        {
            this.key = key;
        }

        public override bool Equals(object obj)
        {
            if (obj is StatAlbum)
            {
                return key.Equals(((StatAlbum)obj).key);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return key.GetHashCode();
        }

        public int Count { get { return count; } }
        public void record()
        {
            count++;
        }
    }

    class StatAlbums
    {
        private BgDictString0<StatAlbum> dict = new BgDictString0<StatAlbum>();

        public void clear()
        {
            foreach (var stat in dict)
            {
                stat.Value.clear();
            }
        }

        public StatAlbum getStat(Album album)
        {
            var key = album.Key;
            var s = dict[key];
            if (s == null)
            {
                s = new StatAlbum(key);
                dict.Add(key, s);
            }
            return s;
        }
    }


    public enum compressState
    {
        none,
        enCours,
        reload,
        cancel
    }




    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> all;
        protected static Dict<int, PiecePrior> dict;
        protected static Dict<int, PiecePrior> masterDict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();
        protected static Dict<string, string> empreintes = new Dict<string, string>();
        protected static StatAlbums statAlbums = new StatAlbums();

        //  protected static Dictionary<int, object> ids;
        protected static HashSet<int> idCopie;
        protected static HashSet<string> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";
        protected static volatile object _lock = new object();
        protected static Thread thCalcul;
        protected static Thread thCopy;

        protected static bool endCopy;
        protected static bool endCopyFinal;
        protected static compressState copy;
        protected static bool endCalcul;

        protected static compressState query;

        //protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static ILogger logger = Logger.getLogger("export");

        protected static void sendCancel()
        {
            lock (_lock)
            {
                if (query < compressState.cancel)
                    query = compressState.cancel;
            }
        }
        protected static compressState Query
        {
            get
            {
                lock (_lock)
                    return query;
            }
            set
            {
                lock (_lock)
                    query = value;
            }
        }





        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (Query)
            {
                case compressState.none:
                    break;
                case compressState.enCours:
                    //if (checkSthChange())
                    //{
                    //PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.reload;
                    //lock (_lock)
                    //    state = compressState.reload;
                    //}
                    break;
                case compressState.cancel:
                    PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.none;
                    break;
                default:
                    break;
            }
        }

        private static bool checkSthChange()
        {
            bool ret = false;
            foreach (PlayListViewModel pl in playlists)
            {
                var emp = empreintes[pl.Name];
                logger.log("{0} ancienne empreinte {1}", pl.Name, emp);
                var _newEmpre = pl.getEmpreinte();
                logger.log("{0} nouvelle empreinte {1}", pl.Name, _newEmpre);
                if (emp != _newEmpre)
                {
                    logger.log("on recalcule");
                    ret = true;
                }
                empreintes[pl.Name] = _newEmpre;

            }
            return ret;

        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }

            public override bool Equals(object obj)
            {
                var o = obj as PiecePrior;
                if (o == null)
                    return false;
                return PieceGen.PieceId == o.PieceGen.PieceId;
            }

            public override int GetHashCode()
            {
                return PieceGen.PieceId.GetHashCode();
            }

            public CListFile Files { get { return (PieceGen.Track as CPiece).Files; } }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            // public int MasterId { get { return Piece.MasterId; } }
            public int PieceId { get { return PieceGen.PieceId; } }
            public int MasterId { get { return PieceGen.MasterId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
                else if (prior == this.prior1)
                {
                }
                else
                {
                }
            }

            public void setPrior0(int prior)
            {
                if (prior < this.prior0)
                    this.prior0 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                return string.Format("{0} {1} {2}\t {3} {4} {5}", rank, nb, PieceGen.TrackNumber, prior0, prior1, PieceGen.ToString());
                //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (Query <= compressState.none)
                record();
            else
            {
                sendCancel();
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }
        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return x.Index.CompareTo(y.Index);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {

            var list = new List<PiecePrior>();
            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                // var ids = new Dictionary<int, object>();
                int i = 0;
                var tracks = new List<TrackListViewModel>(pl.ExportTracks);
                logger.log("export::buildList {0} {1} elements", pl, tracks.Count);
                if (conf.albumReverse)
                {
                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));

                int lastI = 0;
                Album lastAlbum = null;
                StatAlbum lastStatAlbum = null;
                //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                int limitMax = int.MaxValue;
                if (conf.modeAlbum)
                {
                    nbByAlbum = conf.nbMax;
                    limitMax = conf.limitMax;
                    if (limitMax < nbByAlbum)
                        limitMax = nbByAlbum;
                }
                int nbLot = 0;
                int ii = -1;
                //  var ids = new HashSet<int>();
                while (true)
                {

                    if (query != compressState.enCours)
                        return list;
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        if (query != compressState.enCours)
                            return list;
                        ii++;
                        int id = track.PieceGen.PieceId;

                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            // CPiece piece = track.Piece;
                            if (track.Exists)
                            {
                                var pp = dict[id]; // list.Add(piece);
                                if (pp == null)
                                {
                                    pp = new PiecePrior(track.PieceGen, ii);
                                    dict[id] = pp;
                                }

                                //var masterId = track.MasterId;
                                //if (ids.Add(masterId))
                                //{
                                //    presents.Add(pp);
                                //}



                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        lastStatAlbum = statAlbums.getStat(lastAlbum);
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;

                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }

                                    // pp.setPrior(i);
                                    list.Add(pp);
                                    lastStatAlbum.record();

                                    i++;

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;

                                        limitMax = conf.limitMax;
                                        if (limitMax < nbByAlbum)
                                            limitMax = nbByAlbum;

                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;

                                                limitMax = conf.limitMax;
                                                if (limitMax < nbByAlbum)
                                                    limitMax = nbByAlbum;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            var piece = p.Track as CPiece;
                                            if (piece != null && piece.Exists)
                                            {
                                                if (!onlyEnabled || piece.Enabled)
                                                {
                                                    id = p.PieceId;

                                                    //if (ids.Contains(id))
                                                    //    continue;
                                                    var ppp = dict[id];
                                                    // ppp.setPrior(i);
                                                    list.Add(ppp);
                                                    //   ids.Add(id);
                                                    i++;
                                                    if (piece.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;

                                                            limitMax = conf.limitMax;
                                                            if (limitMax < nbByAlbum)
                                                                limitMax = nbByAlbum;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                            break;
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;

                        limitMax = conf.limitMax;
                        if (limitMax < nbByAlbum)
                            limitMax = nbByAlbum;
                    }
                }
                listes.Add(list);
                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            return list;
        }

        public override string Header
        {
            get
            {
                if (query == compressState.enCours || query == compressState.reload)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (Query == compressState.none)
            {

                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    Query = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear(); empreintes.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                empreintes[pl.Name] = pl.getEmpreinte();
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                //listes = new List<List<PiecePrior>>();
                playlists.Clear(); empreintes.Clear();
                Query = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            waitCalculForEnd();

            Query = compressState.enCours;

            lock (_lock)
            {
                if (thCalcul == null)
                {
                    thCalcul = new Thread(calculLoop);
                    thCalcul.SetApartmentState(ApartmentState.STA);
                    thCalcul.Start();
                }

                if (thCopy == null)
                {
                    thCopy = new Thread(copyLoop);
                    thCopy.SetApartmentState(ApartmentState.STA);
                    thCopy.Start();
                }
            }


            OnPropertyChanged("Header");
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            logger.log("export:buildListIni");
            lock (_lock)
            {
                statAlbums.clear();
                listes = new List<List<PiecePrior>>();
                all = new List<PiecePrior>();
                dict = new Dict<int, PiecePrior>();
                masterDict = new Dict<int, PiecePrior>();
            }
            //  locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                    l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {

                    if (query != compressState.enCours)
                        return;
                    //var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(p.PieceId))
                    {
                        var pp = new PiecePrior(p, i);
                        i++;
                        all.Add(pp);
                        dict[p.PieceId] = pp;

                        //var piece = p.Track as CPiece;
                        //foreach (CFile file in piece.Files)
                        //{
                        //    var lp = locations[file.File];
                        //    if (lp == null)
                        //    {
                        //        lp = new List<PiecePrior>();
                        //        lp.Add(pp);
                        //        locations.Add(file.File, lp);
                        //    }
                        //    else
                        //    {
                        //        lp.Add(pp);
                        //        PiecePrior.mergePrior0(lp);
                        //    }
                        //}

                        var masterId = p.MasterId;
                        if (!masterDict.ContainsKey(masterId))
                            masterDict[masterId] = pp;


                    }
                }

                foreach (Piece p in l)
                {
                    if (query != compressState.enCours)
                        return;
                    dict[p.PieceId].setPrior0(masterDict[p.MasterId].Prior0);
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        private void waitCalculForEnd()
        {
            lock (_lock)
            {

                if (query == compressState.none)
                    return;
                if (query == compressState.enCours)
                    query = compressState.cancel;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                    if (endCalcul)
                        return;
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Calcul");
                }
            }

        }


        private void waitCopyForEnd()
        {
            lock (_lock)
            {
                if (copy == compressState.none)
                    return;
                if (copy == compressState.enCours)
                    copy = compressState.cancel;
                if (endCopy)
                    return;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                {
                    if (endCopy)
                        return;
                    if (query != compressState.enCours)
                    {
                        logger.log("abandon attente car query={0}", query);
                        return;
                    }
                }
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Copy");
                }
            }

        }


        [STAThread]
        private void copyLoop()
        {
            while (true)
            {
                try
                {
                    compressState _cp;
                    lock (_lock)
                        _cp = copy;
                    if (_cp != compressState.enCours)
                    {
                        Thread.Sleep(1000);
                        continue;
                    }

                    _copy();
                }

                catch (Exception ex)
                {
                    logger.log(ex.ToString());
                }
            }
        }


        [STAThread]
        private void calculLoop()
        {


            while (true)
            {
                try
                {
                    switch (Query)
                    {
                        case compressState.none: Thread.Sleep(1000); continue;

                        case compressState.enCours:
                            if (endCopyFinal)
                            {
                                Thread.Sleep(1000); continue;
                            }
                            break;
                        case compressState.reload:
                            waitCalculForEnd();
                            break;

                        case compressState.cancel:
                            {
                                waitCalculForEnd();
                                waitCopyForEnd();
                                Query = compressState.none;
                                nbLoop = 0;
                                Thread.Sleep(1000); continue;
                            }

                        default:
                            break;
                    }
                    lock (_lock)
                    {
                        endCalcul = false;
                        query = compressState.enCours;
                        nbLoop++;
                    }



                    buildListIni();

                    foreach (PlayListViewModel pl in playlists)
                    {
                        buildList(pl);
                    }

                    //foreach (List<PiecePrior> lp in locations.Values)
                    //{
                    //    PiecePrior.mergePrior1(lp);
                    //}

                    // concaténation
                    int max = 0;
                    list = new List<PiecePrior>();
                    foreach (var _l in listes)
                    {
                        if (query != compressState.enCours)
                            return;
                        var count_ = _l.Count;
                        if (count_ > max)
                            max = count_;
                    }
                    int count = listes.Count;

                    int nb = 0;
                    for (int i = 0; i < max; i++)
                    {
                        if (query != compressState.enCours)
                            return;
                        for (int j = 0; j < count; j++)
                        {
                            var l = listes[j];
                            if (i < l.Count)
                            {
                                var p = l[i];
                                p.setPrior(nb);
                                list.Add(p);
                                var master = masterDict[p.MasterId];
                                if (master != p)
                                    master.setPrior(nb);
                                nb++;
                            }
                        }
                    }

                    for (int i = 0; i < list.Count; i++)
                    {
                        if (query != compressState.enCours)
                            return;
                        var p = list[i];
                        var master = masterDict[p.MasterId];
                        if (master != p)
                            p.setPrior(master.Prior1);
                    }

                    list.Sort(new PriorComparer());
                    all.Sort(new PriorComparer());

                    waitCopyForEnd();
                    lock (_lock)
                    {
                        if (query != compressState.enCours)
                            continue;
                        App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                        endCopy = false; copy = compressState.enCours; endCopyFinal = false;
                    }

                    while (true)
                    {
                        Thread.Sleep(100);

                        if (endCopy || query != compressState.enCours)
                            break;

                    }


                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                    Thread.Sleep(1000);
                }

                finally
                {
                    lock (_lock)
                        endCalcul = true;


                }

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state;
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state;
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
            //  }
        }
        [STAThread]
        private void _copy()
        {
            PlayListViewModel.resetExport(exportState.none);
            try
            {
                List<PiecePrior> _list = null;
                lock (_lock)
                {
                    _list = new List<PiecePrior>(list);
                }
                foreach (PiecePrior piece in _list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Files;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            setExport(exportState.present, piece);
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new HashSet<int>();
                idCopieLoc = new HashSet<string>();
                //  presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;

                        int id = piece.PieceGen.MasterId;
                        if (idCopie.Contains(id))
                            continue;
                        var files = piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.Contains(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie.Add(id); // idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc.Add(file.File); // [file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                var f = FileRegister.Check(pertinent.Path); //  FileInfo f = new  FileInfo FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece + " )");
                                f.copyTree(conf.dir + pertinent.File, true);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                compressState _copy;
                lock (_lock)
                    _copy = copy;

                if (Query != compressState.none && _copy != compressState.none)
                {
                    var _status = string.Format("statusCalc={0} statusCopy={1} calc={2} copy={3}", endCalcul, endCopy, query, copy);
                    var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6} {7}",
                        listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""), _status);
                    App.log.log(log, CAPTION);
                    if (conf.oneShot)
                        ihm.InfoIHm(log, CAPTION);
                    //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                    //list = new List<PiecePrior>();
                    //listes = new List<List<PiecePrior>>(); 

                    if (_copy == compressState.enCours)
                    {
                        endCopyFinal = true;
                        // PlayListViewModel.resetExport(exportState.none);
                    }

                    OnPropertyChanged("Header");
                }

                lock (_lock)
                {
                    endCopy = true;
                    copy = compressState.none;
                }
                //var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                //    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                //App.log.log(log, CAPTION);
                //if (conf.oneShot)
                //    ihm.InfoIHm(log, CAPTION);
                ////  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                //list = null;
                //listes = null;

                //if (state == compressState.enCours)
                //{
                //}
                //else
                //    PlayListViewModel.resetExport(exportState.none);

                //lock (_lock)
                //    state = compressState.end;
                //OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCompress.cs">
    <content><![CDATA[
using System.Collections.Generic;
using pdb.db;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
using pdb.gen;
namespace pdb.player.ViewModel.Commande.PlayList
{
    class ExportCompress : ExportCmd
    {
        private List<CFile> files;
        private int index = 0;
        private int indexPresent = 0;
        List<PiecePrior> _all;


        public ExportCompress()
        {
        }
        public override string Header
        {
            get
            {
                string header = base.Header;
                if (header.Contains(ANNULATION_EXPORT))
                    return header;

                return "Exporter la liste et compresser si besoin";

            }
        }
        protected override void prepareExport()
        {
         //   BgDict<int, ITrackIdentity> dict = new BgDict<int, ITrackIdentity>();
            files = new List<CFile>();
            index = 0;
            indexPresent = 0;
            //foreach (PiecePrior track in list)
            //{
            //    int id = track.MasterId;
            //    dict[id] = track.Piece;
            //}

            _all = new List<PiecePrior>(all);
            _all.Reverse();

            // phase 1 compress
            foreach (PiecePrior p in _all)
            {
              
                getSecondaryFiles(p.Files);
            }
        }

        private void getSecondaryFiles(CListFile m_files)
        {
           // var m_files = piece.Files;
            if (m_files.Count <= 1)
                return;

            var l = new List<CFile>();
            foreach (CFile file in m_files)
            {
                if (FileRegister.Exist(conf.dir + file.File))
                {
                    l.Add(file);
                }
            }
            if (l.Count <= 1)
                return;

            l.Sort(new CFileComparer());

            for (int i = 1; i < l.Count; i++)
                files.Add(l[i]);
        }

        //private CFile getPertinentFile(CPiece piece)
        //{
        //    var m_files = piece.Files;
        //    if (m_files.Count < 1)
        //        return null;

        //    var l = new List<CFile>();
        //    foreach (CFile file in m_files)
        //    {
        //        if (FileRegister.Exist(conf.dir + file.File))
        //        {
        //            l.Add(file);
        //        }
        //    }
        //    if (l.Count < 1)
        //        return null;
        //    if (l.Count >= 2)
        //        l.Sort(new CFileComparer());

        //    return l[0];
        //}

        protected override bool noMoreSpace()
        {
            if (index >= files.Count)
            {
                return noMoreSpace2();
            }

            CFile file = null;
            while (true)
            {
                if (index >= files.Count)
                    return noMoreSpace2();
                file = files[index];
                string path = conf.dir + file.File;
                var fi = FileRegister.Check(path); 
                if (fi.Exists)
                {
                    misc.deleteFile(path,file.ToString());
                 //   freeSpace += fi.Length; 
                    return false;
                }
                index++;
            }
        }

        private bool noMoreSpace2()
        {
            if (indexPresent >= _all.Count)
                return true;
            while (true)
            {
                if (indexPresent >= _all.Count)
                    return true;
                var p = _all[indexPresent];
                int id = p.MasterId;
                if (!idCopie.Contains(id))
                {
                
                    var files = p.Files;

                    bool contFile = false;
                    foreach (CFile file in files)
                    {
                        if (idCopieLoc.Contains(file.File))
                        {
                            contFile = true;
                            break;
                        }
                    }

                    if (!contFile)
                    {
                        if (files.Exists)
                        {
                            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
                            
                            //App.log.log("supression fichiers de {0}", p);
                            foreach (CFile f in files)
                            {
                                string path = conf.dir + f.File;
                                var fv = FileRegister.Check(path); 
                                if (fv.Exists)
                                {
                                    misc.deleteFile(path, string.Format("{0} {1}", p,f));
                                  //  freeSpace += fv.Length; 
                                   // PlayListViewModel.setExport(piece.PieceId, exportState.delete);
                                    setExport(exportState.delete, p.PieceGen); 
                                    //if (track != null)
                                    //    track.ExportStatus = exportState.delete;
                                    nbFicherSup++;
                                    return false;
                                }
                            }
                        }
                    }
                }
                indexPresent++;

            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\ClassementCache.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;

namespace pdb.gen
{
    class ClassementCache
    {
        private string strClassement;
        private string _classNameAndRating;
        private decimal _classementValueDecimal=-1;
        private decimal _rapportClassement;

        public String ClassNameAndRating
        {
            get
            {
                if (_classNameAndRating == null)
                {
                    if (!isClassListNumeric)
                        _classNameAndRating = "";
                    else
                        _classNameAndRating = strClassement.Replace(".", "");
                }
                return _classNameAndRating;
            }
        }
        public decimal ClassementValueDecimal
        {
            get
            {
                if (_classementValueDecimal < 0)
                {
                    if (!isClassListNumeric) return 0;
                    string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                    _classementValueDecimal = Convert.ToDecimal(classNameAndRating);
                }
                return _classementValueDecimal;
            }
        }

        public decimal RapportClassement
        {
            get
            {
                decimal resultat = 0;
                try
                {
                    return Piece.getRapport(ClassNameAndRating);
                }
                catch
                {
                }
                _rapportClassement = resultat;               
                return _rapportClassement;
            }
        }

        public ClassementCache(string str)
        {
            this.strClassement = str;
        }

        public override string ToString()
        {
            return strClassement;
        }

        public override bool Equals(object obj)
        {

            return ToString().Equals(obj.ToString());
        }

        public override int GetHashCode()
        {
            return strClassement.GetHashCode();
        }

        private string ClassName
        {
            get
            {
                return strClassement.Split('.')[0];
            }
        }

        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }
    }

    class ClassementHash
    {
        private Dict<string, ClassementCache> dict = new Dict<string, ClassementCache>();
        public ClassementCache getCache(string className, int rating)
        {
            var str = string.Format("{0}.{1}", className, (rating / 20));
            var c = dict[str];
            if (c == null)
            {
                c = new ClassementCache(str);
                dict[str] = c;
            }
            return c;
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\AlbumMedianne.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\StackAlbum.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="ClassementCache.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfFilter.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
          //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
           // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && this == album.Next; } set { if (album != null) album.Moved = value; } }
        public bool Empeached { get { if (album == null) return false; return album.Empeached && this == album.Next; } set { if (album != null) album.Empeached = value; } }

        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch(); 
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }
        private static ClassementHash classementHash = new ClassementHash(); 
        private ClassementCache _classementCache;
        private ClassementCache ClassementCache
        {
            get
            {
                if (_classementCache == null)
                {
                    _classementCache = classementHash.getCache(track.ClassName, track.Rating); 
                }
                return _classementCache; 
            }
        }
        public virtual void invalidateCache()
        {
            _classementCache = null; 
            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
          //  _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();

        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

       // private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                return ClassementCache.ClassNameAndRating; 
            }
        }

       // private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                return ClassementCache.ClassementValueDecimal; 
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

       // private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                return ClassementCache.RapportClassement; 
                //if (parent != null)
                //    return parent.RapportClassement;
                //if (_rapportClassement != -1)
                //    return _rapportClassement;

                //decimal resultat = 0;
                //try
                //{
                //    return getRapport(ClassNameAndRating);
                //}
                //catch
                //{
                //}
                //_rapportClassement = resultat;
                //// _classementVirtuel = resultat; 
                //return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation(); 
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {
               
                foreach (DateTime dt in  track.DatesClassementBrut)
                {
                    if (dt> Piece.SeuilProvisoire)
                        return true; 
                }
                return false; 
              
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return; 
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
       // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true; 
                }
                return false; 
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut; 
            }
        }
    }




}

]]></content>
  </file>
</db>
