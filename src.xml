<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;
using pdb.podcast.Albums;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        // standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub, ISelectable
    {
        public const string PUB_DATE_FORMAT_COMMENT = "yyyy/MM/dd HH:mm";
        public const string PUB_DATE_FORMAT_DB = "dd/MM/yyyy HH:mm";
        private static Loader loader;
        public new static Loader Loader { set { loader = value; } }

        public new TrackAlbum TrackAlbum { get { return base.TrackAlbum as TrackAlbum; } }

        public override string AlbumKey { get { var alb = TrackAlbum; if (alb == null) return base.AlbumKey; return alb.AlbumKey; } }

        public int AlbumRating { get { return TrackAlbum.AlbumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.Name = name;

            native.AlbumRating = AlbumRating;
            if (rating != AlbumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.enabled;
            native.PlayedCount = this.playCount;
            var _comment = buildComment();
            if (!string.IsNullOrEmpty(_comment))
                native.Comment = _comment;
        }

        public string buildComment()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            if (pub2 > pub)
                comment = string.Format("{0}|{1}", Pub2.ToString(PUB_DATE_FORMAT_COMMENT), Pub.ToString(PUB_DATE_FORMAT_COMMENT));
            return comment;
        }

        public void BuildComment()
        {
            var comment = buildComment();
            if (!string.IsNullOrEmpty(comment) && comment != Comment)
                Comment = comment;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgClass.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void merge()
        {
            if (!isPresent())
                return;
            bgClass.add(new BgTaskImport(this));
        }

        public void import(TrackInfoItunes db)
        {
            this._album = db._album;
            // this.albumRating = db.albumRating;
            this.rating = db.rating;
            //this.rare = db.rare;
            //this.info = db.info;
            this.playCount = db.playCount;
            this.PlayedDate = db.PlayedDate;
            this.enabled = db.enabled;
            present = true;
            db.present = true;

            import();
        }

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        //private static int NB = 0;
        //private int iddebug;

        public TrackInfoItunes()
        {
            //NB++;
            //iddebug = NB;
        }

        public bool Deleted { get; set; }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        //  private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        // private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        //private LimitItem exclu;
        //public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            //var key = item.ID;
            //if (!listLoad0.ContainsKey(key))
            //    listLoad0.Add(key, item);
        }
        //public bool containsload(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listLoad0.ContainsKey(key);
        //}

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        //public bool containsSelect(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listSelected.ContainsKey(key);
        //}
        //public bool isPreselected { get { return listLoad0.Count > 0; } }
        //public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {

                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out;
            pub2 = o.pub2;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            TrackAlbum.AlbumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                Pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}


        public static void CheckPlay(TrackInfoItunes track)
        {
            track.played = isPlayed(track);
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            if (track.playCount <= 0)
            {
                if (playedLevel == DateTime.MinValue || track.PlayedDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }

            int rating = track.Rating;
            if (maxPlayed.ContainsKey(rating))
                return track.PlayedDate > maxPlayed[rating];
            return true;

        }


        public string ShortName { get { return getShortName(location); } }
        public static string getShortName(string location) { return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.Exist(hibernateLocation);
            return FileRegister.Exist(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        public void build(XmlReader reader)
        {

            location = reader.GetAttribute("f");
            if (Path.IsPathRooted(location))
            {
            }
            else
                location = TrackInfoItunes.DefaultFolder + location;


            hibernateLocation = reader.GetAttribute("hl");

            string album = reader.GetAttribute("alb");
            if (album != null)
                albumMgr.setAlbum(this, album);
            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                Pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("pub2");
            if (!string.IsNullOrEmpty(str))
                Pub2 = Convert.ToDateTime(str);

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                TrackAlbum.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (TrackAlbum.AlbumRating > 0 && rating == 0)
                rating = TrackAlbum.AlbumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            //if ("y" == reader.GetAttribute("rare"))
            //    TrackAlbum.Rare = true;
            //if ("y" == reader.GetAttribute("info"))
            //    TrackAlbum.Info = true;
            if ("y" == reader.GetAttribute("disabled"))
                enabled = false;
            else
                enabled = true;
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));



            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;



            CheckPlay(this);

        }

        public void readStat(XmlReader reader)
        {
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);
        }

        public bool SelectedByDb { get { return Selected; } }// || _in > _out; } }

        public void readStatGlobal(XmlReader reader)
        {
            DateTime oin = DateTime.MinValue;
            DateTime oout = DateTime.MinValue;
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                oin = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                oout = Convert.ToDateTime(str);

            if (oin > oout)
            {
                //sélectionné
                _gout = DateTime.MaxValue;
                return;
            }

            if (oout > _gout)
                _gout = oout;
        }

        //public void consolidStat()
        //{
        //    if (_in > DateTime.MinValue)
        //    {
        //        if (_in < _gin || _gin == DateTime.MinValue)
        //            _gin = _in; 
        //    }

        //    if (_out > _gout)
        //        _gout = _out; 
        //}



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import || loader.Slave)
            {
                copy = createCopy(this);
            }

            base.build(xTrack);

            TrackAlbum.AlbumRating = 0;

            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added; break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": TrackAlbum.AlbumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed)
                TrackAlbum.AlbumRating = 0;

            duree = new util.timeSpan(Duration);


            bool change = false;
            if (copy != null)
            {
                if (copy._album != null)
                    _album = copy._album;
                if (!string.IsNullOrEmpty(copy.name) && copy.name != name)
                {
                    log.log("import cause name '{0}' '{1}' {2}", name, copy.name, this);
                    name = copy.name;
                    change = true;
                }

                if (PlayedDate != copy.PlayedDate)
                {
                    log.log("import cause playDate '{0}' '{1}' {2}", PlayedDate, copy.PlayedDate, this);
                    PlayedDate = copy.PlayedDate;
                    change = true;
                }
                if (playCount != copy.playCount)
                {
                    log.log("import cause playCount '{0}' '{1}' {2}", playCount, copy.playCount, this);
                    change = true;
                    playCount = copy.playCount;
                }
                // albumRating = copy.albumRating;
                if (enabled != copy.enabled)
                {
                    log.log("import cause enabled '{0}' '{1}' {2}", enabled, copy.enabled, this);
                    enabled = copy.enabled;
                    change = true;
                }

                if (rating != copy.rating)
                {
                    log.log("import cause rating '{0}' '{1}' {2}", rating, copy.rating, this);
                    rating = copy.rating;
                    change = true;
                }
                if (pub2 != copy.pub2)
                {
                    log.log("import cause pub2 '{0}' '{1}' {2}", pub2, copy.pub2, this);
                    pub2 = copy.pub2;
                    change = true;
                }


                var comment = buildComment();
                if (!string.IsNullOrEmpty(comment) && comment != Comment)
                {
                    log.log("import cause comment '{0}' '{1}' {2}", Comment, comment, this);
                    change = true;
                }

                //var _comment = buildComment();
                //if (_comment != Comment)
                //    change = true;

                Duration = copy.Duration;
                duree = copy.duree;


            }
            PubLoader.setPub();

            CheckPlay(this);

            if (change)
            {
                import();
            }
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        private DateTime pub2;
        public DateTime Pub
        {
            get
            {
                return pub;
            }
            private set
            {
                var same = pub2 <= pub;
                pub = value;
                if (same)
                    pub2 = pub; 
            }
        }

        public DateTime Pub2
        {
            get { return pub2; }
            set
            {
                if (value > pub)
                    pub2 = value;
                else
                    pub2 = pub; 
               
            }
        }


        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
       new public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        //private DateTime _gin;
        //public DateTime Gin { get { return _gin; } }

        /// <summary>
        /// Dernier out global (MaxValue si encore sélectionné)
        /// </summary>
        private DateTime _gout;
        public DateTime Gout { get { return _gout; } set { _gout = value; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }


        public albumSpec Specif { get { return TrackAlbum.Specif; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        // private bool info;

        public bool Info
        {
            get { return TrackAlbum.Info; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        //  private bool rare;
        public bool Rare
        {
            get { return TrackAlbum.Rare; }
        }

        public bool Actu
        {
            get { return TrackAlbum.Actu; }
        }

        public bool Courant
        {
            get { return TrackAlbum.Courant; }
        }

        public bool Open { get { return TrackAlbum.Open; } }
        public bool Recent { get { return TrackAlbum.Recent; } }
        public bool UnAn { get { return TrackAlbum.UnAn; } }

        private bool played;
        public bool Played { get { return played; } }

        private bool globalSelected;
        public bool GlobalSelected { get { return globalSelected; } set { globalSelected = value; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
       // private bool inJournal = false;

        //public bool FreeInJournal { get { return Selected && !inJournal; } }
        //public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        public void clearLists()
        {
            selected = selectMode.none;
          //  exclu = null;
          //  inJournal = false;
            listSelected.Clear();// = new SequentialDictString<LimitItem>();
            //listLoad0 = new SequentialDictString<LimitItem>();
            //listStandAlone = new SequentialDictString<LimitItem>();
            //indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }
        private string pubInfoShort() { return pub.ToString("dd.MM.yy"); }
        private string getDayOfWeek()
        {
            var strDayOfWeek = "";
            switch (pub.DayOfWeek)
            {
                case DayOfWeek.Friday:
                    strDayOfWeek = "v";
                    break;
                case DayOfWeek.Monday:
                    strDayOfWeek = "l";
                    break;
                case DayOfWeek.Saturday:
                    strDayOfWeek = "s";
                    break;
                case DayOfWeek.Sunday:
                    strDayOfWeek = "d";
                    break;
                case DayOfWeek.Thursday:
                    strDayOfWeek = "j";
                    break;
                case DayOfWeek.Tuesday:
                    strDayOfWeek = "ma";
                    break;
                case DayOfWeek.Wednesday:
                    strDayOfWeek = "me";
                    break;
                default:
                    break;
            }

            return strDayOfWeek;
        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub();


            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {

                var target = NameWithDate;
                if (!target.Equals(Name))
                    Name = target;
                BuildComment();
                return;

                string infoShort = pubInfoShort();
                string infoPubName = pub.ToString("dd.MM.yyyy");
                string infoPubName2 = pub.ToString("dd/MM/yyyy");
                string infoPubName3 = pub.ToString("dd/MM/yy");
                string infoYear = Year.ToString();
                if (pub.DayOfYear == 1)
                {
                    infoPubName = pub.Year.ToString();
                    infoPubName2 = infoPubName;
                    infoPubName3 = infoPubName;
                    infoShort = infoPubName;
                }

                string name = Name;
                string str = name;

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                while (str.Contains(infoShort))
                    str = str.Replace(infoShort, "");
                while (str.Contains(infoPubName))
                    str = str.Replace(infoPubName, "");
                while (str.Contains(infoPubName2))
                    str = str.Replace(infoPubName2, "");
                while (str.Contains(infoPubName3))
                    str = str.Replace(infoPubName3, "");

                str = str.Trim();

                //if (regInfoShort.IsMatch(str))
                //{
                //    var strdate = regInfoShort.Match(str).Groups[1].Value;
                //    str = str.Replace(strdate, "");
                //}



                //Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l
                var strDayOfWeek = getDayOfWeek();
                var s1 = strDayOfWeek + " ";
                strDayOfWeek = " " + strDayOfWeek;

                while (str.EndsWith(strDayOfWeek))
                    str = str.Remove(str.Length - strDayOfWeek.Length - 1);
                //while (str.EndsWith(s1))
                //    str = str.Remove(str.Length - s1.Length);

                //if (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, infoShort);
                //else if (name.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, infoShort);

                //else
                //{
                //    if (!str.Contains(infoShort))
                //    {
                //        str = str + " " + infoShort;
                //    }
                //    else
                //    {
                //        if (Year > 1980 && str.Contains(infoYear))
                //            str = str.Replace(infoYear, "").Trim();
                //    }
                //}
                var strBUG = "30.12.99";
                if (str.Contains(strBUG))
                    str = str.Replace(strBUG, "");

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                str = str.Trim();

                str += " ";
                str += infoShort;


                str += strDayOfWeek;

                if (!str.Equals(name))
                    Name = str;

                BuildComment();
            }
        }
        // private LimitItem provider; 
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (!listSelected.ContainsKey(key))
                listSelected.Add(key, limit);



            if (selected == value)
                return;

            selected = value;
            if (isPresent() && !present)
            {
                // loader.resurrection(this);
            }




        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                this.Pub = value; 
            }
        }
        //DateTime IPub.Pub2
        //{
        //    get
        //    {
        //        return pub2;
        //    }
        //    set
        //    {
        //        pub2 = value;
        //    }
        //}

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                if (string.IsNullOrEmpty(this.Grouping))
                    setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }


        public string getLogicalName(string t)
        {

            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            var sw = getDayOfWeek();
            if (t.EndsWith(sw))
                t = t.Remove(t.Length - sw.Length).Trim();
            var strPub = pub.ToString("dd.MM.yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pubInfoShort();
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            if (t.EndsWith("-"))
                t = t.Remove(t.Length - 1).Trim();

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        public string NameWithDate
        {
            get { return string.Format("{0} {1} {2}", LogicalName, pubInfoShort(), getDayOfWeek()); }
        }

        public string LogicalName
        {
            get
            {
                return getLogicalName(name);
            }
        }

        //public override string Name
        //{
        //    get
        //    {
        //        return name;
        //    }
        //    set
        //    {
        //        if (value == null)
        //        {
        //            log.log("set Name null !!! {0}", this);
        //            return;
        //        }

        //        var thisLog = LogicalName;
        //        var newLog = getLogicalName(value);

        //        if (!thisLog.Equals(newLog, StringComparison.InvariantCultureIgnoreCase))
        //        {
        //            log.log("Modification du nom logique !!! {0}->{1} {2}", thisLog, newLog, this);
        //            return;
        //        }
        //        base.Name = value;
        //    }
        //}



        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Check(Location);
                    if (f.Exists)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        //private int indexRoot = -1;
        //public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }



        public static void setDate0(DateTime date) { Date0 = date; }
        private static DateTime Date0;
        private timeSpan ts;
        public timeSpan Ts
        {
            get
            {
                if (ts == default(timeSpan))
                {
                    if (Date0 == DateTime.MinValue)
                        throw new ApplicationException("Date0 pas initialisée");
                    ts = new timeSpan(Pub2 - Date0);
                }
                return ts;
            }
        }

        public void hibernate(FileValue fv, string dirH)
        {
            bgClass.add(new BgTaskHibernate(this, fv, dirH));
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Load;
using timeSpan = pdb.util.timeSpan;
using System.Diagnostics;


namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    public class AutoBuilder : IComparable<AutoBuilder>//, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private int nbDown;
        private bool? useForfait;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private DirConf source; public DirConf Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        //public const int STOP_MAX = 3;
        //private int _stopLevel = STOP_MAX;
        // private bool 


        private List<LimitItemLoader> loaders = new List<LimitItemLoader>();
        //public void buildLoaders()
        //{
        //    loaders = new List<LimitItemLoader>();
        //    source.buildLoaders(loaders, this);

        //}

        //public void go()
        //{
        //    var total = new timeSpan();
        //    var fd = new timeSpan();
        //    var d = new timeSpan();
        //    var date = new timeSpan();
        //    var nb = 0;

        //    var dict = new pdb.util.BgDictString0<TrackInfoItunes>();

        //    while (true)
        //    {
        //        var _total = timeSpan.MaxValue;
        //        var _fd = timeSpan.MaxValue;
        //        var _d = timeSpan.MaxValue;
        //        var _date = timeSpan.MaxValue;
        //        var _nb = int.MaxValue;

        //        foreach (LimitItemLoader loader in loaders)
        //        {
        //            loader.checkV(this, nb, fd, d, date);
        //            if (_total > loader._durationv)
        //                _total = loader._durationv;
        //            if (_fd > loader.Fd)
        //                _fd = loader.Fd;
        //            if (_date > loader._datev)
        //                _date = loader._datev;
        //            if (_nb > loader._nb)
        //                _nb = loader._nb;
        //        }
        //    }
        //}
        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(DirConf source)
        {
            this.source = source;
            source.addBorderObs(this);
            source.Auto = this;
        }

        //// private static bool loaded; 
        //public static void getLoaders()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.buildLoaders();
        //}

        //public static void test()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.go();
        //}

        private static AutoBuilder main;
        public static void clear() { list.Clear(); }
        public static void build(XmlNode xAuto, DirConf source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        mem.dict.Add(key, desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                List<string> toRemove = new List<string>();
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        toRemove.Add(key);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }

                foreach (string key in toRemove)
                    mem.dict.Remove(key);
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    //{
                    //    //if (!exist)
                    //    //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                    //    tw.Write(DateTime.Now); tw.Write(SEP);
                    //    tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(atomicMode); tw.Write(SEP);
                    //    tw.Write(state); tw.Write(SEP);
                    //    for (int i = 0; i < imax; i++)
                    //    {
                    //        if (i > 0)
                    //        {
                    //            tw.WriteLine();
                    //            for (int j = 0; j < 11; j++)
                    //                tw.Write(SEP);
                    //        }
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].item);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].item);
                    //        tw.Write(SEP);
                    //    }
                    //    tw.WriteLine();
                    //}
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
           // _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                //if (first)
                //    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                //throw new NotImplementedException(); 
                //AutoBuilder builder = null;
                //if (!started)
                //{
                //    started = true;
                //    foreach (AutoBuilder b in list)
                //        b.total = b.source.getTotalSize();
                //}
                //// application de la précédente modif
                //builder = list[index];
                //if (builder.state > builderstate.none)
                //{
                //    builder.makeEmpreinteNonSequence();
                //    decrementIndex();
                //}
                //int i = -1;
                //for (i = list.Count - 1; i >= 0; i--)
                //{
                //    builder = list[i];
                //    bool cango = false;
                //    bool _cont = false;
                //    while (true)
                //    {
                //        if (i == index || _cont)
                //        {
                //            cango = builder.check();
                //            index = i;
                //            main = builder;
                //            _cont = false;
                //            break;
                //        }
                //        else
                //            cango = builder.checkWithoutModify();
                //        if (builder.state == builderstate.none)
                //            _cont = true;
                //        else
                //            break;
                //    }
                //    if (!cango)
                //        _cango = false;
                //    if (builder.mustUpdate)
                //        MustUpdate = true;
                //    if (i == index)
                //    {
                //        if (builder.newv != builder.org)
                //        {
                //            _modifFile = true;
                //        }
                //        else
                //        {
                //            //index--;
                //            //if (index < 0)
                //            //    index = list.Count - 1;
                //        }
                //    }
                //    if (_modifFile)
                //        break;
                //}
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                {
                    _cango = false;
                    break;
                }
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        //private bool check()
        //{
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();
        //    if (state == builderstate.none)
        //        reset();
        //    else if (state == builderstate.stable)
        //    {
        //        if (newEmpreinte != _empreinte)
        //            reset();
        //        else
        //        {
        //            mustUpdate = false;
        //            canGo = true;
        //            org = newv;
        //            return true;
        //        }
        //    }
        //    if (Conf.AutoSequence || total < 0)
        //        total = source.getTotalSize();
        //    double target = conf.target;
        //    delta = target - total;
        //    log("delta {0}", delta);
        //    if (state == builderstate.none)
        //        delta0 = delta;
        //    state = builderstate.enCours;
        //    lastd = d;
        //    d = 0;
        //    xml = null;
        //    lookup(xmlRoot);
        //    if (xml == null)
        //        return true;
        //    string attTarget = conf.type.ToString();
        //    var att = xml.Attributes[attTarget];
        //    if (att == null)
        //        return true;
        //    org = Convert.ToDouble(att.Value);
        //    newv = org;
        //    try
        //    {
        //        if (delta * delta0 < 0)
        //        {
        //            if (atomicMode < 0)
        //            {
        //                atomicMode = 0;
        //                //if (minMem == null)
        //                //    minMem = new Memory(mem0);
        //                //if (maxMem == null)
        //                //    maxMem = new Memory(mem0);
        //                //if (minMem.suppressions.Count == 0)
        //                //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
        //                //if (maxMem.ajouts.Count == 0)
        //                //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
        //            }
        //        }
        //        bool cancelSameConf = false;
        //        bool cancelNb = false;
        //        if (atomicMode >= 0)
        //        {
        //            atomicMode++;
        //            if (Math.Abs(dmin - delta) < EPSILON)
        //                sameConfiguration++;
        //            else if (Math.Abs(dmax - delta) < EPSILON)
        //                sameConfiguration++;
        //            else
        //                sameConfiguration = 0;
        //            if (sameConfiguration > conf.idem)
        //                cancelSameConf = true;
        //            if (atomicMode > conf.cloop)
        //                cancelNb = true;
        //        }
        //        if (delta >= 0)
        //        {
        //            if (mem0.suppressions.Count > 0)
        //                minMem = new Memory(mem0);
        //            if (delta < conf.write)
        //                canGo = true;
        //            //  lastGoodLevel = org;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            if (atomicMode > 0)
        //            {
        //                if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
        //                {
        //                    log("abandon recherche cartésienne cause idem");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                //if (Math.Abs(dmin - delta) < 0.01)
        //                //    dminAlready = true;
        //                //else
        //                //    dminAlready = false;
        //                if (maxMem != null && minMem != null)
        //                {
        //                    if (minMem.suppressions.Count == maxMem.ajouts.Count)
        //                    {
        //                        bool identique = true;
        //                        for (int i = 0; i < minMem.suppressions.Count; i++)
        //                        {
        //                            if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                            {
        //                                identique = false;
        //                                break;
        //                            }
        //                        }
        //                        if (identique)
        //                        {
        //                            if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
        //                            {
        //                                mustUpdate = false;
        //                                log("abandon recherche cartésienne cause cycle");
        //                                state = builderstate.stable;
        //                                _empreinte = newEmpreinte;
        //                                return true;
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //            cmin = org;
        //            dmin = delta;
        //            // lastGoodDelta = (int)delta;
        //            lastTotal = (int)total;
        //            if (delta < conf.delta)
        //            {
        //                state = builderstate.stable;
        //                _empreinte = newEmpreinte;
        //                return true;
        //            }
        //            mustUpdate = true;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                //if (atomicMode > conf.cloop)
        //                //{
        //                //    mustUpdate = false;
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    state = builderstate.stable;
        //                //    _empreinte = newEmpreinte;
        //                //    return true;
        //                //}
        //                //if (dminAlready && dmaxAlready)
        //                //{
        //                //    mustUpdate = false;
        //                //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
        //                //    return true;
        //                //}
        //                d = 0.5 * (cmax - cmin);
        //            }
        //            else
        //            {
        //                double _d = int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmax - cmin;
        //                double aux = int.MaxValue;
        //                // double aux2 = int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - level.d) * level.inf;
        //                    if (aux > d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {

        //                    if (org > conf.max)
        //                        d = conf.max - org;
        //                    else
        //                    {
        //                        d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 < d)
        //                //    d = aux2;

        //                if (d > _d)
        //                    d = _d;
        //            }
        //        }
        //        else if (delta < 0)
        //        {
        //            if (mem0.ajouts.Count > 0)
        //                maxMem = new Memory(mem0);
        //            mustUpdate = true;
        //            canGo = false;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            //    if (atomicMode < 0)
        //            //        atomicMode = 0;
        //            //    atomicMode++;
        //            //}
        //            cmax = org;
        //            dmax = delta;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                bool identique = false;
        //                if (minMem != null && maxMem != null
        //                    && maxMem.ajouts.Count == minMem.suppressions.Count)
        //                {
        //                    identique = true;
        //                    for (int i = 0; i < minMem.suppressions.Count; i++)
        //                    {
        //                        if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                        {
        //                            identique = false;
        //                            break;
        //                        }
        //                    }
        //                }
        //                if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
        //                {
        //                    log("retour derniere bonne valeur cause idem");
        //                    d = cmin - cmax;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    d = cmin - cmax;
        //                }
        //                else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
        //                {
        //                    log("retour derniere bonne valeur cause cycle");
        //                    d = cmin - cmax;
        //                }
        //                //else if (atomicMode > conf.cloop)
        //                //{                      
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    d = cmin - cmax;
        //                //}
        //                else
        //                    d = 0.5 * (cmin - cmax);
        //            }
        //            else
        //            {

        //                double _d = -int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmin - cmax;
        //                double aux = -int.MaxValue;
        //                // double aux2 = -int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - conf.delta + level.d) * level.sup;
        //                    if (aux < d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {
        //                    if (org < conf.min)
        //                        d = (conf.min - org);
        //                    else
        //                    {
        //                        d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 > d)
        //                //    d = aux2;

        //                if (d < _d)
        //                    d = _d;
        //            }
        //            //d = (delta - conf.delta) * conf.sup;
        //            //if (org <= lastGoodLevel)
        //            //{
        //            //    lastGoodLevel = -1;
        //            //    lastGoodDelta = -1;
        //            //    lastTotal = -1;
        //            //}
        //        }
        //        if (Math.Abs(d) < 0.00000001)
        //        {
        //            mustUpdate = false;
        //            // unCart();
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        //if (dejaVu)
        //        //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
        //        log("correction {0}", d);
        //        newv = org + d;
        //        if (newv <= 0)
        //            newv = 0;
        //        if (conf.coeff > 0)
        //        {
        //            if (newv > conf.max)
        //                newv = conf.max;
        //            else if (newv < conf.min)
        //                newv = conf.min;
        //        }
        //        newv = Math.Round(newv, 8);
        //        log(" valeur {0} --> {1}", org, newv);
        //        att.Value = newv.ToString();
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }
        //        string strDate = "";
        //        var attD = xml.Attributes["date"];
        //        if (attD != null)
        //            strDate = attD.Value;
        //        bool exist = File.Exists(file);
        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        //private void calcChoose(bool up, bool strict, bool checkSelect)
        //{
        //    choose = null;
        //    double dt = double.MaxValue;
        //    double gap = double.MaxValue;
        //    // bool trou = false;
        //    foreach (AutoBuilderItem item in items)
        //    {
        //        item.after(up, strict, checkSelect);
        //        item.setTension(up, strict, checkSelect);
        //        if (item.Stop(_stopLevel))
        //        {
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }
        //        double aux = double.MaxValue;
        //        // var tension = item.Tension;
        //        if (conf.selectFix)
        //        {
        //            var tension = item.Tension;
        //            aux = up ? tension : -tension;
        //        }
        //        else
        //            aux = item.Dt;

        //        if (conf.selectAbs && !conf.selectFix && aux < 0)
        //            aux *= -1;



        //        if (item.getCauses().Count == 0)
        //        {
        //            // trou = true;
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }

        //        //var _gap = Math.Abs(aux);
        //        //if (_gap < gap)
        //        //    gap = _gap;

        //        if (aux < dt)
        //        {
        //            dt = aux;
        //            newv = item.NewV;
        //            choose = item;
        //        }
        //    }
        //    //if (trou && conf.gap && gap < double.MaxValue)
        //    //{
        //    //    foreach (AutoBuilderItem item in items)
        //    //    {
        //    //        if (item.Stop)
        //    //            continue;
        //    //        item.gap(up, conf.selectFix, gap);
        //    //    }
        //    //}
        //}

        //private bool check2()
        //{
        //    // _modifFile = false; 
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




        //    if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
        //    {
        //        if (conf.pertinentExclu)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item != choose)
        //                    item.makePertinent();
        //            }
        //        }
        //        else if (conf.pertinentAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //                item.makePertinent();
        //        }
        //        else
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                item.checkAjout(mem0.tajouts);
        //                item.checkAjout(mem0.tsuppressions);
        //            }
        //        }


        //        //else if (choose != null)
        //        //    choose.makePertinent();
        //    }
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();

        //    try
        //    {
        //        if (state == builderstate.none)
        //            reset();
        //        else if (state == builderstate.stable)
        //        {
        //            if (newEmpreinte != _empreinte)
        //                reset();
        //            else
        //            {
        //                mustUpdate = false;
        //                canGo = true;
        //                org = newv;
        //                return true;
        //            }
        //        }

        //        total = source.getTotalSize();
        //        double target = conf.target;
        //        delta = target - total;
        //        log("delta {0}", delta);

        //        if (_stopLevel < 0)
        //        {
        //            log("arret cause stopLevel");
        //            state = builderstate.stable;
        //            return true;
        //        }
        //        if (delta * lastDelta < 0)
        //        {
        //            //if (delta > 0)
        //            //{
        //            //    // ok!
        //            //    state = builderstate.stable;
        //            //    _empreinte = newEmpreinte;
        //            //    return true;
        //            //}
        //            // retour arrière
        //            if (choose != null && _stopLevel > 0)
        //            {
        //                log("retour arrière");
        //                _stopLevel--;
        //                choose.stop(_stopLevel);
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //            else
        //            {
        //                if (delta > 0)
        //                {
        //                    // ok!
        //                    log("pas de retour arriere stoplevel=0");
        //                    state = builderstate.stable;
        //                    _empreinte = newEmpreinte;
        //                    return true;
        //                }
        //                else
        //                {
        //                    _stopLevel--;
        //                    choose.stop(_stopLevel);
        //                    canGo = false;
        //                    mustUpdate = true;
        //                    return false;
        //                }
        //            }
        //        }
        //        lastDelta = delta;
        //        if (state == builderstate.none)
        //            delta0 = delta;
        //        state = builderstate.enCours;
        //        lastd = d;
        //        d = 0;

        //        bool up = delta > 0;
        //        if (up && delta < conf.delta)
        //        {
        //            log("delta");
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        mustUpdate = true;
        //        //double dt = double.MaxValue;

        //        //bool real = true;
        //        //if (delta * delta0 < 0)
        //        //{
        //        //    if (choose != null)
        //        //    {
        //        //        _stopLevel--;
        //        //        choose.stop(_stopLevel);
        //        //    }
        //        //    canGo = false;
        //        //    mustUpdate = true;
        //        //    return false;
        //        //}
        //        if (conf.stopAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item.Stop(1))
        //                {
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //            }
        //        }



        //        choose = null;
        //        if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
        //            calcChoose(up, true, true);
        //        if (choose != null)
        //            log("REEL - SELECT");
        //        else
        //        {
        //            if (_stopLevel >= 2 && conf.checkSelect)
        //                calcChoose(up, false, true);
        //            if (choose != null)
        //                log("VIRTUEL SELECT");
        //            else
        //            {
        //                if (_stopLevel >= 1 && conf.checkStrict)
        //                    calcChoose(up, true, false);
        //                if (choose != null)
        //                    log("REEL");
        //                else
        //                {
        //                    if (_stopLevel >= 0)
        //                    {
        //                        calcChoose(up, false, false);
        //                        if (choose != null)
        //                            log("VIRTUEL");
        //                    }
        //                }
        //            }
        //        }


        //        if (choose == null)
        //        {
        //            log("choose null");
        //            _stopLevel--;
        //            if (_stopLevel < 0)
        //            {
        //                state = builderstate.stable;
        //                return true;
        //            }
        //            else
        //            {
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //        }

        //        org = choose.Org;



        //        if (up)
        //        {
        //            if (delta < conf.write)
        //                canGo = true;
        //            if (conf.checkEvol)
        //            {
        //                // var nextTrack = choose.rejected(real).candidat;
        //                var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
        //                if (delta < size)
        //                {
        //                    _stopLevel--;
        //                    // choose.stop();
        //                    if (conf.stopAll)
        //                    {
        //                        foreach (AutoBuilderItem item in items)
        //                            item.stop(_stopLevel);
        //                        //state = builderstate.stable;
        //                        //return true;
        //                    }
        //                    else
        //                    {
        //                        choose.stop(_stopLevel);
        //                    }
        //                }
        //            }

        //        }
        //        else
        //        {
        //        }
        //        choose.save();
        //        Program.logAuto.log("===> " + choose.ToString());
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }

        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    bool exist = File.Exists(file);
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
            {
                item.Candidat = null;
                item.limit = null;
                item.setTension();
            }
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }

            setDelta();


        }

        public static void SetDelta()
        {
            foreach (AutoBuilder item in list)
            {
                item.setDelta();
            }
        }

        private void setDelta()
        {
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            // log("delta {0}", delta);
        }

        private bool goBack; 

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }



                //if (_stopLevel < 0)
                //{
                //    log("arret cause stopLevel");
                //    state = builderstate.stable;
                //    return true;
                //}
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        if (conf.forfaitNegatif > 0 && true == useForfait)
                        {
                            useForfait = false;
                        }
                        else
                        {
                            if (conf.stopAll || !goBack)
                            {
                                // ok!
                                log("pas de retour arriere");
                                state = builderstate.stable;
                                _empreinte = newEmpreinte;
                                useForfait = null;
                                return true;
                            }
                        }
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                      //  _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null )//&& _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop();
                            }
                        }

                        // il reste des items ?
                        goBack = items.Find( i=> !i.Stopped) != null; 
                        return false;
                    }

                }

                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;

                if (up)
                    nbDown = 0;
                else
                    nbDown++;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    useForfait = null;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                //if (conf.stopAll)
                //{
                //    throw new NotImplementedException(); 
                //    //foreach (AutoBuilderItem item in items)
                //    //{
                //    //    if (item.Stop(1))
                //    //    {
                //    //        state = builderstate.stable;
                //    //        useForfait = null;
                //    //        return true;
                //    //    }
                //    //}
                //}

                if (_cause == null)
                {
                    Debugger.Launch(); 

                    log("_cause NULL");
                    return false; 

                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }

                var cdv = _cause.causes;
                chooses.Clear();


                foreach (CauseDataValue cd in cdv.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Update)
                        continue;

                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;
                    if (item.Stopped)
                        continue; 
                    item.save(cd.val);
                    chooses.Add(item);
                    // item.Cause = cd;
                    item.Candidat = cdv.candidat;
                    item.limit = cdv.limit;

                }

                if (!up && conf.forfaitNegatif > 0)
                {

                    if (nbDown > conf.forfaitNegatifOffset)
                    {
                        useForfait = true;
                        foreach (var item in items)
                        {
                            var tension = item.Tension;
                            tension -= conf.forfaitNegatif * (nbDown - conf.forfaitNegatifOffset);
                            if (tension < 0)
                                tension = 0;
                            item.modif(tension);
                            chooses.Add(item);
                        }
                    }
                }

                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    bool exist = File.Exists(file);
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9}) ", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.Append(nbDown);
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
            {
                sb.Append(item);
            }
            sb.AppendLine("-----------------------------------------");
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
          //  Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        //private CauseRegister causeRegister = new CauseRegister();
        //public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            // causeRegister.signal(cd);
            //     if (nb > 1) // OUAILLE ?
            checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            if (Conf.AutoSelect)
            {
                bool selected = cause.Selected;
                if (up && selected)
                    return;
                if (!up && !selected)
                    return;
            }

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                double tot = 0;
                bool _checked = false;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;
                  
                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (item.Stopped)
                        continue; 

                    if (cd.val <= item.torg)
                        continue;

                    _checked = true;

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    tot += (tension * tension);
                    if (_cause != null && tot >= _cause.tension)
                        return;

                    cd.Update = true;

                }
                if (tot > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                    && (_cause == null || tot < _cause.tension))
                    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}



                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (item.Stopped)
                        continue; 

                    if (cd.val >= item.torg)
                        continue;

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        //  private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        //private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        private List<TrackInfoItunes> candidats = new List<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            init(parent, limit);
        }

        public void init(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        //public timeSpan _durationv;
        //public timeSpan _datev;
        //private timeSpan _fd;
        //public timeSpan Fd { get { return _fd; } }

        public int _nb;

        //public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        //{
        //    BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

        //    int nbMin = int.MaxValue;
        //    timeSpan fdMin = timeSpan.MaxValue;
        //    timeSpan dMin = timeSpan.MaxValue;
        //    timeSpan dateMin = timeSpan.MaxValue;
        //    foreach (FeedLimitItemLoader loader in loaders.Values)
        //    {
        //        loader.checkV(nb, fd);
        //        var _nb = loader.NbV;
        //        var _fd = loader.FdV;
        //        if (_nb > nb && _nb < nbMin)
        //            nbMin = _nb;
        //        if (_fd > fd && fd < fdMin)
        //            fdMin = _fd;
        //        for (int i = 0; i <= loader.IndexV; i++)
        //        {
        //            var track = loader.Candidats[i];
        //            if (dict.ContainsKey(track.Location))
        //                continue;
        //            var _d = currentDuration + track.Duree;
        //            if (_d > d && d < dMin)
        //                dMin = _d;
        //            var _date = track.Ts;
        //            if (_date > date && _date < dateMin)
        //                dateMin = _date;
        //            break;
        //        }



        //    }

        //    this._durationv = dMin;
        //    this._datev = dateMin;
        //    this._nb = nbMin;
        //    this._fd = fdMin;
        //}

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0)
                return;

            if (!limit.OverwriteConf && limit.Nb2 == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                //var location = candidat.Location;
                //if (string.IsNullOrEmpty(location))
                //    continue;

                //if (standAlone.ContainsKey(location))
                //    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                candidats.Add(candidat);
                //  standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                //var loader = getLoader(candidat);
                //loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(TrackInfoItunes candidat)
        {
            return limit.Dir.Loader.Albums.Get(candidat);
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            //loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            //legacy = new SequentialDictString<TrackInfoItunes>();
            //legacyRelax = new SequentialDictString<TrackInfoItunes>();
            //selected = new SequentialDictString<TrackInfoItunes>();
            //exclu = new SequentialDictString<TrackInfoItunes>();

            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();
            use.Clear();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            trackDurationMax = new timeSpan();
            trackDurationMin = new timeSpan();

            //var aux = new List<TrackInfoItunes>(candidats.Count);
            //foreach (TrackInfoItunes track in candidats)
            //{
            //    var copy = TrackInfoItunes.createCopy(track);
            //    aux.Add(copy);
            //}

            //candidats = aux; 
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in limit.Dir.Loader.Albums)
                loader.phase2();
        }

        //public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        //{
        //    if (itemSource == limit)
        //        return;
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    bool transmitTotal = limit.Dir.TransmitTotalGuest;
        //    //if (transmitTotal && legacy.ContainsKey(location))
        //    //    return;
        //    //if (!transmitTotal && legacyRelax.ContainsKey(location))
        //    //    return;


        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {

        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    if (transmitTotal && legacy.ContainsKey(location))
        //        return;
        //    if (!transmitTotal && legacyRelax.ContainsKey(location))
        //        return;
        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {
        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);

        //    }
        //}



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0)
                return;

            //  var histo = limit.Dir.Histo;

            //var relax = legacyRelax.List;
            //if (relax.Count > 0)
            //{
            //    if (histo)
            //        relax.Sort(new PodCastComparerPub2());
            //    else
            //        relax.Sort(new PodCastComparerInv());
            //    selection(relax, false, false);
            //}

            //var list = legacy.List;
            //if (list.Count > 0)
            //{
            //    if (histo)
            //        list.Sort(new PodCastComparerPub2());
            //    else
            //        list.Sort(new PodCastComparerInv());
            //    selection(list, false, true);
            //}

            if (candidats.Count > 0)
            {
                selection(candidats);
            }



            //var list2 = standAlone.List;
            //if (list2.Count > 0)
            //{
            //    //if (histo)
            //    //    list2.Sort(new PodCastComparerPub2());
            //    //else
            //    //    list2.Sort(new PodCastComparerInv());

            //    selection(list2); //, true, true);
            //}

        }


        private class FdResponse
        {
            public int nb;
            public timeSpan duree;
            public bool okFd;
            public bool okNb;
            public bool Result { get { return okFd && okNb; } }


        }

        FdResponse check(FeedLimitItemLoader loader, TrackInfoItunes candidat, LimitItem limit)
        {           
            var response = new FdResponse();

            var _nb = loader.Nb;

            if (!loader.isSelected(candidat))
                _nb++;
            response.nb = _nb;

            response.duree = loader.fd;

            var conf = loader.album.ConfAlbum;

            int _nbMax = limit.getNb(conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
            var __durationMax = limit.getFd(conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
            var _durationMax = timeSpan.FromMinutes(__durationMax);

            response.okNb = _nb <= _nbMax;
            response.okFd = response.duree <= _durationMax;

            return response;

        }

        private void selection(List<TrackInfoItunes> list)
        {
            var duration = limit.getDuration();

            var durationMax = timeSpan.FromMinutes(duration);

            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.ConfAlbum.checkPub ? candidat.Pub : candidat.Pub2;

                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat);



                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                // okTotalDuration = currentDuration <= durationMax;

                //  bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                FdResponse response = null;
                //if (!increment) // données venant de sous-dossier (histo, voisins....)
                //{
                //    response = check(loader, candidat, limit);
                //    _control = response == null || response.Result;
                //    //  _control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);
                //    //if (_control && !selectedByFd.ContainsKey(location))
                //    //    selectedByFd.Add(location, candidat);
                //    //if (!manageByFd.ContainsKey(location))
                //    //    manageByFd.Add(location, candidat);
                //}



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;


                var newDuration = currentDuration + candidat.Duree;
                bool okTotalDuration = newDuration <= durationMax;
                //if (manageByFd.ContainsKey(location))
                //{
                //    _control = false;
                //    if (selectedByFd.ContainsKey(location))
                //        _control = true;
                //}
                //else
                //{
                response = check(loader, candidat, limit);
                bool _control = response == null || response.Result;
                //_control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);

                //}

                if (_control)
                {
                    //currentDurationVirtual += candidat.Duree;
                    if (okDate)
                        currentDuration = newDuration;
                }


                // newDuration = currentDuration;
                //if (_control && !selectedByFd.ContainsKey(location))
                //    selectedByFd.Add(location, candidat);
                //if (!manageByFd.ContainsKey(location))
                //    manageByFd.Add(location, candidat);
                //  okTotalDuration = newDuration <= durationMax;






                bool go = okDate && _control && okTotalDuration;
                if (go)
                {
                    loader.record(candidat);
                    if (LimitItemLoader.ModeSelection)
                    {
                        candidat.select(selectMode.simple, limit);
                        limit.Dir.Feeds.recordTrack(candidat, limit);
                    }

                    //report aux niveaux inférieurs
                    // if (real)
                    // parent.recordLimitItemCandidat(candidat, limit);
                    // return true;

                }

                if (!_selection)
                {

                    if (limit.canSignal() && response != null)
                    {



                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                            //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                            //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                            //, okTotalDuration, newDuration, candidat, limit);
                                response.okFd, response.duree
                        , response.okNb, response.nb
                        , okTotalDuration, newDuration, candidat, limit);

                        limit.signal(dataAuto);
                    }

                }




                //newDuration = currentDuration;
                //okTotalDuration = newDuration <= durationMax;
                if (!okTotalDuration)
                {
                    //if (!Logger.CreateNullLoggers)
                    //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                    if (_selection)
                        limit.DurationLimitAtteinte = true;
                    if (durationStop.Value == 0)
                    {
                        // currentDuration = newDuration;
                        durationStop = currentDuration;
                    }

                    if (Conf.AutoSelect)
                        continue;
                    else
                        break;

                }

                if (!okDate)
                    break;

                if (!_control)
                    continue;




                if (_selection && !newContribut)
                {
                    // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                    currentContrib += candidat.Duree;
                    if (currentContrib > contributionMax)
                    {
                        // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                        limit.ContributionLimitAtteinte = true;
                        break;
                    }

                    use.Add(candidat);
                }

                //   currentDuration = newDuration;




                if (_selection)
                {
                    // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                    limit.Dir.recordTrack(candidat, limit);
                    // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                    //  limit.Dir.recordTrack(candidat, limit);

                    //  selected.Add(location, candidat);

                    //if (select)
                    //    exclu.Add(location, candidat);
                }







            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
</db>
